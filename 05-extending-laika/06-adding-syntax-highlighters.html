<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link rel="stylesheet" href="../icons/icofont.min.css">
    <link href="../css/container.css" rel="stylesheet">
    <link href="../css/content.css" rel="stylesheet">
    <link href="../css/nav.css" rel="stylesheet">
    <link href="../css/code.css" rel="stylesheet">

    <script src="../js/theme.js"></script>
    <script> /* for avoiding page load transitions */ </script>

  </head>

  <body>

    <nav id="sidebar">

      <a id="close-nav-icon">
        <i class="icofont-close-circled icofont-xlg"></i>
      </a>

      <ul class="nav nav-list">

        
        <li><a href="../table-of-contents.html">Table of Contents</a></li>
        <li class="nav-header">About Laika</li>
        <li><a href="../01-about-laika/01-features.html">Features</a></li>
        <li><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
        <li class="nav-header">Running Laika</li>
        <li><a href="../02-running-laika/01-sbt-plugin.html">sbt Plugin</a></li>
        <li><a href="../02-running-laika/02-library-api.html">Library API</a></li>
        <li><a href="../02-running-laika/03-configuration.html">Configuration</a></li>
        <li class="nav-header">Preparing Content</li>
        <li><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
        <li><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
        <li><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
        <li><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
        <li class="nav-header">Customizing Laika</li>
        <li><a href="../04-customizing-laika/01-overview.html">Overview</a></li>
        <li><a href="../04-customizing-laika/03-creating-templates.html">Creating Templates</a></li>
        <li><a href="../04-customizing-laika/04-document-ast.html">The Document AST</a></li>
        <li><a href="../04-customizing-laika/05-ast-rewriting.html">AST Rewriting</a></li>
        <li><a href="../04-customizing-laika/06-overriding-renderers.html">Overriding Renderers</a></li>
        <li class="nav-header">Extending Laika</li>
        <li><a href="01-overview.html">Overview</a></li>
        <li><a href="03-implementing-directives.html">Implementing Directives</a></li>
        <li><a href="04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
        <li class="active"><a href="#">Adding Syntax Highlighters</a></li>
        <li><a href="07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
        <li class="nav-header">Sub-Modules</li>
        <li><a href="../06-sub-modules/02-laikas-parser-combinators.html">Laika&#39;s Parser Combinators</a></li>
        <li><a href="../06-sub-modules/03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
        <li class="nav-header">Reference</li>
        <li><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
        <li><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
        <li><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
        <li><a href="../07-reference/06-release-notes.html">Release Notes</a></li>
        <li><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
        
        <li class="nav-header">Project Links</li>
        <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
        <li><a href="../api/laika/api/">API Documentation</a></li>
        <li><a href="http://planet42.org/">Demo App</a></li>
        
      </ul>

    </nav>

    <div id="container">

      <a id="open-nav-icon">
        <i class="icofont-navigation-menu icofont-xlg"></i>
      </a>

      <main class="content">

        <div class="page-header">
        <h1 id="adding-syntax-highlighters" class="title">Adding Syntax Highlighters</h1>
        </div>
        <p>Laika has its own built-in syntax highlighters (based on its parser combinators). </p>
        <p>This manual itself is a showcase for this functionality. 
        All code samples shown are highlighted by Laika&#39;s own syntax support. </p>
        <p>This chapter explains the general design goals as well as the basic building blocks for adding your own highlighters.</p>
        
        <h2 id="design-goals" class="section">Design Goals</h2>
        <ul>
          <li>
            <p><strong>Everything is pluggable and customizable.</strong></p>
            <p>This includes making it easy to add support for additional languages as well as ignoring the built-in
            highlighter altogether and use external tools like <code>highlight.js</code> instead.</p>
          </li>
          <li>
            <p><strong>The mechanism is not tied to HTML output.</strong></p>
            <p>The analyzed code is part of the document AST and can be processed and transformed like other
            AST nodes before rendering, making it a part of the common processing pipeline and not a bolt-on step after rendering,
            that would require the availability of JavaScript for the rendered output for example.</p>
            <p>This way the highlighted nodes can be rendered in any output format like EPUB, PDF or any 3rd-party format.</p>
          </li>
          <li>
            <p><strong>Focus on display comfort over validation.</strong></p>
            <p>It&#39;s primary use case is documentation or blogs, where the highlighter is supposed to improve the readability
            of the code.
            It is not designed to serve as a basis for code editors or include error highlighting and messages.</p>
            <p>Therefore it is also beyond the scope of this utility to detect larger constructs like entire method signatures.
            In some languages like Java this would come with a lot of ambiguity as a method declaration does not start 
            with a keyword like <code>def</code>.
            It would require to get much closer to having a full blown lexer and analyzer for the language than this
            utility is designed for.</p>
            <p>As a consequence its syntax definitions are more similar in scope and precision to those of lightweight tools
            like <code>highlight.js</code> than to the lower-level nature of sublime-text syntax definitions for example.
            If validation is required the recommended approach in Laika is to rely on other tools like MDoc for Scala
            validation and then only use Laika for highlighting the result.</p>
          </li>
          <li>
            <p><strong>Avoiding the regular expression mazes of other tools.</strong></p>
            <p>It offers a lot of higher level building blocks for assembling highlighters for common constructs like 
            string or number literals which are often quite similar between languages.
            The definitions then become more of a declarative list of supported constructs.</p>
            <p>But even in cases where a custom parser is required, it encourages the use of Laika&#39;s built-in parser combinator 
            framework, 
            which is a more composable and type-safe way to define a parser than a cryptic (and stringly) regular expression.</p>
            <p>None of the built-in parsers for text markup, HOCON, CSS or syntax highlighting use any regular expressions.</p>
          </li>
        </ul>
        
        <h2 id="prerequisites" class="section">Prerequisites</h2>
        <p>The content of this chapter builds on top of concepts introduced in other chapters.</p>
        <p>First, even though Laika&#39;s highlighting support defines a lot of higher level building blocks that
        allow for a mere declarative assembling of the supported constructs for a language,
        some additions of custom parsers might be necessary, depending on the complexity of the target language.
        In that case it&#39;s recommended to use <a href="../06-sub-modules/02-laikas-parser-combinators.html#laika-s-parser-combinators">Laika&#39;s Parser Combinators</a>.</p>
        <p>Second, highlighters produce a list of <code>CodeSpan</code> nodes which is one node type of Laika&#39;s document AST. 
        Even though this is usually the only node type you deal with, 
        it might help to get familiar with <a href="../04-customizing-laika/04-document-ast.html#the-document-ast">The Document AST</a> first.</p>
        
        <h2 id="the-syntaxhighlighter-trait" class="section">The SyntaxHighlighter Trait</h2>
        <p>These are the two abstract methods a new highlighter needs to implement:</p>
        <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">language</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">String</span><span>]

</span><span class="keyword">def</span><span> </span><span class="declaration-name">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>]</span></code></pre>
        <ul>
          <li>
            <p>The <code>language</code> property holds one or more names for the language that will be used to identify the language
            when syntax like fenced code blocks are used.</p>
            <p>Concretely this means that if you specify <code>python</code> and <code>py</code> as the names for example, 
            the implementation will be used for any fenced code block that starts with either <code>```py</code> or <code>```python</code>.</p>
            <p>It&#39;s not tied to Markdown syntax though. 
            reStructuredText has its own way of specifying a code block with language identifier, 
            and the highlighter will be used for those, too.</p>
          </li>
          <li>
            <p>The <code>spanParsers</code> property holds the actual parsers.
            Like with markup parsers they can be defined independently and then simply get listed in this trait.</p>
          </li>
        </ul>
        <p>Let&#39;s start by looking at how you can assemble these span parsers by using some of the building blocks for 
        common language constructs.</p>
        <p>We later look at how to add other constructs based on custom parsers.</p>
        
        <h2 id="using-existing-building-blocks" class="section">Using Existing Building Blocks</h2>
        <p>The building blocks shown in this section are meant to be used as shortcuts.
        Whenever they do not provide the exact syntax option that you need, 
        you can always fall back to <a href="#defining-custom-parsers">Defining Custom Parsers</a>.</p>
        <p>Our code examples in this section define highlighters for a Scala-ish language, 
        but omit many details for the sake of brevity.
        You can examine the source code of Laika&#39;s built-in highlighters for more complete examples.</p>
        
        <h3 id="string-literals" class="section">String Literals</h3>
        <p>There are shortcuts for defining single- and multi-line strings together with escape sequences:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">StringLiteral</span><span>.</span><span class="identifier">multiLine</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;\&quot;\&quot;</span><span class="string-literal">&quot;</span><span>),
  </span><span class="type-name">StringLiteral</span><span>.</span><span class="identifier">singleLine</span><span>(</span><span class="char-literal">&#39;&quot;&#39;</span><span>).</span><span class="identifier">embed</span><span>(
    </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">unicode</span><span> ++ </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">char</span><span>
  )
)</span></code></pre>
        <p>The <code>multiline</code> and <code>singleLine</code> builders both require to specify the delimiter.
        When the start and end delimiter are identical you can use the single-argument overload.</p>
        <p>For a single line string we also define valid escape sequences which will be used
        to detect nested spans. 
        These are existing building blocks, too.</p>
        <p>There are additional escape options like octal and hex, as well as building blocks to define substitutions,
        e.g. Scala&#39;s <code>s&quot;some $ref&quot;</code> syntax.</p>
        
        <h3 id="character-literals" class="section">Character Literals</h3>
        <p>Character literals have fewer options than string literals, but are otherwise quite similar:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">CharLiteral</span><span>.</span><span class="identifier">standard</span><span>.</span><span class="identifier">embed</span><span>(
    </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">unicode</span><span> ++ </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">char</span><span>
  )
)</span></code></pre>
        <p>The <code>standard</code> builder uses single quotes as delimiters, but you can specify a different one if required.
        Like with our string literal example, we define two kinds of escapes that can occur in a character literal.</p>
        
        <h3 id="numeric-literals" class="section">Numeric Literals</h3>
        <p>There are shortcuts for the most common types of decimal, hex, octal and binary number literals:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">NumberLiteral</span><span>.</span><span class="identifier">hex</span><span>
    .</span><span class="identifier">withUnderscores</span><span>
    .</span><span class="identifier">withSuffix</span><span>(</span><span class="type-name">NumericSuffix</span><span>.</span><span class="identifier">long</span><span>),
  </span><span class="type-name">NumberLiteral</span><span>.</span><span class="identifier">decimalInt</span><span>
    .</span><span class="identifier">withUnderscores</span><span>
    .</span><span class="identifier">withSuffix</span><span>(</span><span class="type-name">NumericSuffix</span><span>.</span><span class="identifier">long</span><span> | </span><span class="type-name">NumericSuffix</span><span>.</span><span class="identifier">float</span><span>)
)</span></code></pre>
        <p>Here we are defining two types of number literals: hexadecimal and decimal integers.</p>
        <p>In both cases we allow the use of underscores as separators (e.g. <code>1,000,000</code>).</p>
        <p>We also define which kinds of type indicators we allow as a suffix and again use 
        existing parsers for widely used syntax (<code>NumericSuffix.long</code> parses <code>L</code> or <code>l</code> for example).</p>
        
        <h3 id="identifiers" class="section">Identifiers</h3>
        <p>This is how the identifier category is defined for the Scala highlighter:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">identifier</span><span> = </span><span class="type-name">Identifier</span><span>.</span><span class="identifier">alphaNum</span><span>
  .</span><span class="identifier">withIdStartChars</span><span>(</span><span class="char-literal">&#39;_&#39;</span><span>,</span><span class="char-literal">&#39;$&#39;</span><span>)
  .</span><span class="identifier">withCategoryChooser</span><span>(</span><span class="type-name">Identifier</span><span>.</span><span class="identifier">upperCaseTypeName</span><span>)</span></code></pre>
        <p>It expects any alphanumerical identifier that is also allowed to have <code>_</code> or <code>$</code> as a start character.</p>
        <p>We then pass a function as a &quot;category chooser&quot; that assigns a category based on the parsed identifier.
        It is a very simple function that serves as a relatively useful approximation:
        it picks <code>CodeCategory.TypeName</code> when the identifier starts with an uppercase letter,
        otherwise it assigns <code>CodeCategory.Identifier</code>.</p>
        <p>This is obviously not always correct, but good enough for most use cases.
        As discussed in the design goals, this highlighting utility does not aim to get close to defining
        full lexers and parsers, and assigning the category correctly in all cases would require full context
        of the parsed construct. 
        Many highlighters you might be using with other tools are equally pragmatic.</p>
        
        <h3 id="keywords" class="section">Keywords</h3>
        <p>Keywords can simply be listed as string literals:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">Keywords</span><span>(</span><span class="string-literal">&quot;abstract&quot;</span><span>, </span><span class="string-literal">&quot;case&quot;</span><span>, </span><span class="string-literal">&quot;catch&quot;</span><span>, </span><span class="string-literal">&quot;class&quot;</span><span>, </span><span class="string-literal">&quot;def&quot;</span><span>)
)</span></code></pre>
        <p>It detects word boundaries so that it will not match on sub-strings.</p>
        <p>By default the parser will assign <code>CodeCategory.Keyword</code> to any matching string.
        If you want to use literal matches, but with a different code category, there is an alternative constructor:</p>
        <pre><code class="nohighlight"><span class="type-name">Keywords</span><span>(</span><span class="type-name">CodeCategory</span><span>.</span><span class="type-name">BooleanLiteral</span><span>)(</span><span class="string-literal">&quot;true&quot;</span><span>, </span><span class="string-literal">&quot;false&quot;</span><span>)</span></code></pre>
        
        <h3 id="comments" class="section">Comments</h3>
        <p>Shortcuts exist for defining single- and multi-line comments:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">Comment</span><span>.</span><span class="identifier">singleLine</span><span>(</span><span class="string-literal">&quot;//&quot;</span><span>),
  </span><span class="type-name">Comment</span><span>.</span><span class="identifier">multiLine</span><span>(</span><span class="string-literal">&quot;/*&quot;</span><span>, </span><span class="string-literal">&quot;*/&quot;</span><span>)
)</span></code></pre>
        <p>The code should be self-explanatory here, we simply define the delimiters for the comment syntax of our language.
        The single-line variant terminates at the end of the line.</p>
        
        <h2 id="defining-custom-parsers" class="section">Defining Custom Parsers</h2>
        <p>The basic building blocks presented in the previous section help a lot with reducing boilerplate, 
        but in most cases you end up with the need to have at least a handful of hand-written parsers, too.</p>
        <p>For a little example, let&#39;s implement a highlighter for Scala&#39;s backtick identifiers (e.g. <code>`tag-name`</code>)
        which is quite straightforward, but not included in the reusable builders since it&#39;s not a very common construct:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">builders</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">backtickId</span><span>: </span><span class="type-name">CodeSpanParser</span><span> = </span><span class="type-name">CodeSpanParser</span><span>(</span><span class="type-name">CodeCategory</span><span>.</span><span class="type-name">Identifier</span><span>) {
    (</span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;`&#39;</span><span>) ~ </span><span class="identifier">anyNot</span><span>(</span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;`&#39;</span><span>) ~ </span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;`&#39;</span><span>)).</span><span class="identifier">source</span><span>
  }</span></code></pre>
        <p>In the first line of the definition we specify the category that should be assigned to the result of the parser.</p>
        <p>The next line is a standard parser definition using some of the building blocks of <a href="../06-sub-modules/02-laikas-parser-combinators.html#laika-s-parser-combinators">Laika&#39;s Parser Combinators</a>.
        We simply expect a backtick as the start and end delimiter and allow anything in-between apart from newline or
        backtick characters.</p>
        <p>The call to <code>.source</code> is a convenient shortcut that discards the result of the three parsers and instead
        provides the source of the entire input by those three parsers as the result. 
        This is often preferable when all we would do with the three results would be concatenate them back to one string.</p>
        <p>The code parser we now defined can then be registered in our <code>spanParsers</code> sequence like in all other examples.</p>
        <p>The entry point above is just one option.
        It&#39;s only appropriate if we provide a string parser and want the same category assigned to the entire string.</p>
        <p>There is an alternative factory method, where we specify a <code>PrefixedParser[Seq[CodeSpan]]</code> 
        where we have full control over how we slice the input into multiple categories.</p>
        
        <h2 id="embedding-other-languages" class="section">Embedding other Languages</h2>
        <p>In some cases a language or format may have regions that require a highlighter for a different syntax.
        A classic example is HTML which may have CSS syntax inside a <code>&lt;style&gt;</code> tag and JavaScript syntax inside
        a <code>&lt;script&gt;</code> tag.</p>
        <p>Laika comes with a parser builder that helps with the creation of such a parser.</p>
        <p>Let&#39;s pick CSS in HTML as an example and show a simplified definition for a such a style tag:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">styleTagParser</span><span>: </span><span class="type-name">PrefixedParser</span><span>[</span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpan</span><span>]] = {
  </span><span class="keyword">val</span><span> </span><span class="identifier">cat</span><span> = </span><span class="type-name">CodeCategory</span><span>.</span><span class="type-name">Tag</span><span>.</span><span class="type-name">Name</span><span>
  </span><span class="keyword">val</span><span> </span><span class="identifier">bodyAndEndTag</span><span> = </span><span class="type-name">EmbeddedCodeSpans</span><span>.</span><span class="identifier">parser</span><span>(</span><span class="identifier">delimitedBy</span><span>(</span><span class="string-literal">&quot;&lt;/style&gt;&quot;</span><span>), </span><span class="type-name">CSSSyntax</span><span>)
  (</span><span class="identifier">literal</span><span>(</span><span class="string-literal">&quot;&lt;style&gt;&quot;</span><span>) ~&gt; </span><span class="identifier">bodyAndEndTag</span><span>).</span><span class="identifier">map</span><span> { </span><span class="identifier">css</span><span> =&gt;
    </span><span class="type-name">CodeSpan</span><span>(</span><span class="string-literal">&quot;&lt;style&gt;&quot;</span><span>, </span><span class="identifier">cat</span><span>) +: </span><span class="identifier">css</span><span> :+ </span><span class="type-name">CodeSpan</span><span>(</span><span class="string-literal">&quot;&lt;/style&gt;&quot;</span><span>, </span><span class="identifier">cat</span><span>)
  }</span></code></pre>
        <p>The key here is the third line.
        We define a region to parse with <code>delimitedBy(&quot;&lt;/style&gt;&quot;)</code> which consumes text until it sees the specified
        end delimiter. See <a href="../06-sub-modules/02-laikas-parser-combinators.html#delimiters">Delimiters</a> for details.
        And we specify the syntax to switch to until we reach that delimiter, in this case the existing <code>CSSSyntax</code></p>
        <p>The result (the <code>css</code> param) is of type <code>Seq[CodeSpan]</code>, containing the spans detected by the CSS highlighter.
        We then wrap the code spans for the start tag and end tag around it for the final result.</p>
        <p>One of the simplifications to keep the example simple is that we assign the category <code>CodeCategory.Tag.Name</code>
        to the entire tag, including the angle brackets.
        Normally you would keep them separate under <code>CodeCategory.Tag.Punctuation</code>.</p>
        
        <h2 id="parser-precedence" class="section">Parser Precedence</h2>
        <p>The precedence rules are identical to those for declaring markup parsers.</p>
        <p>The parser precedence is determined by the order you specify them in.
        This means they will be &quot;tried&quot; on input in that exact order.
        The second parser in the list will only be invoked on a particular input when the first fails, and so on.</p>
        <p>This is the logical execution model only, the exact runtime behaviour may differ due to performance optimizations,
        but without breaking the guarantees of respecting the order you specify.</p>
        <p>In many cases the difference in the syntax between constructs is high enough that the precedence does not matter.
        But in some cases extra care is needed.</p>
        <p>If, for example, you provide a parser for a span delimited by one or two occurrences of the same character,
        the two-character version must be specified first, as otherwise the parser with the single-character delimiter 
        would 100% shadow the double one and consume all matching input itself, unless it contains a guard against it.</p>
        <p>Similarly, parsers like those for identifiers which do not have a limited set of start delimiters 
        usually need to occur near the bottom of the list of parsers you register.</p>
        
        <h2 id="registering-a-highlighter" class="section">Registering a Highlighter</h2>
        <p>First you have to assemble all the parsers in a <code>SyntaxHighlighter</code> implementation:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">FooHighlighter</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">SyntaxHighlighter</span><span> {

  </span><span class="keyword">val</span><span> </span><span class="identifier">language</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="type-name">NonEmptyList</span><span>.</span><span class="identifier">one</span><span>(</span><span class="string-literal">&quot;foo&quot;</span><span>)
  
  </span><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
    </span><span class="comment">// all your definitions here
</span><span>  )

}</span></code></pre>
        <p>Finally, like all other types of extensions, the highlighter needs to be registered with an <code>ExtensionBundle</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">MyExtensions</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ExtensionBundle</span><span> {
  
  </span><span class="keyword">override</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">parsers</span><span>: </span><span class="type-name">ParserBundle</span><span> = </span><span class="type-name">ParserBundle</span><span>(
    </span><span class="identifier">syntaxHighlighters</span><span> = </span><span class="type-name">Seq</span><span>(
      </span><span class="type-name">FooHighlighter</span><span>
    )
  )
}</span></code></pre>
        <p>You can bundle multiple highlighters in a single instance.</p>
        <p>Finally you can register your extension together with any built-in extensions you may use:</p>
        <p><strong>sbt plugin</strong></p>
        <pre><code class="nohighlight"><span class="identifier">laikaExtensions</span><span> := </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">GitHubFlavor</span><span>,
  </span><span class="type-name">MyExtensions</span><span>
)</span></code></pre>
        <p><strong>Library API</strong></p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyExtensions</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        
      </main>
      
    </div>

  </body>
</html>
