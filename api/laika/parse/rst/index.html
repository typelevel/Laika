<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons">î…Œ</i>
            <i id="search-icon" class="material-icons">î¢¶</i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="index.html#laika" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../laika/index.html#parse" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.core" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="core"></a><a id="core:core"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html#core" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../core/index.html"><span class="name">core</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.css" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="css"></a><a id="css:css"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html#css" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../css/index.html"><span class="name">css</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.markdown" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markdown"></a><a id="markdown:markdown"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html#markdown" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../markdown/index.html"><span class="name">markdown</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.rst" visbl="pub" class="indented3 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rst"></a><a id="rst:rst"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html#rst" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">rst</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.rst.ext" visbl="pub" class="indented4 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ext"></a><a id="ext:ext"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#ext" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="ext/index.html"><span class="name">ext</span></a>
      </span>
      
      
    </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="BaseParsers$.html" title=""></a>
                        <a href="BaseParsers$.html" title="">BaseParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="BlockParsers.html" title="Provides the parsers for all types of block-level elements of reStructuredText."></a>
                        <a href="BlockParsers.html" title="Provides the parsers for all types of block-level elements of reStructuredText.">BlockParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Directives$.html" title="API for creating directives, the extension mechanism of reStructuredText."></a>
                        <a href="Directives$.html" title="API for creating directives, the extension mechanism of reStructuredText.">Directives</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="Elements$.html" title="Provides the elements of the document tree that are too specific to reStructuredText to be added to the generic tree model."></a>
                        <a href="Elements$.html" title="Provides the elements of the document tree that are too specific to reStructuredText to be added to the generic tree model.">Elements</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="ExplicitBlockParsers.html" title="Provides the parsers for all types of explicit block elements."></a>
                        <a href="ExplicitBlockParsers.html" title="Provides the parsers for all types of explicit block elements.">ExplicitBlockParsers</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="ExtendedHTML$.html" title=""></a>
                        <a class="class" href="ExtendedHTML.html" title="HTML renderer for special reStructuredText tree elements not part of the default document tree model."></a>
                        <a href="ExtendedHTML.html" title="HTML renderer for special reStructuredText tree elements not part of the default document tree model.">ExtendedHTML</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="InlineParsers.html" title="Provides all inline parsers for reStructuredText."></a>
                        <a href="InlineParsers.html" title="Provides all inline parsers for reStructuredText.">InlineParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="ListParsers.html" title="Provides the parsers for all reStructuredText list types."></a>
                        <a href="ListParsers.html" title="Provides the parsers for all reStructuredText list types.">ListParsers</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="ReStructuredText$.html" title="The default reStructuredText parser configuration, without any directives or text roles installed."></a>
                        <a class="class" href="ReStructuredText.html" title="A parser for text written in reStructuredText markup."></a>
                        <a href="ReStructuredText.html" title="A parser for text written in reStructuredText markup.">ReStructuredText</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="RewriteRules$.html" title="The default rewrite rules that get applied to the raw document tree after parsing reStructuredText markup."></a>
                        <a href="RewriteRules$.html" title="The default rewrite rules that get applied to the raw document tree after parsing reStructuredText markup.">RewriteRules</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="RootParser.html" title="The main parser for reStructuredText, combining the individual parsers for block and inline elements, and adding functionality like directives depending on configuration."></a>
                        <a href="RootParser.html" title="The main parser for reStructuredText, combining the individual parsers for block and inline elements, and adding functionality like directives depending on configuration.">RootParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="TableParsers.html" title="Provides parsers for the two table types supported by reStructuredText."></a>
                        <a href="TableParsers.html" title="Provides parsers for the two table types supported by reStructuredText.">TableParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="TextRoles$.html" title="API for creating interpreted text roles, the extension mechanism for inline elements of reStructuredText."></a>
                        <a href="TextRoles$.html" title="API for creating interpreted text roles, the extension mechanism for inline elements of reStructuredText.">TextRoles</a>
                      </li><li name="laika.parse.util" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="util"></a><a id="util:util"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html#util" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../util/index.html"><span class="name">util</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../../index.html" class="extype" name="laika">laika</a>.<a href="../index.html" class="extype" name="laika.parse">parse</a></p>
        <h1>rst<span class="permalink">
      <a href="../../../laika/parse/rst/index.html" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">rst</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow">î€·</i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons">î…Œ</i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              
            </ol>
          </div>
          
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="laika.parse.rst.BlockParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BlockParsersextendsAnyRef"></a><a id="BlockParsers:BlockParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#BlockParsersextendsAnyRef" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides the parsers for all types of block-level elements of reStructuredText." href="BlockParsers.html"><span class="name">BlockParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides the parsers for all types of block-level elements of reStructuredText.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the parsers for all types of block-level elements of reStructuredText.
 It merges the individual traits that provide implementations for list, tables, etc. and
 adds the remaining block level parsers that do not fit into any of the subcategories
 supported by the other traits.</p><p> Block parsers are only concerned with splitting the document into
 (potentially nested) blocks. They are used in the first phase of parsing,
 while delegating to inline parsers for the 2nd phase.
</p></div></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ExplicitBlockParsersextendsAnyRef"></a><a id="ExplicitBlockParsers:ExplicitBlockParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#ExplicitBlockParsersextendsAnyRef" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides the parsers for all types of explicit block elements." href="ExplicitBlockParsers.html"><span class="name">ExplicitBlockParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides the parsers for all types of explicit block elements.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the parsers for all types of explicit block elements.
 In reStructuredText an explicit block element starts with <code>.. </code>,
 followed by a block where the second and subsequent lines are indented.
</p></div></div>
    </li><li name="laika.parse.rst.ExtendedHTML" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ExtendedHTMLextendslaika.render.HTMLWriter=&gt;laika.tree.Elements.RenderFunction"></a><a id="ExtendedHTML:ExtendedHTML"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#ExtendedHTMLextendslaika.render.HTMLWriter=&gt;laika.tree.Elements.RenderFunction" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="HTML renderer for special reStructuredText tree elements not part of the default document tree model." href="ExtendedHTML.html"><span class="name">ExtendedHTML</span></a><span class="result"> extends (<a href="../../render/HTMLWriter.html" class="extype" name="laika.render.HTMLWriter">HTMLWriter</a>) â‡’ <a href="../../tree/Elements$.html#RenderFunction=PartialFunction[laika.tree.Elements.Element,Unit]" class="extmbr" name="laika.tree.Elements.RenderFunction">RenderFunction</a></span>
      </span>
      
      <p class="shortcomment cmt">HTML renderer for special reStructuredText tree elements not part of the default document tree model.</p><div class="fullcomment"><div class="comment cmt"><p>HTML renderer for special reStructuredText tree elements not part of the default document tree model.</p><p> The following tree elements are specific to reStructuredText and are not included in the default model:</p><ul><li><code>FieldList</code> and corresponding child elements</li><li><code>OptionList</code> and corresponding child elements</li><li><code>DoctestBlock</code></li></ul><p> FieldLists being part of a directive declaration will be processed by the default parser, the <code>FieldList</code>
 element only appears in the final document model if field lists are used outside of directives.</p><p> The renderer must be applied explicitly when any of these constructs are used in the markup:</p><pre><span class="kw">val</span> transform = Transform from ReStructuredText to HTML rendering ExtendedHTML</pre></div></div>
    </li><li name="laika.parse.rst.InlineParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="InlineParsersextendsAnyRef"></a><a id="InlineParsers:InlineParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#InlineParsersextendsAnyRef" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides all inline parsers for reStructuredText." href="InlineParsers.html"><span class="name">InlineParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides all inline parsers for reStructuredText.</p><div class="fullcomment"><div class="comment cmt"><p>Provides all inline parsers for reStructuredText.</p><p> Inline parsers deal with markup within a block of text, such as a
 link or emphasized text. They are used in the second phase of parsing,
 after the block parsers have cut the document into a (potentially nested)
 block structure.
</p></div></div>
    </li><li name="laika.parse.rst.ListParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ListParsersextendsAnyRef"></a><a id="ListParsers:ListParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#ListParsersextendsAnyRef" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides the parsers for all reStructuredText list types." href="ListParsers.html"><span class="name">ListParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides the parsers for all reStructuredText list types.</p>
    </li><li name="laika.parse.rst.ReStructuredText" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReStructuredTextextendsParserFactory"></a><a id="ReStructuredText:ReStructuredText"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#ReStructuredTextextendsParserFactory" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="A parser for text written in reStructuredText markup." href="ReStructuredText.html"><span class="name">ReStructuredText</span></a><span class="result"> extends <a href="../../factory/ParserFactory.html" class="extype" name="laika.factory.ParserFactory">ParserFactory</a></span>
      </span>
      
      <p class="shortcomment cmt">A parser for text written in reStructuredText markup.</p><div class="fullcomment"><div class="comment cmt"><p>A parser for text written in reStructuredText markup. Instances of this class may be passed directly
 to the <code>Parse</code> or <code>Transform</code> APIs:</p><pre><span class="kw">val</span> document = Parse as ReStructuredText fromFile <span class="lit">"hello.rst"</span>

Transform from ReStructuredText to HTML fromFile <span class="lit">"hello.rst"</span> toFile <span class="lit">"hello.html"</span></pre><p> reStructuredText has several types of extension points that are fully supported by Laika.
 In contrast to the original Python implementation, the API has been redesigned to be a more
 idiomatic, concise and type-safe Scala DSL.</p><p> The following extension types are available:</p><ul><li>Block Directives - an extension hook for adding new block level elements to
   reStructuredText markup. Use the <code>withBlockDirectives</code> method of this class to
   add directive implementations to the parser. Specification entry:
   <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives</a></li><li>Substitution Definitions - an extension hook for adding new span level elements to
   reStructuredText markup that can be used by substitution references (like <code>|subst|</code>).
   Use the <code>withSpanDirectives</code> method of this class to
   add directive implementations to the parser that can be used as substitution definitions.
   Specification entry:
   <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-definitions" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-definitions</a></li><li>Interpreted Text Roles - an extension hook for adding new dynamic span level elements to
   reStructuredText markup. In contrast to substitution definitions the implementation of a text
   role uses the text from the occurrences in the markup referring to the role as input.
   Use the <code>withTextRoles</code> method of this class to
   add custom text role implementations to the parser that can be referred to by interpreted text.
   Specification entry:
   <a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles</a></li></ul><p> In addition to the standard reStructuredText directives, the API also supports a custom directive
 type unique to Laika. They represent a library-wide extension mechanism and allow you to implement
 tags which can be used in any of the supported markup formats or in templates. If you need this
 level of flexibility, it is recommended to use the Laika directives, if you want to stay compatible
 with the reStructuredText reference parser, you should pick the standard directives.</p><p> Laika directives can be registered with the <code>withLaikaSpanDirective</code> and <code>withLaikaBlockDirective</code>
 calls respectively. reStructuredText directives can be registered with <code>withSpanDirective</code> and
 <code>withBlockDirective</code> respectively. The DSLs for creating directives are similar, but still different,
 due to differences in the feature set of the two variants. The Laika directives try to avoid some
 of the unnecessary complexities of reStructuredText directives.
</p></div></div>
    </li><li name="laika.parse.rst.RootParser" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RootParserextendsRootParserBase"></a><a id="RootParser:RootParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#RootParserextendsRootParserBase" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="The main parser for reStructuredText, combining the individual parsers for block and inline elements, and adding functionality like directives depending on configuration." href="RootParser.html"><span class="name">RootParser</span></a><span class="result"> extends <a href="../core/markup/RootParserBase.html" class="extype" name="laika.parse.core.markup.RootParserBase">RootParserBase</a></span>
      </span>
      
      <p class="shortcomment cmt">The main parser for reStructuredText, combining the individual parsers for block and inline elements,
and adding functionality like directives depending on configuration.</p>
    </li><li name="laika.parse.rst.TableParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TableParsersextendsAnyRef"></a><a id="TableParsers:TableParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#TableParsersextendsAnyRef" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides parsers for the two table types supported by reStructuredText." href="TableParsers.html"><span class="name">TableParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides parsers for the two table types supported by reStructuredText.</p>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="laika.parse.rst.BaseParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="BaseParsers"></a><a id="BaseParsers:BaseParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#BaseParsers" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="BaseParsers$.html"><span class="name">BaseParsers</span></a>
      </span>
      
      <p class="shortcomment cmt"></p>
    </li><li name="laika.parse.rst.Directives" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Directives"></a><a id="Directives:Directives"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#Directives" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="API for creating directives, the extension mechanism of reStructuredText." href="Directives$.html"><span class="name">Directives</span></a>
      </span>
      
      <p class="shortcomment cmt">API for creating directives, the extension mechanism of reStructuredText.</p><div class="fullcomment"><div class="comment cmt"><p>API for creating directives, the extension mechanism of reStructuredText.
 The API did not aim to mimic the API of the original Python reference implementation.
 Instead the goal was to create an API that is idiomatic Scala, fully typesafe and as concise as possible.
 Yet it should be flexible enough to semantically support the options of the Python directives, so that
 ideally most existing Python directives could theoretically get ported to Laika.</p><p> Entry points are the <code>BlockDirective</code> and <code>SpanDirective</code> objects. The Python reference parser does
 not make this distinction on the API level, but does this internally based on the context a
 directive is parsed in. Since Laika APIs are typesafe, the distinction is necessary since
 block level and span level directives create different types of document tree nodes.
 A <code>SpanDirective</code> can only be used in a substitution definition which can then be used
 within flow elements. A <code>BlockDirective</code> can be used directly in any location other block
 level content like paragraphs or lists can be used.</p><p> A directive may consist of any combination of arguments, fields and body elements:</p><pre>.. myDirective:: arg1 arg2
 :field1: value1
 :field2: value2

 This is the body of the directive. It may consist of any standard or custom
 block-level and inline markup.</pre><p> In the example above <code>arg1</code> and <code>arg2</code> are arguments, <code>field1</code> and <code>field2</code> are fields,
 and followed by body elements after a blank line. If there are no arguments or fields
 the blank line may be omitted. For the full specification, see
 <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives</a>.</p><p> For each of these directive elements, the API offers a method to specify whether the
 element is required or optional, and an optional function to convert or validate the
 parsed value.</p><p> Consider the following simple example of a directive with just one argument and
 a body:</p><pre>.. note:: This is the title

 This is the body of the note.</pre><p> The implementation of this directive could look like this:</p><pre><span class="kw">case</span> <span class="kw">class</span> Note (title: <span class="std">String</span>,
                 content: <span class="std">Seq</span>[Block],
                 options: Options = NoOpt) <span class="kw">extends</span> Block
                                           <span class="kw">with</span> BlockContainer[Note]

<span class="kw">val</span> rst = ReStructuredText withBlockDirectives
  BlockDirective(<span class="lit">"note"</span>) {
    (argument(withWS = <span class="kw">true</span>) ~ blockContent)(Note(_,_))
  }

Transform from rst to HTML fromFile <span class="lit">"hello.rst"</span> toFile <span class="lit">"hello.html"</span></pre><p> The <code>argument()</code> method specifies a required argument of type <code>String</code> (since no conversion
 function was supplied). We need to set the <code>withWS</code> flag to true as an argument cannot have
 whitespace per default. The <code>blockContent</code> method specifies standard block content (any block-level
 elements that are supported in normal blocks, too) which results in a parsed value of type
 <code>Seq[Block]</code>. Finally you need to provide a function that accepts the results of the specified
 directive elements as parameters (of the corresponding type). Here we created a case class
 with a matching signature so can pass it directly as the target function. For a block directive
 the final result has to be of type <code>Block</code> which the <code>Note</code> class satisfies. Finally the directive
 gets registered with the <code>ReStructuredText</code> parser.</p><p> If any conversion or validation is required on the individual parts of the directive they can
 be passed to the corresponding function:</p><pre><span class="kw">def</span> nonNegativeInt (value: <span class="std">String</span>) =
  <span class="kw">try</span> {
    <span class="kw">val</span> num = value.toInt
    Either.cond(num &gt;= <span class="num">0</span>, num, s<span class="lit">"not a positive int: $num"</span>)
  }
  <span class="kw">catch</span> {
    <span class="kw">case</span> e: NumberFormatException <span class="kw">=&gt;</span> Left(s<span class="lit">"not a number: $value"</span>)
  }

<span class="kw">case</span> <span class="kw">class</span> Message (severity: <span class="std">Int</span>,
                    content: <span class="std">Seq</span>[Block],
                    options: Options = NoOpt) <span class="kw">extends</span> Block
                                              <span class="kw">with</span> BlockContainer[Message]

<span class="kw">val</span> rst = ReStructuredText withBlockDirectives (
  BlockDirective(<span class="lit">"message"</span>) {
    (argument(nonNegativeInt) ~ blockContent)(Message(_,_))
  }
)</pre><p> The function has to provide an <code>Either[String, T]</code> as a result. A <code>Left</code> result will be interpreted
 as an error by the parser with the string being used as the message and an instance of <code>InvalidBlock</code>
 containing the validator message and the raw source of the directive will be inserted into the document
 tree. In this case the final function (<code>Message</code>) will never be invoked. A <code>Right</code> result will be
 used as an argument to the final function. Note how the case class now expects an <code>Int</code> as the first
 parameter.</p><p> Finally arguments and fields can also be optional. In case they are missing, the directive is still
 considered valid and <code>None</code> will be passed to your function:</p><pre><span class="kw">case</span> <span class="kw">class</span> Message (severity: <span class="std">Option</span>[<span class="std">Int</span>],
                    content: <span class="std">Seq</span>[Block],
                    options: Options = NoOpt) <span class="kw">extends</span> Block
                                              <span class="kw">with</span> BlockContainer[Message]

<span class="kw">val</span> rst = ReStructuredText withBlockDirectives (
  BlockDirective(<span class="lit">"message"</span>) {
    (optArgument(nonNegativeInt) ~ blockContent)(Message(_,_))
  }
)</pre><p> The argument may be missing, but if it is present it has to pass the specified validator.</p><p> In case of multiple arguments, the order you specify them is also the order in which they
 are parsed from the directive markup, with the only exception being that required arguments
 will always be parsed before optional ones, and arguments with whitespace need to come last.
</p></div></div>
    </li><li name="laika.parse.rst.Elements" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Elements"></a><a id="Elements:Elements"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#Elements" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Provides the elements of the document tree that are too specific to reStructuredText to be added to the generic tree model." href="Elements$.html"><span class="name">Elements</span></a>
      </span>
      
      <p class="shortcomment cmt">Provides the elements of the document tree that are too specific to reStructuredText
 to be added to the generic tree model.</p>
    </li><li name="laika.parse.rst.ExtendedHTML" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ExtendedHTML"></a><a id="ExtendedHTML:ExtendedHTML"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#ExtendedHTML" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="ExtendedHTML$.html"><span class="name">ExtendedHTML</span></a><span class="result"> extends <a href="ExtendedHTML.html" class="extype" name="laika.parse.rst.ExtendedHTML">ExtendedHTML</a></span>
      </span>
      
      
    </li><li name="laika.parse.rst.ReStructuredText" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ReStructuredText"></a><a id="ReStructuredText:ReStructuredText"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#ReStructuredText" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="The default reStructuredText parser configuration, without any directives or text roles installed." href="ReStructuredText$.html"><span class="name">ReStructuredText</span></a><span class="result"> extends <a href="ReStructuredText.html" class="extype" name="laika.parse.rst.ReStructuredText">ReStructuredText</a></span>
      </span>
      
      <p class="shortcomment cmt">The default reStructuredText parser configuration, without any directives or text roles installed.</p>
    </li><li name="laika.parse.rst.RewriteRules" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RewriteRules"></a><a id="RewriteRules:RewriteRules"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#RewriteRules" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="The default rewrite rules that get applied to the raw document tree after parsing reStructuredText markup." href="RewriteRules$.html"><span class="name">RewriteRules</span></a><span class="result"> extends (<a href="../../rewrite/DocumentCursor.html" class="extype" name="laika.rewrite.DocumentCursor">DocumentCursor</a>) â‡’ <a href="../../tree/Elements$.html#RewriteRule=PartialFunction[laika.tree.Elements.Element,Option[laika.tree.Elements.Element]]" class="extmbr" name="laika.tree.Elements.RewriteRule">RewriteRule</a></span>
      </span>
      
      <p class="shortcomment cmt"> The default rewrite rules that get applied to the raw document tree after parsing
 reStructuredText markup.</p><div class="fullcomment"><div class="comment cmt"><p> The default rewrite rules that get applied to the raw document tree after parsing
 reStructuredText markup. These rules are responsible for resolving  substitution
 references and interpreted text which are specific to reStructuredText and get usually
 executed alongside the generic rules. .
</p></div></div>
    </li><li name="laika.parse.rst.TextRoles" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TextRoles"></a><a id="TextRoles:TextRoles"></a>
      <span class="permalink">
      <a href="../../../laika/parse/rst/index.html#TextRoles" title="Permalink">
        <i class="material-icons">î…—</i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="API for creating interpreted text roles, the extension mechanism for inline elements of reStructuredText." href="TextRoles$.html"><span class="name">TextRoles</span></a>
      </span>
      
      <p class="shortcomment cmt">API for creating interpreted text roles, the extension mechanism for inline elements of reStructuredText.</p><div class="fullcomment"><div class="comment cmt"><p>API for creating interpreted text roles, the extension mechanism for inline elements of reStructuredText.
 The API did not aim to mimic the API of the original Python reference implementation.
 Instead the goal was to create an API that is idiomatic Scala, fully typesafe and as concise as possible.
 Yet it should be flexible enough to semantically support the options of the Python text roles, so that
 ideally most existing Python text roles could theoretically get ported to Laika.</p><p> Entry point for creating a new role is the <code>TextRole</code> object. It allows to specify the following
 aspects that define a text role:</p><ul><li>The name with which it can be referred to by both, a span of interpreted text and a role
   directive to further customize it.</li><li>The default value, that should get passed to the role function in case it is used
   directly in interpreted text without customization through a role directive.</li><li>The role directive that specifies how the role can be customized. The options
   for role directives are almost identical to regular directives, the only difference
   being that role directives do not support arguments, only fields and body elements.</li><li>The actual role function. It gets invoked for each occurrence of interpreted text
   that refers to this role, either directly by name or to the name of a role directive
   that customized this role. The first argument is either the default value
   or the result of the role directive, the second is the actual text of the interpreted
   text span. The return value of the role function is the actual <code>Span</code> instance
   that the original interpreted text should be replaced with.</li></ul><p> A role directive may consist of any combination of fields and body elements:</p><pre>.. role:: ticket(link)
 :base-url: http:<span class="cmt">//www.company.com/tickets/</span></pre><p> In the example above <code>ticket</code> is the name of the customized role, <code>link</code> the name
 of the base role and <code>base-url</code> the value that overrides the default defined in the
 base role. For the specification details on role directives see
 <a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles</a>.</p><p> Before such a role directive can be used, an implementation has to be provided
 for the base role with the name <code>link</code>. For more details on implementing directives
 see <a href="Directives$.html" class="extype" name="laika.parse.rst.Directives">laika.parse.rst.Directives</a>.</p><p> The implementation of the <code>link</code> text role could look like this:</p><pre><span class="kw">val</span> rst = ReStructuredText withTextRoles (
  TextRole(<span class="lit">"link"</span>, <span class="lit">"http://www.company.com/main/"</span>)(field(<span class="lit">"base-url"</span>)) {
    (base, text) <span class="kw">=&gt;</span> Link(<span class="std">List</span>(Text(text)), base + text)
  }
)

Transform from rst to HTML fromFile <span class="lit">"hello.rst"</span> toFile <span class="lit">"hello.html"</span></pre><p> We specify the name of the role to be <code>link</code>, and the default value the URL provided as the
 second argument. The second parameter list specifies the role directive implementation,
 in this case only consisting of a call to <code>field(&quot;base-url&quot;)</code> which specifies a required
 field of type <code>String</code> (since no conversion function was supplied). The type of the result
 of the directive has to match the type of the default value.
 Finally the role function is defined that accepts two arguments. The first is the base
 url, either the default in case the base role is used directly, or the value specified
 with the <code>base-url</code> field in a customized role. The second is the actual text from the
 interpreted text span. Finally the directive gets registered with the <code>ReStructuredText</code>
 parser.</p><p> If you need to define more fields or body content they can be added with the <code>~</code> combinator
 just like with normal directives. Likewise you can specify validators and converters for
 fields and body values like documented in <a href="Directives$.html" class="extype" name="laika.parse.rst.Directives">laika.parse.rst.Directives</a>.</p><p> Our example role can then be used in the following ways:</p><p> Using the base role directly:</p><pre>For details read our :link:`documentation`.</pre><p> This would result in the following HTML:</p><pre>For details read our &lt;a href=<span class="lit">"http://www.company.com/main/documentation"</span>&gt;documentation&lt;/a&gt;.</pre><p> Using the customized role called <code>ticket</code>:</p><pre>For details see ticket :ticket:`<span class="num">344</span>`.</pre><p> This would result in the following HTML:</p><pre>For details see ticket &lt;a href=<span class="lit">"http://www.company.com/ticket/344"</span>&gt;344&lt;/a&gt;.</pre></div></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
