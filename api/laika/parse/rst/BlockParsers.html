<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>laika.parse.rst.BlockParsers</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../lib/template.css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="type">
      <div id="definition">
        <img src="../../../lib/trait_big.png" />
        <p id="owner"><a name="laika" class="extype" href="../../package.html">laika</a>.<a name="laika.parse" class="extype" href="../package.html">parse</a>.<a name="laika.parse.rst" class="extype" href="package.html">rst</a></p>
        <h1>BlockParsers</h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">BlockParsers</span><span class="result"> extends <a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a> with <a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a> with <a name="laika.parse.rst.TableParsers" class="extype" href="TableParsers.html">TableParsers</a> with <a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>Provides the parsers for all types of block-level elements of reStructuredText.
 It merges the individual traits that provide implementations for list, tables, etc. and
 adds the remaining block level parsers that do not fit into any of the subcategories
 supported by the other traits.</p><p> Block parsers are only concerned with splitting the document into
 (potentially nested) blocks. They are used in the first phase of parsing,
 while delegating to inline parsers for the 2nd phase.
</p></div><dl class="attributes block"> <dt>Self Type</dt><dd><a name="laika.parse.rst.BlockParsers" class="extype" href="">BlockParsers</a> with <a name="laika.parse.rst.InlineParsers" class="extype" href="InlineParsers.html">InlineParsers</a></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a>, <a name="laika.parse.rst.TableParsers" class="extype" href="TableParsers.html">TableParsers</a>, <a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a>, <a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a>, <a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a>, <a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a>, <span name="scala.util.parsing.combinator.RegexParsers" class="extype">RegexParsers</span>, <span name="scala.util.parsing.combinator.Parsers" class="extype">Parsers</span>, AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="laika.parse.rst.BlockParsers" class="in"><span>BlockParsers</span></li><li name="laika.parse.rst.ExplicitBlockParsers" class="in"><span>ExplicitBlockParsers</span></li><li name="laika.parse.rst.TableParsers" class="in"><span>TableParsers</span></li><li name="laika.parse.rst.ListParsers" class="in"><span>ListParsers</span></li><li name="laika.parse.rst.BlockBaseParsers" class="in"><span>BlockBaseParsers</span></li><li name="laika.parse.BlockParsers" class="in"><span>BlockParsers</span></li><li name="laika.parse.MarkupParsers" class="in"><span>MarkupParsers</span></li><li name="scala.util.parsing.combinator.RegexParsers" class="in"><span>RegexParsers</span></li><li name="scala.util.parsing.combinator.Parsers" class="in"><span>Parsers</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div class="types members" id="types">
              <h3>Type Members</h3>
              <ol><li visbl="pub" name="laika.parse.rst.TableParsers.CellBuilder" data-isabs="false">
      <a id="CellBuilder:CellBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TableParsers$CellBuilder.html"><span class="name">CellBuilder</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="laika.parse.rst.TableParsers.CellBuilderRef" data-isabs="false">
      <a id="CellBuilderRef:CellBuilderRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TableParsers$CellBuilderRef.html"><span class="name">CellBuilderRef</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="laika.parse.rst.TableParsers.ColumnBuilder" data-isabs="false">
      <a id="ColumnBuilder:ColumnBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TableParsers$ColumnBuilder.html"><span class="name">ColumnBuilder</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#Elem" data-isabs="false">
      <a id="Elem:Elem"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Elem</span><span class="result"> = <span name="scala.Char" class="extype">Char</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers.IndentedBlock" data-isabs="false">
      <a id="IndentedBlock:IndentedBlock"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="BlockBaseParsers$IndentedBlock.html"><span class="name">IndentedBlock</span></a><span class="params">(<span name="nestLevel">nestLevel: Int</span>, <span name="minIndent">minIndent: Int</span>, <span name="lines">lines: List[String]</span>)</span><span class="result"> extends Product with Serializable</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#Input" data-isabs="false">
      <a id="Input:Input"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Input</span><span class="result"> = <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.TableParsers.MalformedTableException" data-isabs="false">
      <a id="MalformedTableException:MalformedTableException"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TableParsers$MalformedTableException.html"><span class="name">MalformedTableException</span></a><span class="result"> extends RuntimeException</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="laika.parse.MarkupParsers.MarkupParserException" data-isabs="false">
      <a id="MarkupParserException:MarkupParserException"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../MarkupParsers$MarkupParserException.html"><span class="name">MarkupParserException</span></a><span class="result"> extends RuntimeException</span>
      </span>
      </h4>
      <p class="comment cmt">Exception thrown when parsing a text markup document or fragment fails.</p>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers.NestedCharSequenceReader" data-isabs="false">
      <a id="NestedCharSequenceReader:NestedCharSequenceReader"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="BlockBaseParsers$NestedCharSequenceReader.html"><span class="name">NestedCharSequenceReader</span></a><span class="result"> extends CharSequenceReader</span>
      </span>
      </h4>
      <p class="comment cmt">Reader implementation that keeps the current nest level in case
 of recursive parsing of block-level elements.</p>
    </li><li visbl="pub" name="laika.parse.MarkupParsers.ParserOps" data-isabs="false">
      <a id="ParserOps:ParserOps[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../MarkupParsers$ParserOps.html"><span class="name">ParserOps</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      <p class="comment cmt">Provides additional combinator methods to parsers via implicit conversion.</p>
    </li><li visbl="pub" name="laika.parse.rst.TableParsers.RowBuilder" data-isabs="false">
      <a id="RowBuilder:RowBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TableParsers$RowBuilder.html"><span class="name">RowBuilder</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="laika.parse.rst.TableParsers.TableBuilder" data-isabs="false">
      <a id="TableBuilder:TableBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="TableParsers$TableBuilder.html"><span class="name">TableBuilder</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="laika.parse.MarkupParsers.TextParser" data-isabs="false">
      <a id="TextParser:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../MarkupParsers$TextParser.html"><span class="name">TextParser</span></a><span class="result"> extends Parser[String]</span>
      </span>
      </h4>
      <p class="comment cmt">API for specifying further constraints on the parsers provided by this base trait.</p>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Abstract Value Members</h3>
              <ol><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#blockDirectives" data-isabs="true">
      <a id="blockDirectives:Map[String, DirectivePart[Block]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockDirectives</span><span class="result">: Map[String, <a name="laika.parse.rst.Directives.DirectivePart" class="extype" href="Directives$$DirectivePart.html">DirectivePart</a>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Mapping from the name of all configured block directives to their implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Mapping from the name of all configured block directives to their implementation.</p><p> See laika.parse.rst.Directives for details on how to implement directives.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#spanDirectives" data-isabs="true">
      <a id="spanDirectives:Map[String, DirectivePart[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">spanDirectives</span><span class="result">: Map[String, <a name="laika.parse.rst.Directives.DirectivePart" class="extype" href="Directives$$DirectivePart.html">DirectivePart</a>[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Mapping from the name of all configured span directives to their implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Mapping from the name of all configured span directives to their implementation.</p><p> See laika.parse.rst.Directives for details on how to implement directives.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#textRoles" data-isabs="true">
      <a id="textRoles:Map[String, TextRole]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">textRoles</span><span class="result">: Map[String, <a name="laika.parse.rst.TextRoles.TextRole" class="extype" href="TextRoles$$TextRole.html">TextRole</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Mapping from the name of all configured text roles to their implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Mapping from the name of all configured text roles to their implementation.</p><p> See laika.parse.rst.TextRoles for details on how to implement text roles.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Concrete Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#OnceParser" data-isabs="false">
      <a id="OnceParser[T]((Input) ⇒ ParseResult[T]):Parser[T] with OnceParser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (Input) ⇒ <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T] with <span name="scala.util.parsing.combinator.Parsers.OnceParser" class="extype">OnceParser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#Parser" data-isabs="false">
      <a id="Parser[T]((Input) ⇒ ParseResult[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (Input) ⇒ <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#accept" data-isabs="false">
      <a id="accept[U](String,PartialFunction[Elem, U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: String</span>, <span name="f">f: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[Elem, U]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#accept" data-isabs="false">
      <a id="accept[ES](ES)((ES) ⇒ List[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: ES</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (ES) ⇒ List[Elem]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[Elem]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#accept" data-isabs="false">
      <a id="accept(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="params">(<span name="e">e: Elem</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#acceptIf" data-isabs="false">
      <a id="acceptIf((Elem) ⇒ Boolean)((Elem) ⇒ String):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptIf</span><span class="params">(<span name="p">p: (Elem) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="params">(<span name="err">err: (Elem) ⇒ String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#acceptMatch" data-isabs="false">
      <a id="acceptMatch[U](String,PartialFunction[Elem, U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptMatch</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: String</span>, <span name="f">f: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[Elem, U]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#acceptSeq" data-isabs="false">
      <a id="acceptSeq[ES](ES)((ES) ⇒ Iterable[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptSeq</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: ES</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (ES) ⇒ Iterable[Elem]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[Elem]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#any" data-isabs="false">
      <a id="any:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">any</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any kind of input, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any kind of input, always succeeds.
 This parser would consume the entire input unless a <code>max</code> constraint
 is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyBut" data-isabs="false">
      <a id="anyBut(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyBut</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyIn" data-isabs="false">
      <a id="anyIn(Traversable[Char]*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyIn</span><span class="params">(<span name="ranges">ranges: Traversable[<span name="scala.Char" class="extype">Char</span>]*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are in one of the specified character ranges.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are in one of the specified character ranges.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyOf" data-isabs="false">
      <a id="anyOf(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyUntil" data-isabs="false">
      <a id="anyUntil(⇒ Parser[Any]):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="until">until: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of characters for which the specified parser fails on the corresponding offset.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of characters for which the specified parser fails on the corresponding offset.
 This parser fails if the end of input is reached without the specified parser ever succeeding or
 if the parser causes an Error result instead of a plain Failure or Success.
 Further constraints like minimum or maximum number of required matching characters can be specified
 through the API of the returned <code>TextParser</code> instance.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyUntil" data-isabs="false">
      <a id="anyUntil(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.</p><p> This parser is identical to the <code>anyBut</code> parser except for two differences: this parser fails
 if it reaches the end of the input without seeing any of the specified
 characters and it also consumes this final character, without adding it
 to the result. This parser is usually used when a construct like a span
 enclosed between two characters needs to be parsed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyWhile" data-isabs="false">
      <a id="anyWhile((Char) ⇒ Boolean):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyWhile</span><span class="params">(<span name="p">p: (<span name="scala.Char" class="extype">Char</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters which satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters which satisfy the specified predicate.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#atStart" data-isabs="false">
      <a id="atStart:Parser[Parser[Unit]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">atStart</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Unit" class="extype">Unit</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the start of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the start of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#blankLine" data-isabs="false">
      <a id="blankLine:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLine</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a blank line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a blank line from the current input offset (which may not be at the
 start of the line). Fails for lines that contain any non-whitespace character.
 Does always produce an empty string as the result, discarding any whitespace
 characters found in the line.</p><p> Since it also succeeds at the end of the input
 it should never be used in the form of (blankLine *) or (blankLine +). Use
 the <code>blankLines</code> parser instead in these cases.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#blankLines" data-isabs="false">
      <a id="blankLines:Parser[List[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLines</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[String]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses one or more blanklines, producing a list of empty strings corresponding
 to the number of blank lines consumed.</p><div class="fullcomment"><div class="comment cmt"><p>Parses one or more blanklines, producing a list of empty strings corresponding
 to the number of blank lines consumed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#block" data-isabs="false">
      <a id="block(Parser[Any],⇒ Parser[Any],⇒ Parser[Any]):Parser[List[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">block</span><span class="params">(<span name="firstLinePrefix">firstLinePrefix: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>, <span name="linePrefix">linePrefix: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>, <span name="nextBlockPrefix">nextBlockPrefix: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[String]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full block based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full block based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">firstLinePrefix</dt><dd class="cmt"><p>parser that recognizes the start of the first line of this block</p></dd><dt class="param">linePrefix</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">nextBlockPrefix</dt><dd class="cmt"><p>parser that recognizes whether a line after one or more blank lines still belongs to the same block
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#blockDirective" data-isabs="false">
      <a id="blockDirective:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockDirective</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a block-level directive.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a block-level directive.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#blockList" data-isabs="false">
      <a id="blockList(⇒ Parser[Block]):Parser[List[Block]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockList</span><span class="params">(<span name="parser">parser: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Builds a parser for a list of blocks based on the parser for a single block.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a parser for a list of blocks based on the parser for a single block.</p><p> Overridden to add the processing required for cases where a block has influence
 on the parsing or processing of the subsequent block.</p><p> This includes checking each Paragraph for a double colon ending which turns
 the following block into a literal block as well as processing internal
 link targets and section headers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for a single block element</p></dd><dt>returns</dt><dd class="cmt"><p>a parser for a list of blocks
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockParsers" class="extype" href="">BlockParsers</a> → <a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#blockQuote" data-isabs="false">
      <a id="blockQuote:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockQuote</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a block quote with an optional attribution.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a block quote with an optional attribution.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#block-quotes">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#block-quotes</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.ListParsers#bulletList" data-isabs="false">
      <a id="bulletList:Parser[BulletList]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bulletList</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.BulletList" class="extype" href="../../tree/Elements$$BulletList.html">BulletList</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a bullet list with any of the supported bullet characters.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a bullet list with any of the supported bullet characters.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#bullet-lists">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#bullet-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#chainl1" data-isabs="false">
      <a id="chainl1[T, U](⇒ Parser[T],⇒ Parser[U],⇒ Parser[(T, U) ⇒ T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="first">first: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(T, U) ⇒ T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#chainl1" data-isabs="false">
      <a id="chainl1[T](⇒ Parser[T],⇒ Parser[(T, T) ⇒ T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(T, T) ⇒ T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#chainr1" data-isabs="false">
      <a id="chainr1[T, U](⇒ Parser[T],⇒ Parser[(T, U) ⇒ U],(T, U) ⇒ U,U):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainr1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(T, U) ⇒ U]</span>, <span name="combine">combine: (T, U) ⇒ U</span>, <span name="first">first: U</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#charToTraversalble" data-isabs="false">
      <a id="charToTraversalble(Char):Traversable[Char]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">charToTraversalble</span><span class="params">(<span name="char">char: <span name="scala.Char" class="extype">Char</span></span>)</span><span class="result">: Traversable[<span name="scala.Char" class="extype">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#citation" data-isabs="false">
      <a id="citation:Parser[Citation]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">citation</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Citation" class="extype" href="../../tree/Elements$$Citation.html">Citation</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a citation.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a citation.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citations">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citations</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#comment" data-isabs="false">
      <a id="comment:Parser[Comment]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">comment</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Comment" class="extype" href="../../tree/Elements$$Comment.html">Comment</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a comment.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a comment.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#comments">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#comments</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#commit" data-isabs="false">
      <a id="commit[T](⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commit</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ListParsers#definitionList" data-isabs="false">
      <a id="definitionList:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">definitionList</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a definition list.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a definition list.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#definition-lists">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#definition-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#doctest" data-isabs="false">
      <a id="doctest:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doctest</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a doctest block.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a doctest block. This is a feature which is very specific to the
 world of Python where reStructuredText originates. Therefore the resulting
 <code>DoctestBlock</code> tree element is not part of the standard Laika tree model.
 When this block type is used the corresponding special renderers must
 be enabled (e.g. the <code>ExtendedHTML</code> renderer for HTML).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#doctest-blocks">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#doctest-blocks</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#document" data-isabs="false">
      <a id="document:Parser[Document]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">document</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Document" class="extype" href="../../tree/Elements$$Document.html">Document</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full document and applies the default rules for resolving
 all kinds of references like footnotes, citations, link references,
 text roles and substitutions.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full document and applies the default rules for resolving
 all kinds of references like footnotes, citations, link references,
 text roles and substitutions.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockParsers" class="extype" href="">BlockParsers</a> → <a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#elem" data-isabs="false">
      <a id="elem(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="e">e: Elem</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#elem" data-isabs="false">
      <a id="elem(String,(Elem) ⇒ Boolean):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="kind">kind: String</span>, <span name="p">p: (Elem) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ListParsers#enumList" data-isabs="false">
      <a id="enumList:Parser[EnumList]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">enumList</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.EnumList" class="extype" href="../../tree/Elements$$EnumList.html">EnumList</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an enumerated list in any of the supported combinations of enumeration style and formatting.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an enumerated list in any of the supported combinations of enumeration style and formatting.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#enumerated-lists">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#enumerated-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#eof" data-isabs="false">
      <a id="eof:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eof</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#eol" data-isabs="false">
      <a id="eol:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eol</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of a line, including the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of a line, including the end of the input.
 Produces an empty string as a result and consumes any new line characters.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#err" data-isabs="false">
      <a id="err(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">err</span><span class="params">(<span name="msg">msg: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Nothing" class="extype">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#explicitBlockItem" data-isabs="false">
      <a id="explicitBlockItem:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">explicitBlockItem</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all types of explicit block items.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all types of explicit block items.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#explicit-markup-blocks">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#explicit-markup-blocks</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#failure" data-isabs="false">
      <a id="failure(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Nothing" class="extype">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ListParsers#fieldList" data-isabs="false">
      <a id="fieldList:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldList</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a field list.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a field list.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#field-lists">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#field-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#fixedIndentedBlock" data-isabs="false">
      <a id="fixedIndentedBlock(Int,⇒ Parser[Any],⇒ Parser[Any]):Parser[IndentedBlock]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fixedIndentedBlock</span><span class="params">(<span name="fixedIndent">fixedIndent: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">1</span></span>, <span name="linePrefix">linePrefix: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>] = <span class="symbol"><span class="name"><a href="../BlockParsers.html#blankLine:Parser[String]">not(blankLine)</a></span></span></span>, <span name="nextBlockPrefix">nextBlockPrefix: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>] = <span class="symbol"><span class="name"><a href="../BlockParsers.html#blankLine:Parser[String]">not(blankLine)</a></span></span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.parse.rst.BlockBaseParsers.IndentedBlock" class="extype" href="BlockBaseParsers$IndentedBlock.html">IndentedBlock</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first. The indentation must be as specified by the first parameter
 for all lines of these blocks.
</p></div><dl class="paramcmts block"><dt class="param">fixedIndent</dt><dd class="cmt"><p>the indentation that each line in this block must have</p></dd><dt class="param">linePrefix</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">nextBlockPrefix</dt><dd class="cmt"><p>parser that recognizes whether a line after one or more blank lines still belongs to the same block</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that produces an instance of IndentedBlock
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#footnote" data-isabs="false">
      <a id="footnote:Parser[FootnoteDefinition]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">footnote</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.FootnoteDefinition" class="extype" href="../../tree/Elements$$FootnoteDefinition.html">FootnoteDefinition</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a footnote.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a footnote.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnotes">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnotes</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.TableParsers#gridTable" data-isabs="false">
      <a id="gridTable:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gridTable</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a grid table.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a grid table.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#grid-tables">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#grid-tables</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.TableParsers" class="extype" href="TableParsers.html">TableParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#guard" data-isabs="false">
      <a id="guard[T](⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">guard</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="prt" name="scala.util.parsing.combinator.RegexParsers#handleWhiteSpace" data-isabs="false">
      <a id="handleWhiteSpace(CharSequence,Int):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleWhiteSpace</span><span class="params">(<span name="source">source: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>, <span name="offset">offset: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#headerWithOverline" data-isabs="false">
      <a id="headerWithOverline:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headerWithOverline</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a section header with both overline and underline.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a section header with both overline and underline.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#headerWithUnderline" data-isabs="false">
      <a id="headerWithUnderline:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headerWithUnderline</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a section header with an underline, but no overline.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a section header with an underline, but no overline.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections</a>.
</p></div></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#lastNoSuccess" data-isabs="false">
      <a id="lastNoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">lastNoSuccess</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.NoSuccess" class="extype">NoSuccess</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ListParsers#lineBlock" data-isabs="false">
      <a id="lineBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lineBlock</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a block of lines with line breaks preserved.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a block of lines with line breaks preserved.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#line-blocks">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#line-blocks</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#linkTarget" data-isabs="false">
      <a id="linkTarget:Parser[Block with Serializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">linkTarget</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a> with <span name="scala.Serializable" class="extype">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a link definition, either an internal, external or indirect link.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a link definition, either an internal, external or indirect link.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-targets">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-targets</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#literal" data-isabs="false">
      <a id="literal(String):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="s">s: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#literalBlock" data-isabs="false">
      <a id="literalBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literalBlock</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a literal block, either quoted or indented.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a literal block, either quoted or indented.
 Only used when the preceding block ends with a double colon (<code>::</code>).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks</a>
</p></div></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#log" data-isabs="false">
      <a id="log[T](⇒ Parser[T])(String):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">log</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="params">(<span name="name">name: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#lookBehind" data-isabs="false">
      <a id="lookBehind[T](Int,⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookBehind</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span name="scala.Int" class="extype">Int</span></span>, <span name="parser">parser: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#maxNestLevel" data-isabs="false">
      <a id="maxNestLevel:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">maxNestLevel</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The maximum level of block nesting.</p><div class="fullcomment"><div class="comment cmt"><p>The maximum level of block nesting. Some block types like lists
 and blockquotes contain nested blocks. To protect against malicious
 input or accidentally broken markup, the level of nesting is restricted.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#mkList" data-isabs="false">
      <a id="mkList[T]:(~[T, List[T]]) ⇒ List[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkList</span><span class="tparams">[<span name="T">T</span>]</span><span class="result">: (<span name="scala.util.parsing.combinator.Parsers.~" class="extype">~</span>[T, List[T]]) ⇒ <span name="scala.collection.immutable.List" class="extype">List</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#nestLevel" data-isabs="false">
      <a id="nestLevel(Input):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nestLevel</span><span class="params">(<span name="reader">reader: Input</span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the current nest level from the specified input or 0 if it cannot be determined.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the current nest level from the specified input or 0 if it cannot be determined.</p><p> The nest level is usually only used to prevent endless recursion of nested blocks.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#nestedBlock" data-isabs="false">
      <a id="nestedBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nestedBlock</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses any kind of nested block supported by a concrete markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any kind of nested block supported by a concrete markup language.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockParsers" class="extype" href="">BlockParsers</a> → <a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#nonRecursiveBlock" data-isabs="false">
      <a id="nonRecursiveBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nonRecursiveBlock</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses reStructuredText blocks, except for blocks that allow nesting of blocks.</p><div class="fullcomment"><div class="comment cmt"><p>Parses reStructuredText blocks, except for blocks that allow nesting of blocks.
 Only used in rare cases when the maximum nest level allowed had been reached
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockParsers" class="extype" href="">BlockParsers</a> → <a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#not" data-isabs="false">
      <a id="not[T](⇒ Parser[T]):Parser[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Unit" class="extype">Unit</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#opt" data-isabs="false">
      <a id="opt[T](⇒ Parser[T]):Parser[Option[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Option" class="extype">Option</span>[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="prt" name="laika.parse.MarkupParsers#optimizedCharLookup" data-isabs="false">
      <a id="optimizedCharLookup(Char*):(Char) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedCharLookup</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: (<span name="scala.Char" class="extype">Char</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="prt" name="laika.parse.MarkupParsers#optimizedRangeLookup" data-isabs="false">
      <a id="optimizedRangeLookup(Traversable[Char]*):(Char) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedRangeLookup</span><span class="params">(<span name="ranges">ranges: Traversable[<span name="scala.Char" class="extype">Char</span>]*</span>)</span><span class="result">: (<span name="scala.Char" class="extype">Char</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified ranges of characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified ranges of characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ListParsers#optionList" data-isabs="false">
      <a id="optionList:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optionList</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an option list.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an option list.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#option-lists">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#option-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#paragraph" data-isabs="false">
      <a id="paragraph:Parser[Paragraph]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">paragraph</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Paragraph" class="extype" href="../../tree/Elements$$Paragraph.html">Paragraph</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single paragraph.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single paragraph. Everything between two blank lines that is not
 recognized as a special reStructuredText block type will be parsed as a regular paragraph.
</p></div></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parse" data-isabs="false">
      <a id="parse[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.io.Reader" class="extype">Reader</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parse" data-isabs="false">
      <a id="parse[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parse" data-isabs="false">
      <a id="parse[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parseAll" data-isabs="false">
      <a id="parseAll[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parseAll" data-isabs="false">
      <a id="parseAll[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.io.Reader" class="extype">Reader</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parseAll" data-isabs="false">
      <a id="parseAll[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#parseDocument" data-isabs="false">
      <a id="parseDocument(Reader[Char]):Document"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseDocument</span><span class="params">(<span name="reader">reader: <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="result">: <a name="laika.tree.Elements.Document" class="extype" href="../../tree/Elements$$Document.html">Document</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input from the specified reader and returns the document tree.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input from the specified reader and returns the document tree.
 This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#parseMarkup" data-isabs="false">
      <a id="parseMarkup[T](Parser[T],Reader[Char]):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="reader">reader: <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input from the specified reader and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input from the specified reader and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#parseMarkup" data-isabs="false">
      <a id="parseMarkup[T](Parser[T],String):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="source">source: String</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the specified input string and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the specified input string and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#parseNestedBlocks" data-isabs="false">
      <a id="parseNestedBlocks(List[String],Int):List[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseNestedBlocks</span><span class="params">(<span name="lines">lines: List[String]</span>, <span name="nestLevel">nestLevel: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: List[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all nested blocks for the specified input and nest level.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all nested blocks for the specified input and nest level.
 The nest level is primarily used as a protection against malicious
 input that forces endless recursion.
</p></div><dl class="paramcmts block"><dt class="param">lines</dt><dd class="cmt"><p>the input to parse</p></dd><dt class="param">nestLevel</dt><dd class="cmt"><p>the level of nesting with 0 being the outermost level</p></dd><dt>returns</dt><dd class="cmt"><p>the parser result as a list of blocks
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#parseNestedBlocks" data-isabs="false">
      <a id="parseNestedBlocks(IndentedBlock):List[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseNestedBlocks</span><span class="params">(<span name="block">block: <a name="laika.parse.rst.BlockBaseParsers.IndentedBlock" class="extype" href="BlockBaseParsers$IndentedBlock.html">IndentedBlock</a></span>)</span><span class="result">: List[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all nested blocks inside the specified indented block.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all nested blocks inside the specified indented block.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#parseNestedBlocks" data-isabs="false">
      <a id="parseNestedBlocks(List[String],Parser[Block]):List[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseNestedBlocks</span><span class="params">(<span name="lines">lines: List[String]</span>, <span name="parser">parser: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>)</span><span class="result">: List[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the list of lines and returns a list of blocks, using the specified
 parser for parsing individual blocks instead of the default <code>nestedBlock</code> parser.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the list of lines and returns a list of blocks, using the specified
 parser for parsing individual blocks instead of the default <code>nestedBlock</code> parser.</p><p> This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#parseNestedBlocks" data-isabs="false">
      <a id="parseNestedBlocks(List[String]):List[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseNestedBlocks</span><span class="params">(<span name="lines">lines: List[String]</span>)</span><span class="result">: List[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the list of lines and returns a list of blocks, delegating to the
 abstract <code>nestedBlock</code> parser that sub-traits need to define.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the list of lines and returns a list of blocks, delegating to the
 abstract <code>nestedBlock</code> parser that sub-traits need to define.</p><p> This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#phrase" data-isabs="false">
      <a id="phrase[T](Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">phrase</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#positioned" data-isabs="false">
      <a id="positioned[T&lt;:Positional](⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">positioned</span><span class="tparams">[<span name="T">T &lt;: <span name="scala.util.parsing.input.Positional" class="extype">Positional</span></span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#punctuationChar" data-isabs="false">
      <a id="punctuationChar:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">punctuationChar</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses punctuation characters as supported by transitions (rules) and
 overlines and underlines for header sections.</p>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#regex" data-isabs="false">
      <a id="regex(Regex):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">regex</span><span class="params">(<span name="r">r: <span name="scala.util.matching.Regex" class="extype">Regex</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep" data-isabs="false">
      <a id="rep[T](⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep1" data-isabs="false">
      <a id="rep1[T](⇒ Parser[T],⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="first">first: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="p0">p0: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> The <code>p0</code> call-by-name arguments is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.</p></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep1" data-isabs="false">
      <a id="rep1[T](⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep1sep" data-isabs="false">
      <a id="rep1sep[T](⇒ Parser[T],⇒ Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1sep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#repMax" data-isabs="false">
      <a id="repMax[T](Int,⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMax</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span name="scala.Int" class="extype">Int</span></span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at most the specified number of repetitions, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at most the specified number of repetitions, always succeeds.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#repMin" data-isabs="false">
      <a id="repMin[T](Int,⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMin</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span name="scala.Int" class="extype">Int</span></span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at least the specified number of repetitions or otherwise fails.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at least the specified number of repetitions or otherwise fails.
 Continues to apply the parser after the minimum has been reached until if fails.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#repN" data-isabs="false">
      <a id="repN[T](Int,⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repN</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span name="scala.Int" class="extype">Int</span></span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#repsep" data-isabs="false">
      <a id="repsep[T](⇒ Parser[T],⇒ Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repsep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#restOfLine" data-isabs="false">
      <a id="restOfLine:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">restOfLine</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text. Does not include the eol character(s).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#roleDirective" data-isabs="false">
      <a id="roleDirective:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">roleDirective</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a role directive.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a role directive.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles">http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#shortAnonymousLinkTarget" data-isabs="false">
      <a id="shortAnonymousLinkTarget:Parser[ExternalLinkDefinition]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">shortAnonymousLinkTarget</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.ExternalLinkDefinition" class="extype" href="../../tree/Elements$$ExternalLinkDefinition.html">ExternalLinkDefinition</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the short variant of an anonymous link definition
 (that starts with <code><u><code> instead of </code>.. </u>:</code>)</p><div class="fullcomment"><div class="comment cmt"><p>Parses the short variant of an anonymous link definition
 (that starts with <code><u><code> instead of </code>.. </u>:</code>)</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#anonymous-hyperlinks">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#anonymous-hyperlinks</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.TableParsers#simpleTable" data-isabs="false">
      <a id="simpleTable:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">simpleTable</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a simple table.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a simple table.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#simple-tables">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#simple-tables</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.TableParsers" class="extype" href="TableParsers.html">TableParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#skipWhitespace" data-isabs="false">
      <a id="skipWhitespace:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">skipWhitespace</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a> → RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#substitutionDefinition" data-isabs="false">
      <a id="substitutionDefinition:Parser[Block with Serializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">substitutionDefinition</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a> with <span name="scala.Serializable" class="extype">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a substitution definition.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a substitution definition.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-definitions">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-definitions</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#success" data-isabs="false">
      <a id="success[T](T):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: T</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.BlockParsers#textLine" data-isabs="false">
      <a id="textLine:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">textLine</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single text line from the current input offset (which may not be at the
 start of the line.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single text line from the current input offset (which may not be at the
 start of the line. Fails for blank lines. Does not include the eol character(s).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#toParserOps" data-isabs="false">
      <a id="toParserOps[A](Parser[A]):ParserOps[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toParserOps</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="parser">parser: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[A]</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.ParserOps" class="extype" href="../MarkupParsers$ParserOps.html">ParserOps</a>[A]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#topLevelBlock" data-isabs="false">
      <a id="topLevelBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">topLevelBlock</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Block" class="extype" href="../../tree/Elements$$Block.html">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses any kind of top-level block supported by a concrete markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any kind of top-level block supported by a concrete markup language.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockParsers" class="extype" href="">BlockParsers</a> → <a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockParsers#transition" data-isabs="false">
      <a id="transition:Parser[Rule]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">transition</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Rule" class="extype" href="../../tree/Elements$$Rule.html">Rule</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a transition (rule).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a transition (rule).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#transitions">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#transitions</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#varIndentedBlock" data-isabs="false">
      <a id="varIndentedBlock(Int,⇒ Parser[Any],⇒ Parser[Any],Boolean):Parser[IndentedBlock]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">varIndentedBlock</span><span class="params">(<span name="minIndent">minIndent: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">1</span></span>, <span name="linePrefix">linePrefix: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>] = <span class="symbol"><span class="name"><a href="../BlockParsers.html#blankLine:Parser[String]">not(blankLine)</a></span></span></span>, <span name="nextBlockPrefix">nextBlockPrefix: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>] = <span class="symbol"><span class="name"><a href="../BlockParsers.html#blankLine:Parser[String]">not(blankLine)</a></span></span></span>, <span name="firstLineIndented">firstLineIndented: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.parse.rst.BlockBaseParsers.IndentedBlock" class="extype" href="BlockBaseParsers$IndentedBlock.html">IndentedBlock</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first. The indentation may vary between the parts of the indented
 block, so that this parser only cuts off the minimum indentation shared by all lines,
 but each line must have at least the specified minimum indentation.
</p></div><dl class="paramcmts block"><dt class="param">minIndent</dt><dd class="cmt"><p>the minimum indentation that each line in this block must have</p></dd><dt class="param">linePrefix</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">nextBlockPrefix</dt><dd class="cmt"><p>parser that recognizes whether a line after one or more blank lines still belongs to the same block</p></dd><dt class="param">firstLineIndented</dt><dd class="cmt"><p>indicates whether the first line is expected to be indented, too</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that produces an instance of IndentedBlock
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="prt" name="scala.util.parsing.combinator.RegexParsers#whiteSpace" data-isabs="false">
      <a id="whiteSpace:Regex"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">whiteSpace</span><span class="result">: <span name="scala.util.matching.Regex" class="extype">Regex</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.ExplicitBlockParsers#withFailureMessage" data-isabs="false">
      <a id="withFailureMessage[T](⇒ Parser[T],String):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFailureMessage</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="msg">msg: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Overrides the failure message to the specified parser.</p><div class="fullcomment"><div class="comment cmt"><p>Overrides the failure message to the specified parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#withNestLevel" data-isabs="false">
      <a id="withNestLevel[T](⇒ Parser[T]):Parser[(Int, T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withNestLevel</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(<span name="scala.Int" class="extype">Int</span>, T)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new parser that produces a tuple containing the current nest
 level as well as the result from the specified parser.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new parser that produces a tuple containing the current nest
 level as well as the result from the specified parser.</p><p> The nest level is usually only used to prevent endless recursion of nested blocks.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.BlockBaseParsers#ws" data-isabs="false">
      <a id="ws:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ws</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses horizontal whitespace (space and tab).</p><div class="fullcomment"><div class="comment cmt"><p>Parses horizontal whitespace (space and tab).
 Always succeeds, consuming all whitespace found.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a> → <a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li></ol>
            </div>

        
        </div>

        <div id="inheritedMembers">
        <div name="laika.parse.rst.ExplicitBlockParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.rst.ExplicitBlockParsers" class="extype" href="ExplicitBlockParsers.html">ExplicitBlockParsers</a></h3>
            </div><div name="laika.parse.rst.TableParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.rst.TableParsers" class="extype" href="TableParsers.html">TableParsers</a></h3>
            </div><div name="laika.parse.rst.ListParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.rst.ListParsers" class="extype" href="ListParsers.html">ListParsers</a></h3>
            </div><div name="laika.parse.rst.BlockBaseParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.rst.BlockBaseParsers" class="extype" href="BlockBaseParsers.html">BlockBaseParsers</a></h3>
            </div><div name="laika.parse.BlockParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.BlockParsers" class="extype" href="../BlockParsers.html">BlockParsers</a></h3>
            </div><div name="laika.parse.MarkupParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></h3>
            </div><div name="scala.util.parsing.combinator.RegexParsers" class="parent">
              <h3>Inherited from <span name="scala.util.parsing.combinator.RegexParsers" class="extype">RegexParsers</span></h3>
            </div><div name="scala.util.parsing.combinator.Parsers" class="parent">
              <h3>Inherited from <span name="scala.util.parsing.combinator.Parsers" class="extype">Parsers</span></h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>