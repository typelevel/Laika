<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>laika.parse.rst.InlineParsers</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../lib/template.css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="type">
      <div id="definition">
        <img src="../../../lib/trait_big.png" />
        <p id="owner"><a name="laika" class="extype" href="../../package.html">laika</a>.<a name="laika.parse" class="extype" href="../package.html">parse</a>.<a name="laika.parse.rst" class="extype" href="package.html">rst</a></p>
        <h1>InlineParsers</h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">InlineParsers</span><span class="result"> extends <a name="laika.parse.InlineParsers" class="extype" href="../InlineParsers.html">InlineParsers</a> with <a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>Provides all inline parsers for reStructuredText.</p><p> Inline parsers deal with markup within a block of text, such as a
 link or emphasized text. They are used in the second phase of parsing,
 after the block parsers have cut the document into a (potentially nested)
 block structure.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a>, <a name="laika.parse.InlineParsers" class="extype" href="../InlineParsers.html">InlineParsers</a>, <a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a>, <span name="scala.util.parsing.combinator.RegexParsers" class="extype">RegexParsers</span>, <span name="scala.util.parsing.combinator.Parsers" class="extype">Parsers</span>, AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="laika.parse.rst.InlineParsers" class="in"><span>InlineParsers</span></li><li name="laika.parse.util.URIParsers" class="in"><span>URIParsers</span></li><li name="laika.parse.InlineParsers" class="in"><span>InlineParsers</span></li><li name="laika.parse.MarkupParsers" class="in"><span>MarkupParsers</span></li><li name="scala.util.parsing.combinator.RegexParsers" class="in"><span>RegexParsers</span></li><li name="scala.util.parsing.combinator.Parsers" class="in"><span>Parsers</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div class="types members" id="types">
              <h3>Type Members</h3>
              <ol><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#Elem" data-isabs="false">
      <a id="Elem:Elem"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Elem</span><span class="result"> = <span name="scala.Char" class="extype">Char</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#Input" data-isabs="false">
      <a id="Input:Input"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Input</span><span class="result"> = <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers.MarkupParserException" data-isabs="false">
      <a id="MarkupParserException:MarkupParserException"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../MarkupParsers$MarkupParserException.html"><span class="name">MarkupParserException</span></a><span class="result"> extends RuntimeException</span>
      </span>
      </h4>
      <p class="comment cmt">Exception thrown when parsing a text markup document or fragment fails.</p>
    </li><li visbl="pub" name="laika.parse.MarkupParsers.ParserOps" data-isabs="false">
      <a id="ParserOps:ParserOps[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../MarkupParsers$ParserOps.html"><span class="name">ParserOps</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      <p class="comment cmt">Provides additional combinator methods to parsers via implicit conversion.</p>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers.ReferenceName" data-isabs="false">
      <a id="ReferenceName:ReferenceName"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="InlineParsers$ReferenceName.html"><span class="name">ReferenceName</span></a><span class="params">(<span name="original">original: String</span>)</span><span class="result"> extends Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">Represent a reference name.</p>
    </li><li visbl="pub" name="laika.parse.InlineParsers.ResultBuilder" data-isabs="true">
      <a id="ResultBuilder:ResultBuilder[Elem, To]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="../InlineParsers$ResultBuilder.html"><span class="name">ResultBuilder</span></a><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">+To</span>]</span><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      <p class="comment cmt">Abstracts the internal process of building up the result of an inline parser.</p>
    </li><li visbl="prt" name="laika.parse.rst.InlineParsers.Reverse" data-isabs="false">
      <a id="Reverse:Reverse"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="InlineParsers$Reverse.html"><span class="name">Reverse</span></a><span class="params">(<span name="length">length: Int</span>, <span name="target">target: Span</span>, <span name="fallback">fallback: Span</span>, <span name="options">options: Options</span>)</span><span class="result"> extends Element with Span with Product with Serializable</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li visbl="pub" name="laika.parse.InlineParsers.SpanBuilder" data-isabs="false">
      <a id="SpanBuilder:SpanBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../InlineParsers$SpanBuilder.html"><span class="name">SpanBuilder</span></a><span class="result"> extends ResultBuilder[Span, List[Span]]</span>
      </span>
      </h4>
      <p class="comment cmt">ResultBuilder that produces a list of spans.</p>
    </li><li visbl="pub" name="laika.parse.InlineParsers.TextBuilder" data-isabs="false">
      <a id="TextBuilder:TextBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../InlineParsers$TextBuilder.html"><span class="name">TextBuilder</span></a><span class="result"> extends ResultBuilder[String, String]</span>
      </span>
      </h4>
      <p class="comment cmt">ResultBuilder that produces a String.</p>
    </li><li visbl="pub" name="laika.parse.MarkupParsers.TextParser" data-isabs="false">
      <a id="TextParser:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../MarkupParsers$TextParser.html"><span class="name">TextParser</span></a><span class="result"> extends Parser[String]</span>
      </span>
      </h4>
      <p class="comment cmt">API for specifying further constraints on the parsers provided by this base trait.</p>
    </li></ol>
            </div>

        

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#OnceParser" data-isabs="false">
      <a id="OnceParser[T]((Input) ⇒ ParseResult[T]):Parser[T] with OnceParser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (Input) ⇒ <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T] with <span name="scala.util.parsing.combinator.Parsers.OnceParser" class="extype">OnceParser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#Parser" data-isabs="false">
      <a id="Parser[T]((Input) ⇒ ParseResult[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (Input) ⇒ <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#accept" data-isabs="false">
      <a id="accept[U](String,PartialFunction[Elem, U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: String</span>, <span name="f">f: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[Elem, U]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#accept" data-isabs="false">
      <a id="accept[ES](ES)((ES) ⇒ List[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: ES</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (ES) ⇒ List[Elem]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[Elem]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#accept" data-isabs="false">
      <a id="accept(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="params">(<span name="e">e: Elem</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#acceptIf" data-isabs="false">
      <a id="acceptIf((Elem) ⇒ Boolean)((Elem) ⇒ String):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptIf</span><span class="params">(<span name="p">p: (Elem) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="params">(<span name="err">err: (Elem) ⇒ String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#acceptMatch" data-isabs="false">
      <a id="acceptMatch[U](String,PartialFunction[Elem, U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptMatch</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: String</span>, <span name="f">f: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[Elem, U]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#acceptSeq" data-isabs="false">
      <a id="acceptSeq[ES](ES)((ES) ⇒ Iterable[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptSeq</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: ES</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (ES) ⇒ Iterable[Elem]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[Elem]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#addrSpec" data-isabs="false">
      <a id="addrSpec:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">addrSpec</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single email address as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single email address as defined in RFC 6068.</p><pre>
 addr-spec = local-part <span class="lit">"@"</span> domain
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#alpha" data-isabs="false">
      <a id="alpha:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">alpha</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses letters according to RFC 2234.</p><div class="fullcomment"><div class="comment cmt"><p>Parses letters according to RFC 2234.</p><pre>
 ALPHA =  %x41-<span class="num">5</span>A / %x61-<span class="num">7</span>A ; A-Z / a-z
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#any" data-isabs="false">
      <a id="any:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">any</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any kind of input, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any kind of input, always succeeds.
 This parser would consume the entire input unless a <code>max</code> constraint
 is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyBut" data-isabs="false">
      <a id="anyBut(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyBut</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyIn" data-isabs="false">
      <a id="anyIn(Traversable[Char]*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyIn</span><span class="params">(<span name="ranges">ranges: Traversable[<span name="scala.Char" class="extype">Char</span>]*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are in one of the specified character ranges.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are in one of the specified character ranges.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyOf" data-isabs="false">
      <a id="anyOf(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyUntil" data-isabs="false">
      <a id="anyUntil(⇒ Parser[Any]):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="until">until: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of characters for which the specified parser fails on the corresponding offset.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of characters for which the specified parser fails on the corresponding offset.
 This parser fails if the end of input is reached without the specified parser ever succeeding or
 if the parser causes an Error result instead of a plain Failure or Success.
 Further constraints like minimum or maximum number of required matching characters can be specified
 through the API of the returned <code>TextParser</code> instance.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyUntil" data-isabs="false">
      <a id="anyUntil(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.</p><p> This parser is identical to the <code>anyBut</code> parser except for two differences: this parser fails
 if it reaches the end of the input without seeing any of the specified
 characters and it also consumes this final character, without adding it
 to the result. This parser is usually used when a construct like a span
 enclosed between two characters needs to be parsed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#anyWhile" data-isabs="false">
      <a id="anyWhile((Char) ⇒ Boolean):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyWhile</span><span class="params">(<span name="p">p: (<span name="scala.Char" class="extype">Char</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters which satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters which satisfy the specified predicate.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#atStart" data-isabs="false">
      <a id="atStart:Parser[Parser[Unit]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">atStart</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Unit" class="extype">Unit</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the start of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the start of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#authority" data-isabs="false">
      <a id="authority:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">authority</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the authority part of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the authority part of a URI as defined in RFC 3986.</p><pre>
 authority = [ userinfo <span class="lit">"@"</span> ] host [ <span class="lit">":"</span> port ]
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#chainl1" data-isabs="false">
      <a id="chainl1[T, U](⇒ Parser[T],⇒ Parser[U],⇒ Parser[(T, U) ⇒ T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="first">first: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(T, U) ⇒ T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#chainl1" data-isabs="false">
      <a id="chainl1[T](⇒ Parser[T],⇒ Parser[(T, T) ⇒ T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(T, T) ⇒ T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#chainr1" data-isabs="false">
      <a id="chainr1[T, U](⇒ Parser[T],⇒ Parser[(T, U) ⇒ U],(T, U) ⇒ U,U):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainr1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(T, U) ⇒ U]</span>, <span name="combine">combine: (T, U) ⇒ U</span>, <span name="first">first: U</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#charToTraversalble" data-isabs="false">
      <a id="charToTraversalble(Char):Traversable[Char]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">charToTraversalble</span><span class="params">(<span name="char">char: <span name="scala.Char" class="extype">Char</span></span>)</span><span class="result">: Traversable[<span name="scala.Char" class="extype">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#citationRef" data-isabs="false">
      <a id="citationRef:Parser[CitationReference]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">citationRef</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.CitationReference" class="extype" href="../../tree/Elements$$CitationReference.html">CitationReference</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a citation reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a citation reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citation-references">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citation-references</a>.
</p></div></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#commit" data-isabs="false">
      <a id="commit[T](⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commit</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#defaultTextRole" data-isabs="false">
      <a id="defaultTextRole:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">defaultTextRole</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The default text role to use when no role is specified in an interpreted text element.</p>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#digit" data-isabs="false">
      <a id="digit:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">digit</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses digits according to RFC 2234.</p><div class="fullcomment"><div class="comment cmt"><p>Parses digits according to RFC 2234.</p><pre>
 DIGIT =  %x30-<span class="num">39</span>; <span class="num">0</span>-<span class="num">9</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#domain" data-isabs="false">
      <a id="domain:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">domain</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the domain portion of an email address as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the domain portion of an email address as defined in RFC 6068.</p><pre>
 domain       = dot-atom-text / <span class="lit">"["</span> *dtext-no-obs <span class="lit">"]"</span>
 dtext-no-obs = %d33-<span class="num">90</span> / ; Printable US-ASCII
                %d94-<span class="num">126</span>  ; characters not including
                          ; <span class="lit">"["</span>, <span class="lit">"]"</span>, or <span class="lit">"\"
</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#dotAtomText" data-isabs="false">
      <a id="dotAtomText:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">dotAtomText</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a <code>dot-atom-text</code> sequence as defined in RFC 5322.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a <code>dot-atom-text</code> sequence as defined in RFC 5322.</p><pre>
 dot-atom-text   =   <span class="num">1</span>*atext *(<span class="lit">"."</span> <span class="num">1</span>*atext)

  atext           =   ALPHA / DIGIT /    ; Printable US-ASCII
                   <span class="lit">"!"</span> / <span class="lit">"#"</span> /        ;  characters not including
                   <span class="lit">"$"</span> / <span class="lit">"%"</span> /        ;  specials.  Used <span class="kw">for</span> atoms.
                   <span class="lit">"&"</span> / <span class="lit">"'"</span> /
                   <span class="lit">"*"</span> / <span class="lit">"+"</span> /
                   <span class="lit">"-"</span> / <span class="lit">"/"</span> /
                   <span class="lit">"="</span> / <span class="lit">"?"</span> /
                   <span class="lit">"^"</span> / <span class="lit">"_"</span> /
                   <span class="lit">"`"</span> / <span class="lit">"{"</span> /
                   <span class="lit">"|"</span> / <span class="lit">"}"</span> /
                   <span class="lit">"~"</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#elem" data-isabs="false">
      <a id="elem(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="e">e: Elem</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#elem" data-isabs="false">
      <a id="elem(String,(Elem) ⇒ Boolean):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="kind">kind: String</span>, <span name="p">p: (Elem) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#em" data-isabs="false">
      <a id="em:Parser[Emphasized]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">em</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Emphasized" class="extype" href="../../tree/Elements$$Emphasized.html">Emphasized</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a span of emphasized text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a span of emphasized text.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#emphasis">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#emphasis</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#email" data-isabs="false">
      <a id="email:Parser[(String, String, String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">email</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(String, <span name="java.lang.String" class="extype">String</span>, String)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a standalone email address (with no surrounding markup).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a standalone email address (with no surrounding markup).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#emailAddress" data-isabs="false">
      <a id="emailAddress:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">emailAddress</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a mailto URI without the scheme part as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a mailto URI without the scheme part as defined in RFC 6068.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#emailURI" data-isabs="false">
      <a id="emailURI:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">emailURI</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full mailto URI as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full mailto URI as defined in RFC 6068.</p><pre>
 mailtoURI = <span class="lit">"mailto:"</span> [ to ] [ hfields ]
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#eof" data-isabs="false">
      <a id="eof:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eof</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#eol" data-isabs="false">
      <a id="eol:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eol</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of a line, including the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of a line, including the end of the input.
 Produces an empty string as a result and consumes any new line characters.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#err" data-isabs="false">
      <a id="err(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">err</span><span class="params">(<span name="msg">msg: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Nothing" class="extype">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#escapedChar" data-isabs="false">
      <a id="escapedChar:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">escapedChar</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="java.lang.String" class="extype">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an escaped character.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an escaped character. For most characters it produces the character
 itself as the result with the only exception being an escaped space character
 which is removed from the output in reStructuredText.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#escaping-mechanism">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#escaping-mechanism</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#escapedText" data-isabs="false">
      <a id="escapedText(TextParser):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">escapedText</span><span class="params">(<span name="p">p: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Adds support for escape sequences to the specified text parser.</p><div class="fullcomment"><div class="comment cmt"><p>Adds support for escape sequences to the specified text parser.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the parser to add support for escape sequences to</p></dd><dt>returns</dt><dd class="cmt"><p>a parser for a text span that supports escape sequences
</p></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#escapedUntil" data-isabs="false">
      <a id="escapedUntil(Char):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">escapedUntil</span><span class="params">(<span name="char">char: <span name="scala.Char" class="extype">Char</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a span of text until the specified character is seen
 (unless it is escaped),
 while also processing escaped characters, but no other nested
 spans.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a span of text until the specified character is seen
 (unless it is escaped),
 while also processing escaped characters, but no other nested
 spans. The final character is not included in the result.
</p></div><dl class="paramcmts block"><dt class="param">char</dt><dd class="cmt"><p>the character that signals the end of the text span</p></dd><dt>returns</dt><dd class="cmt"><p>a parser for a text span that supports escape sequences
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#failure" data-isabs="false">
      <a id="failure(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Nothing" class="extype">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#flatten" data-isabs="false">
      <a id="flatten(Any):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatten</span><span class="params">(<span name="result">result: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Flattens the result from various combinators,
 including the <code>repX</code> variants and <code>~</code> into
 a single string.</p><div class="fullcomment"><div class="comment cmt"><p>Flattens the result from various combinators,
 including the <code>repX</code> variants and <code>~</code> into
 a single string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#footnoteLabel" data-isabs="false">
      <a id="footnoteLabel:Parser[Product with Serializable with FootnoteLabel]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">footnoteLabel</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span> with <a name="laika.tree.Elements.FootnoteLabel" class="extype" href="../../tree/Elements$$FootnoteLabel.html">FootnoteLabel</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses any of the four supported types of footnote labels.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any of the four supported types of footnote labels.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#footnoteRef" data-isabs="false">
      <a id="footnoteRef:Parser[FootnoteReference]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">footnoteRef</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.FootnoteReference" class="extype" href="../../tree/Elements$$FootnoteReference.html">FootnoteReference</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a footnote reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a footnote reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#fragment" data-isabs="false">
      <a id="fragment:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">fragment</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the fragment part of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the fragment part of a URI as defined in RFC 3986.</p><pre>
 fragment = *( pchar / <span class="lit">"/"</span> / <span class="lit">"?"</span> )
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#guard" data-isabs="false">
      <a id="guard[T](⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">guard</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="prt" name="scala.util.parsing.combinator.RegexParsers#handleWhiteSpace" data-isabs="false">
      <a id="handleWhiteSpace(CharSequence,Int):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleWhiteSpace</span><span class="params">(<span name="source">source: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>, <span name="offset">offset: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#hexdig" data-isabs="false">
      <a id="hexdig:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">hexdig</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a hexadecimal value according to RFC 2234.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a hexadecimal value according to RFC 2234.</p><pre>
 HEXDIG = DIGIT / <span class="lit">"A"</span> / <span class="lit">"B"</span> / <span class="lit">"C"</span> / <span class="lit">"D"</span> / <span class="lit">"E"</span> / <span class="lit">"F"</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#hfields" data-isabs="false">
      <a id="hfields:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">hfields</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses header fields of an email address as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses header fields of an email address as defined in RFC 6068.</p><pre>
 hfields      = <span class="lit">"?"</span> hfield *( <span class="lit">"&"</span> hfield )
 hfield       = hfname <span class="lit">"="</span> hfvalue
 hfname       = *qchar
 hfvalue      = *qchar

 qchar        = unreserved / pct-encoded / some-delims
 some-delims  = <span class="lit">"!"</span> / <span class="lit">"$"</span> / <span class="lit">"'"</span> / <span class="lit">"("</span> / <span class="lit">")"</span> / <span class="lit">"*"</span>
              / <span class="lit">"+"</span> / <span class="lit">","</span> / <span class="lit">";"</span> / <span class="lit">":"</span> / <span class="lit">"@"</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#hierPart" data-isabs="false">
      <a id="hierPart:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">hierPart</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the hierarchical part of a URI with an authority component as defined in RFC 3986,
 but only the variant including an authority component.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the hierarchical part of a URI with an authority component as defined in RFC 3986,
 but only the variant including an authority component.</p><pre>
 hier-part     = <span class="lit">"//"</span> authority path-abempty
               / path-absolute ; excluded
               / path-rootless ; excluded
               / path-empty    ; excluded
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#host" data-isabs="false">
      <a id="host:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">host</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a host as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a host as defined in RFC 3986.</p><pre>
 host = IP-literal / IPv4address / reg-name
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#httpUri" data-isabs="false">
      <a id="httpUri:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">httpUri</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full HTTP URI including the scheme part and an authority component
 as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full HTTP URI including the scheme part and an authority component
 as defined in RFC 3986.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#httpUriNoScheme" data-isabs="false">
      <a id="httpUriNoScheme:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">httpUriNoScheme</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an HTTP or HTTPS URI with an authority component, but without the scheme part
 (therefore starting with &quot;//&quot;) as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an HTTP or HTTPS URI with an authority component, but without the scheme part
 (therefore starting with &quot;//&quot;) as defined in RFC 3986.</p><pre>
 URI = scheme <span class="lit">":"</span> hier-part [ <span class="lit">"?"</span> query ] [ <span class="lit">"#"</span> fragment ]
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#httpsUri" data-isabs="false">
      <a id="httpsUri:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">httpsUri</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full HTTPS URI including the scheme part and an authority component
 as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full HTTPS URI including the scheme part and an authority component
 as defined in RFC 3986.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.InlineParsers#inline" data-isabs="false">
      <a id="inline[Elem, To](⇒ TextParser,⇒ Map[Char, Parser[Elem]],⇒ ResultBuilder[Elem, To]):Parser[To]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inline</span><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">To</span>]</span><span class="params">(<span name="text">text: ⇒ <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>, <span name="nested">nested: ⇒ Map[<span name="scala.Char" class="extype">Char</span>, <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[Elem]]</span>, <span name="resultBuilder">resultBuilder: ⇒ <a name="laika.parse.InlineParsers.ResultBuilder" class="extype" href="../InlineParsers$ResultBuilder.html">ResultBuilder</a>[Elem, To]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[To]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Generic base parser that parses inline elements based on the specified
 helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Generic base parser that parses inline elements based on the specified
 helper parsers. Usually not used directly by parser implementations,
 this is the base parser the other inline parsers of this trait delegate to.
</p></div><dl class="paramcmts block"><dt class="tparam">Elem</dt><dd class="cmt"><p>the element type produced by a single parser for a nested span</p></dd><dt class="tparam">To</dt><dd class="cmt"><p>the type of the result this parser produces</p></dd><dt class="param">nested</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser for nested span elements</p></dd><dt class="param">resultBuilder</dt><dd class="cmt"><p>responsible for building the final result of this parser based on the results of the helper parsers</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.InlineParsers" class="extype" href="../InlineParsers.html">InlineParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#inlineLiteral" data-isabs="false">
      <a id="inlineLiteral:Parser[Literal]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">inlineLiteral</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Literal" class="extype" href="../../tree/Elements$$Literal.html">Literal</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an inline literal element.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an inline literal element.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-literals">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-literals</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#internalTarget" data-isabs="false">
      <a id="internalTarget:Parser[InternalLinkTarget]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">internalTarget</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.InternalLinkTarget" class="extype" href="../../tree/Elements$$InternalLinkTarget.html">InternalLinkTarget</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an inline internal link target.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an inline internal link target.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-internal-targets">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-internal-targets</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#interpretedTextWithRolePrefix" data-isabs="false">
      <a id="interpretedTextWithRolePrefix:Parser[InterpretedText]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">interpretedTextWithRolePrefix</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.parse.rst.Elements.InterpretedText" class="extype" href="Elements$$InterpretedText.html">InterpretedText</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an interpreted text element with the role name as a prefix.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an interpreted text element with the role name as a prefix.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#interpretedTextWithRoleSuffix" data-isabs="false">
      <a id="interpretedTextWithRoleSuffix:Parser[InterpretedText]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">interpretedTextWithRoleSuffix</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.parse.rst.Elements.InterpretedText" class="extype" href="Elements$$InterpretedText.html">InterpretedText</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an interpreted text element with the role name as a suffix.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an interpreted text element with the role name as a suffix.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#ipLiteral" data-isabs="false">
      <a id="ipLiteral:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipLiteral</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an ip literal as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an ip literal as defined in RFC 3986.</p><pre>
 IP-literal = <span class="lit">"["</span> ( IPv6address / IPvFuture  ) <span class="lit">"]"</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#ipv4address" data-isabs="false">
      <a id="ipv4address:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipv4address</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an IPv4 address as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an IPv4 address as defined in RFC 3986.</p><pre>
 IPv4address   = dec-octet <span class="lit">"."</span> dec-octet <span class="lit">"."</span> dec-octet <span class="lit">"."</span> dec-octet

 dec-octet     = DIGIT                 ; <span class="num">0</span>-<span class="num">9</span>
               / %x31-<span class="num">39</span> DIGIT         ; <span class="num">10</span>-<span class="num">99</span>
               / <span class="lit">"1"</span> <span class="num">2</span>DIGIT            ; <span class="num">100</span>-<span class="num">199</span>
               / <span class="lit">"2"</span> %x30-<span class="num">34</span> DIGIT     ; <span class="num">200</span>-<span class="num">249</span>
               / <span class="lit">"25"</span> %x30-<span class="num">35</span>          ; <span class="num">250</span>-<span class="num">255</span>
</pre><p> The implementation has been simplified to parse a 3-digit number and
 check its value.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#ipv6address" data-isabs="false">
      <a id="ipv6address:Parser[~[Product, Serializable]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipv6address</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.util.parsing.combinator.Parsers.~" class="extype">~</span>[<span name="scala.Product" class="extype">Product</span>, <span name="java.io.Serializable" class="extype">Serializable</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an IPv6 address as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an IPv6 address as defined in RFC 3986.</p><pre>
 IPv6address  =                            <span class="num">6</span>( h16 <span class="lit">":"</span> ) ls32
              /                       <span class="lit">"::"</span> <span class="num">5</span>( h16 <span class="lit">":"</span> ) ls32
              / [               h16 ] <span class="lit">"::"</span> <span class="num">4</span>( h16 <span class="lit">":"</span> ) ls32
              / [ *<span class="num">1</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span> <span class="num">3</span>( h16 <span class="lit">":"</span> ) ls32
              / [ *<span class="num">2</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span> <span class="num">2</span>( h16 <span class="lit">":"</span> ) ls32
              / [ *<span class="num">3</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>    h16 <span class="lit">":"</span>   ls32
              / [ *<span class="num">4</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>              ls32
              / [ *<span class="num">5</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>              h16
              / [ *<span class="num">6</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>

 h16          = <span class="num">1</span>*<span class="num">4</span>HEXDIG

 ls32         = ( h16 <span class="lit">":"</span> h16 ) / IPv4address
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#ipvFuture" data-isabs="false">
      <a id="ipvFuture:Parser[~[~[~[Elem, String], Elem], List[Any]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipvFuture</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.util.parsing.combinator.Parsers.~" class="extype">~</span>[<span name="scala.util.parsing.combinator.Parsers.~" class="extype">~</span>[<span name="scala.util.parsing.combinator.Parsers.~" class="extype">~</span>[Elem, String], Elem], List[<span name="scala.Any" class="extype">Any</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a future IP address as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a future IP address as defined in RFC 3986.</p><pre>
 IPvFuture = <span class="lit">"v"</span> <span class="num">1</span>*HEXDIG <span class="lit">"."</span> <span class="num">1</span>*( unreserved / sub-delims / <span class="lit">":"</span> )
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#lastNoSuccess" data-isabs="false">
      <a id="lastNoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">var</span>
      </span>
      <span class="symbol">
        <span class="name">lastNoSuccess</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.NoSuccess" class="extype">NoSuccess</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#literal" data-isabs="false">
      <a id="literal(String):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="s">s: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#localPart" data-isabs="false">
      <a id="localPart:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">localPart</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the local part of an email address (before the @), with one
 deviation from RFC 6068: a quoted string is not allowed.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the local part of an email address (before the @), with one
 deviation from RFC 6068: a quoted string is not allowed. It is rarely
 used, not supported by the reStructuredText reference parser and would
 be hard to combine within text markup as it allows for whitespace and
 line break characters.</p><pre>
 local-part = dot-atom-text / quoted-string ; quoted-string omitted
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#log" data-isabs="false">
      <a id="log[T](⇒ Parser[T])(String):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">log</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="params">(<span name="name">name: String</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#lookBehind" data-isabs="false">
      <a id="lookBehind[T](Int,⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookBehind</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span name="scala.Int" class="extype">Int</span></span>, <span name="parser">parser: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#markupEnd" data-isabs="false">
      <a id="markupEnd(Parser[String]):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">markupEnd</span><span class="params">(<span name="end">end: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the end of an inline element  according to reStructuredText markup recognition rules.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the end of an inline element  according to reStructuredText markup recognition rules.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules</a>.
</p></div><dl class="paramcmts block"><dt class="param">end</dt><dd class="cmt"><p>the parser that recognizes the markup at the end of an inline element</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that produces the same result as the parser passed as an argument
</p></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#markupStart" data-isabs="false">
      <a id="markupStart(Parser[String]):Parser[Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">markupStart</span><span class="params">(<span name="end">end: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the start of an inline element without specific start markup
 according to reStructuredText markup recognition rules.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the start of an inline element without specific start markup
 according to reStructuredText markup recognition rules.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules</a>.
</p></div><dl class="paramcmts block"><dt class="param">end</dt><dd class="cmt"><p>the parser that recognizes the markup at the end of an inline element, needed to verify
 the start sequence is not immediately followed by an end sequence as empty elements are not allowed.</p></dd><dt>returns</dt><dd class="cmt"><p>a parser without a useful result, as it is only needed to verify it succeeds
</p></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#markupStart" data-isabs="false">
      <a id="markupStart(Parser[Any],Parser[String]):Parser[Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">markupStart</span><span class="params">(<span name="start">start: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>, <span name="end">end: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the markup at the start of an inline element according to reStructuredText markup recognition rules.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the markup at the start of an inline element according to reStructuredText markup recognition rules.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules</a>.
</p></div><dl class="paramcmts block"><dt class="param">start</dt><dd class="cmt"><p>the parser that recognizes the markup at the start of an inline element</p></dd><dt class="param">end</dt><dd class="cmt"><p>the parser that recognizes the markup at the end of an inline element, needed to verify
 the start sequence is not immediately followed by an end sequence as empty elements are not allowed.</p></dd><dt>returns</dt><dd class="cmt"><p>a parser without a useful result, as it is only needed to verify it succeeds
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#mkList" data-isabs="false">
      <a id="mkList[T]:(~[T, List[T]]) ⇒ List[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkList</span><span class="tparams">[<span name="T">T</span>]</span><span class="result">: (<span name="scala.util.parsing.combinator.Parsers.~" class="extype">~</span>[T, List[T]]) ⇒ <span name="scala.collection.immutable.List" class="extype">List</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#not" data-isabs="false">
      <a id="not[T](⇒ Parser[T]):Parser[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Unit" class="extype">Unit</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#opt" data-isabs="false">
      <a id="opt[T](⇒ Parser[T]):Parser[Option[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Option" class="extype">Option</span>[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="prt" name="laika.parse.MarkupParsers#optimizedCharLookup" data-isabs="false">
      <a id="optimizedCharLookup(Char*):(Char) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedCharLookup</span><span class="params">(<span name="chars">chars: <span name="scala.Char" class="extype">Char</span>*</span>)</span><span class="result">: (<span name="scala.Char" class="extype">Char</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="prt" name="laika.parse.MarkupParsers#optimizedRangeLookup" data-isabs="false">
      <a id="optimizedRangeLookup(Traversable[Char]*):(Char) ⇒ Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedRangeLookup</span><span class="params">(<span name="ranges">ranges: Traversable[<span name="scala.Char" class="extype">Char</span>]*</span>)</span><span class="result">: (<span name="scala.Char" class="extype">Char</span>) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified ranges of characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified ranges of characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#pChar" data-isabs="false">
      <a id="pChar:Parser[Serializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">pChar</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="java.io.Serializable" class="extype">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses one path character as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses one path character as defined in RFC 3986.</p><pre>
 pchar = unreserved / pct-encoded / sub-delims / <span class="lit">":"</span> / <span class="lit">"@"</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parse" data-isabs="false">
      <a id="parse[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.io.Reader" class="extype">Reader</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parse" data-isabs="false">
      <a id="parse[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parse" data-isabs="false">
      <a id="parse[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parseAll" data-isabs="false">
      <a id="parseAll[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parseAll" data-isabs="false">
      <a id="parseAll[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="java.io.Reader" class="extype">Reader</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#parseAll" data-isabs="false">
      <a id="parseAll[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="in">in: <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.ParseResult" class="extype">ParseResult</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#parseInline" data-isabs="false">
      <a id="parseInline(String,Map[Char, Parser[Span]]):List[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseInline</span><span class="params">(<span name="source">source: String</span>, <span name="spanParsers">spanParsers: Map[<span name="scala.Char" class="extype">Char</span>, <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]]</span>)</span><span class="result">: List[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input string and produces a list of spans.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input string and produces a list of spans.</p><p> This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>the input to parse</p></dd><dt class="param">spanParsers</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser</p></dd><dt>returns</dt><dd class="cmt"><p>the result of the parser in form of a list of spans
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.rst.InlineParsers" class="extype" href="">InlineParsers</a> → <a name="laika.parse.InlineParsers" class="extype" href="../InlineParsers.html">InlineParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#parseInline" data-isabs="false">
      <a id="parseInline(String):List[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseInline</span><span class="params">(<span name="source">source: String</span>)</span><span class="result">: List[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all inline elements of the specified source string.</p>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#parseMarkup" data-isabs="false">
      <a id="parseMarkup[T](Parser[T],Reader[Char]):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="reader">reader: <span name="scala.util.parsing.input.Reader" class="extype">Reader</span>[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input from the specified reader and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input from the specified reader and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#parseMarkup" data-isabs="false">
      <a id="parseMarkup[T](Parser[T],String):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="source">source: String</span>)</span><span class="result">: T</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the specified input string and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the specified input string and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#path" data-isabs="false">
      <a id="path:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">path</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the path of a URI as defined in RFC 3986, but only the path
 variant following an authority component.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the path of a URI as defined in RFC 3986, but only the path
 variant following an authority component.</p><pre>
 path-abempty  = *( <span class="lit">"/"</span> segment )

 segment       = *pchar
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#pctEncoded" data-isabs="false">
      <a id="pctEncoded:Parser[~[Elem, String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">pctEncoded</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.util.parsing.combinator.Parsers.~" class="extype">~</span>[Elem, String]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a percent-encoded character as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a percent-encoded character as defined in RFC 3986.</p><pre>
 pct-encoded = <span class="lit">"%"</span> HEXDIG HEXDIG
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#phrase" data-isabs="false">
      <a id="phrase[T](Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">phrase</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#phraseLinkRef" data-isabs="false">
      <a id="phraseLinkRef:Parser[laika.tree.Elements.SpanContainer[_ &gt;: laika.tree.Elements.SpanSequence with laika.tree.Elements.ExternalLink with laika.tree.Elements.LinkReference &lt;: laika.tree.Elements.SpanContainer[_ &gt;: laika.tree.Elements.SpanSequence with laika.tree.Elements.ExternalLink with laika.tree.Elements.LinkReference &lt;: laika.tree.Elements.SpanContainer[_ &gt;: laika.tree.Elements.SpanSequence with laika.tree.Elements.ExternalLink with laika.tree.Elements.LinkReference &lt;: laika.tree.Elements.Span with laika.tree.Elements.Container[Seq[laika.tree.Elements.Span]] with Serializable] with laika.tree.Elements.Span with Serializable] with laika.tree.Elements.Span with Serializable] with Span with Serializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">phraseLinkRef</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[laika.tree.Elements.SpanContainer[_ &gt;: laika.tree.Elements.SpanSequence with laika.tree.Elements.ExternalLink with laika.tree.Elements.LinkReference &lt;: laika.tree.Elements.SpanContainer[_ &gt;: laika.tree.Elements.SpanSequence with laika.tree.Elements.ExternalLink with laika.tree.Elements.LinkReference &lt;: laika.tree.Elements.SpanContainer[_ &gt;: laika.tree.Elements.SpanSequence with laika.tree.Elements.ExternalLink with laika.tree.Elements.LinkReference &lt;: laika.tree.Elements.Span with laika.tree.Elements.Container[Seq[laika.tree.Elements.Span]] with Serializable] with laika.tree.Elements.Span with Serializable] with laika.tree.Elements.Span with Serializable] with <a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a> with <span name="scala.Serializable" class="extype">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a phrase link reference (enclosed in back ticks).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a phrase link reference (enclosed in back ticks).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#phraseRef" data-isabs="false">
      <a id="phraseRef:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">phraseRef</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a phrase reference name enclosed in back ticks.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a phrase reference name enclosed in back ticks.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#port" data-isabs="false">
      <a id="port:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">port</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a port as defined in RFC 3986, except for requiring at least one digit;
 instead the port is defined as optional in a higher level combinator.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a port as defined in RFC 3986, except for requiring at least one digit;
 instead the port is defined as optional in a higher level combinator.</p><pre>
 port = *DIGIT
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#positioned" data-isabs="false">
      <a id="positioned[T&lt;:Positional](⇒ Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">positioned</span><span class="tparams">[<span name="T">T &lt;: <span name="scala.util.parsing.input.Positional" class="extype">Positional</span></span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#query" data-isabs="false">
      <a id="query:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">query</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the query part of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the query part of a URI as defined in RFC 3986.</p><pre>
 query = *( pchar / <span class="lit">"/"</span> / <span class="lit">"?"</span> )
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#refName" data-isabs="false">
      <a id="refName:Parser[ReferenceName]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">refName</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.parse.rst.InlineParsers.ReferenceName" class="extype" href="InlineParsers$ReferenceName.html">ReferenceName</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a reference name, either a simple or a phrase reference name.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a reference name, either a simple or a phrase reference name.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#regName" data-isabs="false">
      <a id="regName:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">regName</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a server name as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a server name as defined in RFC 3986.</p><pre>
 reg-name = *( unreserved / pct-encoded / sub-delims )
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.RegexParsers#regex" data-isabs="false">
      <a id="regex(Regex):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">regex</span><span class="params">(<span name="r">r: <span name="scala.util.matching.Regex" class="extype">Regex</span></span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep" data-isabs="false">
      <a id="rep[T](⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep1" data-isabs="false">
      <a id="rep1[T](⇒ Parser[T],⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="first">first: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="p0">p0: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> The <code>p0</code> call-by-name arguments is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.</p></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep1" data-isabs="false">
      <a id="rep1[T](⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#rep1sep" data-isabs="false">
      <a id="rep1sep[T](⇒ Parser[T],⇒ Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1sep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#repMax" data-isabs="false">
      <a id="repMax[T](Int,⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMax</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span name="scala.Int" class="extype">Int</span></span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at most the specified number of repetitions, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at most the specified number of repetitions, always succeeds.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#repMin" data-isabs="false">
      <a id="repMin[T](Int,⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMin</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span name="scala.Int" class="extype">Int</span></span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at least the specified number of repetitions or otherwise fails.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at least the specified number of repetitions or otherwise fails.
 Continues to apply the parser after the minimum has been reached until if fails.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#repN" data-isabs="false">
      <a id="repN[T](Int,⇒ Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repN</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span name="scala.Int" class="extype">Int</span></span>, <span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#repsep" data-isabs="false">
      <a id="repsep[T](⇒ Parser[T],⇒ Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repsep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>, <span name="q">q: ⇒ <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="scala.Any" class="extype">Any</span>]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[T]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#simpleLinkRef" data-isabs="false">
      <a id="simpleLinkRef:Parser[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">simpleLinkRef</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a simple link reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a simple link reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#simpleRefName" data-isabs="false">
      <a id="simpleRefName:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">simpleRefName</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<span name="java.lang.String" class="extype">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a simple reference name that only allows alphanumerical characters
 and the punctuation characters <code>-</code>, <code>_</code>, <code>.</code>, <code>:</code>, <code>+</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a simple reference name that only allows alphanumerical characters
 and the punctuation characters <code>-</code>, <code>_</code>, <code>.</code>, <code>:</code>, <code>+</code>.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names</a>.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#skipWhitespace" data-isabs="false">
      <a id="skipWhitespace:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">skipWhitespace</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a> → RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#spanParsers" data-isabs="false">
      <a id="spanParsers:Map[Char, Parser[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">spanParsers</span><span class="result">: <span name="scala.collection.immutable.Map" class="extype">Map</span>[<span name="scala.Char" class="extype">Char</span>, <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A mapping of the start character of an inline element to the corresponding parser.</p><div class="fullcomment"><div class="comment cmt"><p>A mapping of the start character of an inline element to the corresponding parser.
 The mapping is used to provide a fast implementation of an inline parser that
 only stops at known special characters.
</p></div></div>
    </li><li visbl="pub" name="laika.parse.InlineParsers#spans" data-isabs="false">
      <a id="spans(⇒ TextParser,⇒ Map[Char, Parser[Span]]):Parser[List[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">spans</span><span class="params">(<span name="parser">parser: ⇒ <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>, <span name="spanParsers">spanParsers: ⇒ Map[<span name="scala.Char" class="extype">Char</span>, <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[List[<a name="laika.tree.Elements.Span" class="extype" href="../../tree/Elements$$Span.html">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a list of spans based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a list of spans based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for the text of the current span element</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.InlineParsers" class="extype" href="../InlineParsers.html">InlineParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#strong" data-isabs="false">
      <a id="strong:Parser[Strong]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">strong</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Strong" class="extype" href="../../tree/Elements$$Strong.html">Strong</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a span of text with strong emphasis.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a span of text with strong emphasis.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#strong-emphasis">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#strong-emphasis</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#subDelims" data-isabs="false">
      <a id="subDelims:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">subDelims</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single sub-delimiter as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single sub-delimiter as defined in RFC 3986.</p><pre>
 sub-delims = <span class="lit">"!"</span> / <span class="lit">"$"</span> / <span class="lit">"&"</span> / <span class="lit">"'"</span> / <span class="lit">"("</span> / <span class="lit">")"</span>
                  / <span class="lit">"*"</span> / <span class="lit">"+"</span> / <span class="lit">","</span> / <span class="lit">";"</span> / <span class="lit">"="</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#substitutionRef" data-isabs="false">
      <a id="substitutionRef:Parser[Reference with Serializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">substitutionRef</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[<a name="laika.tree.Elements.Reference" class="extype" href="../../tree/Elements$$Reference.html">Reference</a> with <span name="scala.Serializable" class="extype">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a substitution reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a substitution reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-references">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-references</a>.
</p></div></div>
    </li><li visbl="pub" name="scala.util.parsing.combinator.Parsers#success" data-isabs="false">
      <a id="success[T](T):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: T</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[T]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.InlineParsers#text" data-isabs="false">
      <a id="text(⇒ TextParser,⇒ Map[Char, Parser[String]]):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">text</span><span class="params">(<span name="parser">parser: ⇒ <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>, <span name="nested">nested: ⇒ Map[<span name="scala.Char" class="extype">Char</span>, <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]]</span>)</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses text based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses text based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for the text of the current element</p></dd><dt class="param">nested</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser for nested span elements</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.InlineParsers" class="extype" href="../InlineParsers.html">InlineParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#to" data-isabs="false">
      <a id="to:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">to</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a sequence of email addresses as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a sequence of email addresses as defined in RFC 6068.</p><pre>
 to = addr-spec *(<span class="lit">","</span> addr-spec )
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#toParserOps" data-isabs="false">
      <a id="toParserOps[A](Parser[A]):ParserOps[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toParserOps</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="parser">parser: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[A]</span>)</span><span class="result">: <a name="laika.parse.MarkupParsers.ParserOps" class="extype" href="../MarkupParsers$ParserOps.html">ParserOps</a>[A]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#unreserved" data-isabs="false">
      <a id="unreserved:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">unreserved</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single unreserved character as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single unreserved character as defined in RFC 3986.</p><pre>
 sub-delims = <span class="lit">"!"</span> / <span class="lit">"$"</span> / <span class="lit">"&"</span> / <span class="lit">"'"</span> / <span class="lit">"("</span> / <span class="lit">")"</span>
                  / <span class="lit">"*"</span> / <span class="lit">"+"</span> / <span class="lit">","</span> / <span class="lit">";"</span> / <span class="lit">"="</span>
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="laika.parse.rst.InlineParsers#uri" data-isabs="false">
      <a id="uri:Parser[(String, String, String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">uri</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[(String, <span name="java.lang.String" class="extype">String</span>, String)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a standalone HTTP or HTTPS hyperlink (with no surrounding markup).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a standalone HTTP or HTTPS hyperlink (with no surrounding markup).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks</a>
</p></div></div>
    </li><li visbl="pub" name="laika.parse.util.URIParsers#userInfo" data-isabs="false">
      <a id="userInfo:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">userInfo</span><span class="result">: <span name="scala.util.parsing.combinator.Parsers.Parser" class="extype">Parser</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the user info portion of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the user info portion of a URI as defined in RFC 3986.</p><pre>
 userinfo = *( unreserved / pct-encoded / sub-delims / <span class="lit">":"</span> )
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="prt" name="scala.util.parsing.combinator.RegexParsers#whiteSpace" data-isabs="false">
      <a id="whiteSpace:Regex"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">whiteSpace</span><span class="result">: <span name="scala.util.matching.Regex" class="extype">Regex</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li visbl="pub" name="laika.parse.MarkupParsers#ws" data-isabs="false">
      <a id="ws:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ws</span><span class="result">: <a name="laika.parse.MarkupParsers.TextParser" class="extype" href="../MarkupParsers$TextParser.html">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses horizontal whitespace (space and tab).</p><div class="fullcomment"><div class="comment cmt"><p>Parses horizontal whitespace (space and tab).
 Always succeeds, consuming all whitespace found.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></dd></dl></div>
    </li></ol>
            </div>

        
        </div>

        <div id="inheritedMembers">
        <div name="laika.parse.util.URIParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.util.URIParsers" class="extype" href="../util/URIParsers.html">URIParsers</a></h3>
            </div><div name="laika.parse.InlineParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.InlineParsers" class="extype" href="../InlineParsers.html">InlineParsers</a></h3>
            </div><div name="laika.parse.MarkupParsers" class="parent">
              <h3>Inherited from <a name="laika.parse.MarkupParsers" class="extype" href="../MarkupParsers.html">MarkupParsers</a></h3>
            </div><div name="scala.util.parsing.combinator.RegexParsers" class="parent">
              <h3>Inherited from <span name="scala.util.parsing.combinator.RegexParsers" class="extype">RegexParsers</span></h3>
            </div><div name="scala.util.parsing.combinator.Parsers" class="parent">
              <h3>Inherited from <span name="scala.util.parsing.combinator.Parsers" class="extype">Parsers</span></h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>