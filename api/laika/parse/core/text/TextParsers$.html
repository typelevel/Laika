<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../../index.js"></script>
      <script type="text/javascript" src="../../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="index.html#laika" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../laika/index.html#parse" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.core" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="core"></a><a id="core:core"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html#core" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">core</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.core.text" visbl="pub" class="indented4 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text"></a><a id="text:text"></a>
      <span class="permalink">
      <a href="../../../laika/parse/core/index.html#text" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">text</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse.core">core</a></dd></dl></div>
    </li><li class="current-entities indented4">
                        <a class="object" href="Characters$.html" title="Companion with factory methods for creating optimized character parsers."></a>
                        <a class="class" href="Characters.html" title="Optimized parser for character input."></a>
                        <a href="Characters.html" title="Optimized parser for character input.">Characters</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="ConfigurableDelimiter.html" title="Delimiter implementation that allows for various kinds of customization."></a>
                        <a href="ConfigurableDelimiter.html" title="Delimiter implementation that allows for various kinds of customization.">ConfigurableDelimiter</a>
                      </li><li class="current-entities indented4">
                        <a class="object" href="DelimitedText$.html" title=""></a>
                        <a class="class" href="DelimitedText.html" title="A parser for text that ends with a specific delimiter condition, either marking the end of the text span or the start of an embedded inner span."></a>
                        <a href="DelimitedText.html" title="A parser for text that ends with a specific delimiter condition, either marking the end of the text span or the start of an embedded inner span.">DelimitedText</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="trait" href="Delimiter.html" title="Represents the logic of a specific kind of text delimiter."></a>
                        <a href="Delimiter.html" title="Represents the logic of a specific kind of text delimiter.">Delimiter</a>
                      </li><li class="current-entities indented4">
                        <a class="object" href="DelimiterOptions$.html" title=""></a>
                        <a class="trait" href="DelimiterOptions.html" title="API for customizing a delimiter."></a>
                        <a href="DelimiterOptions.html" title="API for customizing a delimiter.">DelimiterOptions</a>
                      </li><li class="current-entities indented4">
                        <a class="object" href="DelimiterResult$.html" title=""></a>
                        <a class="trait" href="DelimiterResult.html" title="Represents the result of parsing a delimiter."></a>
                        <a href="DelimiterResult.html" title="Represents the result of parsing a delimiter.">DelimiterResult</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Literal.html" title="A parser that matches a literal string."></a>
                        <a href="Literal.html" title="A parser that matches a literal string.">Literal</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="object" href="" title="Base text parsers that provide optimized low-level parsers for typical requirements of text markup parsers."></a>
                        <a href="" title="Base text parsers that provide optimized low-level parsers for typical requirements of text markup parsers.">TextParsers</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="object value">
      <div id="definition">
        <div class="big-circle object">o</div>
        <p id="owner"><a href="../../../index.html" class="extype" name="laika">laika</a>.<a href="../../index.html" class="extype" name="laika.parse">parse</a>.<a href="../index.html" class="extype" name="laika.parse.core">core</a>.<a href="index.html" class="extype" name="laika.parse.core.text">text</a></p>
        <h1>TextParsers<span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">TextParsers</span><span class="result"> extends <a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Base text parsers that provide optimized low-level parsers for typical requirements
 of text markup parsers. In particular they are meant as an efficient replacement
 for scenarios where usually regex parsers are used. In cases where different parsers
 need to be tried for relatively short input sequences, regex parsers tend to be less
 efficient. Furthermore, these base parsers may also improve readability, as it
 allows to combine simple low-level parsers to higher-level parsers based on the
 Laika combinator API, instead of producing long regexes which may be hard to read.
</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="laika.parse.core.text.TextParsers"><span>TextParsers</span></li><li class="in" name="laika.parse.core.combinator.Parsers"><span>Parsers</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="laika.parse.core.combinator.Parsers.ParserException" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ParserExceptionextendsRuntimeExceptionwithProductwithSerializable"></a><a id="ParserException:ParserException"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/combinator/Parsers.html#ParserExceptionextendsRuntimeExceptionwithProductwithSerializable" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="" href="../combinator/Parsers$ParserException.html"><span class="name">ParserException</span></a><span class="params">(<span name="result">result: <a href="../Failure.html" class="extype" name="laika.parse.core.Failure">Failure</a></span>)</span><span class="result"> extends <span class="extype" name="scala.RuntimeException">RuntimeException</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers.TryOps" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TryOps[A]extendsAnyRef"></a><a id="TryOps[A]:TryOps[A]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/combinator/Parsers.html#TryOps[A]extendsAnyRef" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides additional methods to Try via implicit conversion." href="../combinator/Parsers$TryOps.html"><span class="name">TryOps</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides additional methods to <code>Try</code> via implicit conversion.</p><div class="fullcomment"><div class="comment cmt"><p>Provides additional methods to <code>Try</code> via implicit conversion.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.core.text.TextParsers#any" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="any:laika.parse.core.text.Characters[String]"></a><a id="any:Characters[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#any:laika.parse.core.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">any</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.core.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any kind of input, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any kind of input, always succeeds.
 This parser would consume the entire input unless a <code>max</code> constraint
 is specified.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#anyBut" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyBut(chars:Char*):laika.parse.core.text.Characters[String]"></a><a id="anyBut(Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#anyBut(chars:Char*):laika.parse.core.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyBut</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.core.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#anyIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyIn(ranges:Traversable[Char]*):laika.parse.core.text.Characters[String]"></a><a id="anyIn(Traversable[Char]*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#anyIn(ranges:Traversable[Char]*):laika.parse.core.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyIn</span><span class="params">(<span name="ranges">ranges: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]*</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.core.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are in one of the specified character ranges.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are in one of the specified character ranges.
 Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#anyOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(chars:Char*):laika.parse.core.text.Characters[String]"></a><a id="anyOf(Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#anyOf(chars:Char*):laika.parse.core.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.core.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#anyWhile" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyWhile(p:Char=&gt;Boolean):laika.parse.core.text.Characters[String]"></a><a id="anyWhile((Char)⇒Boolean):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#anyWhile(p:Char=&gt;Boolean):laika.parse.core.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.core.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters which satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters which satisfy the specified predicate.
 Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.core.text.TextParsers#atStart" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="atStart:laika.parse.core.Parser[Unit]"></a><a id="atStart:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#atStart:laika.parse.core.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">atStart</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the start of the input.</p>
    </li><li name="laika.parse.core.text.TextParsers#blankLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blankLine:laika.parse.core.Parser[String]"></a><a id="blankLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#blankLine:laika.parse.core.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLine</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a blank line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a blank line from the current input offset (which may not be at the
 start of the line). Fails for lines that contain any non-whitespace character.
 Does always produce an empty string as the result, discarding any whitespace
 characters found in the line.</p><p> Since it also succeeds at the end of the input
 it should never be used in the form of <code>(blankLine *)</code> or <code>(blankLine +)</code>. Use
 the <code>blankLines</code> parser instead in these cases.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#blankLines" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="blankLines:laika.parse.core.Parser[List[String]]"></a><a id="blankLines:Parser[List[String]]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#blankLines:laika.parse.core.Parser[List[String]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLines</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Parses one or more blanklines, producing a list of empty strings corresponding
 to the number of blank lines consumed.</p>
    </li><li name="laika.parse.core.text.TextParsers#char" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="char(expected:Char):laika.parse.core.Parser[Char]"></a><a id="char(Char):Parser[Char]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#char(expected:Char):laika.parse.core.Parser[Char]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">char</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> A parser that matches only the specified character.</p><div class="fullcomment"><div class="comment cmt"><p> A parser that matches only the specified character.</p><p> The method is implicit so that characters can automatically be lifted to their parsers.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#charToTraversable" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="charToTraversable(char:Char):Traversable[Char]"></a><a id="charToTraversable(Char):Traversable[Char]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#charToTraversable(char:Char):Traversable[Char]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">charToTraversable</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.</p>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers#consumeAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="consumeAll[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[T]"></a><a id="consumeAll[T](Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#consumeAll[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">consumeAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.consumeAll.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.consumeAll.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that succeeds if the specified parser succeeds and all input has been consumed.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that succeeds if the specified parser succeeds and all input has been consumed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.core.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimitedBy(str:String,postCondition:laika.parse.core.Parser[Any]):laika.parse.core.text.DelimitedText[String]withlaika.parse.core.text.DelimiterOptions"></a><a id="delimitedBy(String,Parser[Any]):DelimitedText[String]withDelimiterOptions"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#delimitedBy(str:String,postCondition:laika.parse.core.Parser[Any]):laika.parse.core.text.DelimitedText[String]withlaika.parse.core.text.DelimiterOptions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="str">str: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="postCondition">postCondition: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="DelimitedText.html" class="extype" name="laika.parse.core.text.DelimitedText">DelimitedText</a>[<span class="extype" name="scala.Predef.String">String</span>] with <a href="DelimiterOptions.html" class="extype" name="laika.parse.core.text.DelimiterOptions">DelimiterOptions</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until the specified string delimiter
is encountered on the input string.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters until the specified string delimiter
is encountered on the input string.</p><p>Only succeeds if the specified <code>postCondition</code> parser succeeds at the offset after
the consumed delimiter string.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delimitedBy(str:String):laika.parse.core.text.DelimitedText[String]withlaika.parse.core.text.DelimiterOptions"></a><a id="delimitedBy(String):DelimitedText[String]withDelimiterOptions"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#delimitedBy(str:String):laika.parse.core.text.DelimitedText[String]withlaika.parse.core.text.DelimiterOptions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="str">str: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="DelimitedText.html" class="extype" name="laika.parse.core.text.DelimitedText">DelimitedText</a>[<span class="extype" name="scala.Predef.String">String</span>] with <a href="DelimiterOptions.html" class="extype" name="laika.parse.core.text.DelimiterOptions">DelimiterOptions</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until the specified string delimiter
is encountered on the input string.</p>
    </li><li name="laika.parse.core.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delimitedBy(chars:Char*):laika.parse.core.text.DelimitedText[String]withlaika.parse.core.text.DelimiterOptions"></a><a id="delimitedBy(Char*):DelimitedText[String]withDelimiterOptions"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#delimitedBy(chars:Char*):laika.parse.core.text.DelimitedText[String]withlaika.parse.core.text.DelimiterOptions" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="DelimitedText.html" class="extype" name="laika.parse.core.text.DelimitedText">DelimitedText</a>[<span class="extype" name="scala.Predef.String">String</span>] with <a href="DelimiterOptions.html" class="extype" name="laika.parse.core.text.DelimiterOptions">DelimiterOptions</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until one of the specified characters
is encountered on the input string.</p>
    </li><li name="laika.parse.core.text.TextParsers#eof" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="eof:laika.parse.core.Parser[String]"></a><a id="eof:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#eof:laika.parse.core.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">eof</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the end of the input.</p>
    </li><li name="laika.parse.core.text.TextParsers#eol" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eol:laika.parse.core.Parser[Unit]"></a><a id="eol:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#eol:laika.parse.core.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">eol</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the end of a line, including the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of a line, including the end of the input.
 Produces an empty string as a result and consumes any new line characters.
</p></div></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers#failure" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="failure(msg:String):laika.parse.core.Parser[Nothing]"></a><a id="failure(String):Parser[Nothing]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#failure(msg:String):laika.parse.core.Parser[Nothing]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that always fails with the specified message.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that always fails with the specified message.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.core.text.TextParsers#literal" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="literal(expected:String):laika.parse.core.Parser[String]"></a><a id="literal(String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#literal(expected:String):laika.parse.core.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> A parser that matches only the specified literal string.</p><div class="fullcomment"><div class="comment cmt"><p> A parser that matches only the specified literal string.</p><p> The method is implicit so that strings can automatically be lifted to their parsers.
</p></div></div>
    </li><li name="laika.parse.core.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead[T](offset:Int,p:laika.parse.core.Parser[T]):laika.parse.core.Parser[T]"></a><a id="lookAhead[T](Int,Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#lookAhead[T](offset:Int,p:laika.parse.core.Parser[T]):laika.parse.core.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.lookAhead.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.lookAhead.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[T]"></a><a id="lookAhead[T](Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#lookAhead[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.lookAhead.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.lookAhead.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser at the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser at the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers#lookBehind" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookBehind[T](offset:Int,parser:=&gt;laika.parse.core.Parser[T]):laika.parse.core.Parser[T]"></a><a id="lookBehind[T](Int,⇒Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#lookBehind[T](offset:Int,parser:=&gt;laika.parse.core.Parser[T]):laika.parse.core.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookBehind</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="parser">parser: ⇒ <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.lookBehind.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.lookBehind.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers#not" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="not[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[Unit]"></a><a id="not[T](Parser[T]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#not[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.not.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that only succeeds if the specified parser fails and
 vice versa, it never consumes any input.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that only succeeds if the specified parser fails and
 vice versa, it never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers#opt" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[Option[T]]"></a><a id="opt[T](Parser[T]):Parser[Option[T]]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#opt[T](p:laika.parse.core.Parser[T]):laika.parse.core.Parser[Option[T]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.opt.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.core.combinator.Parsers.opt.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">A parser for an optional element that always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>A parser for an optional element that always succeeds.</p><p>If the underlying parser succeeds this parser will contain its result as a <code>Some</code>,
if it fails this parser will succeed with a <code>None</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.core.text.TextParsers#refName" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="refName:laika.parse.core.Parser[String]"></a><a id="refName:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#refName:laika.parse.core.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">refName</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a simple reference name that only allows alphanumerical characters
 and the punctuation characters <code>-</code>, <code>_</code>, <code>.</code>, <code>:</code>, <code>+</code>.</p>
    </li><li name="laika.parse.core.text.TextParsers#restOfLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restOfLine:laika.parse.core.Parser[String]"></a><a id="restOfLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#restOfLine:laika.parse.core.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">restOfLine</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text. Does not include the eol character(s).
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#sizeAndUnit" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sizeAndUnit:laika.parse.core.Parser[laika.tree.Elements.Size]"></a><a id="sizeAndUnit:Parser[Size]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#sizeAndUnit:laika.parse.core.Parser[laika.tree.Elements.Size]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">sizeAndUnit</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<a href="../../../tree/Elements$$Size.html" class="extype" name="laika.tree.Elements.Size">Size</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a size and its amount, e.g.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a size and its amount, e.g. 12px.
The unit is mandatory and not validated.
</p></div></div>
    </li><li name="laika.parse.core.combinator.Parsers#success" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="success[T](v:T):laika.parse.core.Parser[T]"></a><a id="success[T](T):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#success[T](v:T):laika.parse.core.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: <span class="extype" name="laika.parse.core.combinator.Parsers.success.T">T</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.success.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that always succeeds with the specified value.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that always succeeds with the specified value.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.core.text.TextParsers#textLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="textLine:laika.parse.core.Parser[String]"></a><a id="textLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#textLine:laika.parse.core.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">textLine</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a single text line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single text line from the current input offset (which may not be at the
 start of the line). Fails for blank lines. Does not include the eol character(s).
</p></div></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.core.combinator.Parsers#unsafeParserFunction" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsafeParserFunction[T](parser:laika.parse.core.Parser[T]):laika.parse.core.ParserContext=&gt;T"></a><a id="unsafeParserFunction[T](Parser[T]):(ParserContext)⇒T"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#unsafeParserFunction[T](parser:laika.parse.core.Parser[T]):laika.parse.core.ParserContext=&gt;T" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsafeParserFunction</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="laika.parse.core.combinator.Parsers.unsafeParserFunction.T">T</span>]</span>)</span><span class="result">: (<a href="../ParserContext.html" class="extype" name="laika.parse.core.ParserContext">ParserContext</a>) ⇒ <span class="extype" name="laika.parse.core.combinator.Parsers.unsafeParserFunction.T">T</span></span>
      </span>
      
      <p class="shortcomment cmt">A parser function for the specified parser that is expected to consume
all input and always succeed, throwing unexpected parser failures
as exceptions instead.</p><div class="fullcomment"><div class="comment cmt"><p>A parser function for the specified parser that is expected to consume
all input and always succeed, throwing unexpected parser failures
as exceptions instead.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.core.text.TextParsers#ws" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ws:laika.parse.core.text.Characters[String]"></a><a id="ws:Characters[String]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#ws:laika.parse.core.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">ws</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.core.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses horizontal whitespace (space and tab).</p><div class="fullcomment"><div class="comment cmt"><p>Parses horizontal whitespace (space and tab).
Always succeeds, consuming all whitespace found.
</p></div></div>
    </li><li name="laika.parse.core.text.TextParsers#wsEol" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="wsEol:laika.parse.core.Parser[Unit]"></a><a id="wsEol:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../../laika/parse/core/text/TextParsers$.html#wsEol:laika.parse.core.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">wsEol</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.core.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses any number of whitespace characters followed
by a newline character.</p>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="laika.parse.core.combinator.Parsers">
              <h3>Inherited from <a href="../combinator/Parsers.html" class="extype" name="laika.parse.core.combinator.Parsers">Parsers</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
