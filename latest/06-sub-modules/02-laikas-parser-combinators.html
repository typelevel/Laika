<!DOCTYPE html>
<html lang="en">
  
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Typelevel Laika + Helium Theme" />
  <title>Laika's Parser Combinators</title>
  
  
  <meta name="description" content="Site and E-book Generator and Customizable Text Markup Transformer for sbt, Scala and Scala.js"/>
  
  
  
  <link rel="icon" sizes="32x32" type="image/png" href="../../img/site/laika-favicon.png"/>
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  
  <link rel="stylesheet" type="text/css" href="../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../css/manual.css" />
  <script src="../helium/site/laika-helium.js"></script>
    <script src="../helium/site/laika-versions.js"></script>
  <script>initVersions("../../", "/06-sub-modules/02-laikas-parser-combinators.html", "latest", "https://typelevel.org/Laika/");</script>
  
  <script> /* for avoiding page load transitions */ </script>
</head>

  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 1.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="../../olderVersions/">Older Versions</a></li>
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link glyph-link" href="../../"><i class="icofont-laika home" title="Home">&#xef47;</i></a>

  <div class="row links">
    
    <a class="icon-link svg-link" href="https://github.com/typelevel/Laika"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link svg-link" href="https://javadoc.io/doc/org.typelevel/laika-docs_2.12/latest/laika/index.html"><span class="api" title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="../downloads.html"><i class="icofont-laika download" title="Download">&#xef08;</i></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="icon-link svg-link" href="https://github.com/typelevel/Laika"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link svg-link" href="https://javadoc.io/doc/org.typelevel/laika-docs_2.12/latest/laika/index.html"><span class="api" title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="../downloads.html"><i class="icofont-laika download" title="Download">&#xef08;</i></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../table-of-content.html">Table of Content</a></li>
    <li class="level1 nav-leaf"><a href="../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-header">About Laika</li>
    <li class="level2 nav-leaf"><a href="../01-about-laika/01-features.html">Features</a></li>
    <li class="level2 nav-leaf"><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
    <li class="level1 nav-header">Running Laika</li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/01-sbt-plugin.html">sbt Plugin</a></li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/02-library-api.html">Library API</a></li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/03-configuration.html">Configuration</a></li>
    <li class="level1 nav-header">Preparing Content</li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/03-theme-settings.html">Theme Settings</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
    <li class="level1 nav-header">Customizing Laika</li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/01-overview.html">Customizing Laika - Overview</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/03-creating-templates.html">Creating Templates</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/04-document-ast.html">The Document AST</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/05-ast-rewriting.html">AST Rewriting</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/06-overriding-renderers.html">Overriding Renderers</a></li>
    <li class="level1 nav-header">Extending Laika</li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/01-overview.html">Extending Laika - Overview</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/02-creating-themes.html">Creating Themes</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/03-implementing-directives.html">Implementing Directives</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/06-adding-syntax-highlighters.html">Adding Syntax Highlighters</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
    <li class="level1 nav-header">Sub-Modules</li>
    <li class="level2 active nav-leaf"><a href="#">Laika&#39;s Parser Combinators</a></li>
    <li class="level2 nav-leaf"><a href="03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
    <li class="level1 nav-header">Reference</li>
    <li class="level2 nav-leaf"><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Laika&#39;s Parser Combinators</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#the-parser-trait">The Parser Trait</a></li>
    <li class="level1 nav-node"><a href="#parsing-text">Parsing Text</a></li>
    <li class="level2 nav-leaf"><a href="#literal-text">Literal Text</a></li>
    <li class="level2 nav-leaf"><a href="#character-groups">Character Groups</a></li>
    <li class="level2 nav-leaf"><a href="#length-constraints">Length Constraints</a></li>
    <li class="level1 nav-node"><a href="#combinators">Combinators</a></li>
    <li class="level2 nav-leaf"><a href="#concatenation">Concatenation</a></li>
    <li class="level2 nav-leaf"><a href="#alternatives">Alternatives</a></li>
    <li class="level2 nav-leaf"><a href="#repetitions">Repetitions</a></li>
    <li class="level1 nav-leaf"><a href="#producing-results">Producing Results</a></li>
    <li class="level1 nav-leaf"><a href="#delimiters">Delimiters</a></li>
    <li class="level1 nav-leaf"><a href="#parsing-nested-spans">Parsing Nested Spans</a></li>
    <li class="level1 nav-node"><a href="#performance-optimizations">Performance Optimizations</a></li>
    <li class="level2 nav-leaf"><a href="#inline-parsing-challenges">Inline Parsing Challenges</a></li>
    <li class="level2 nav-leaf"><a href="#the-prefixedparser-trait">The PrefixedParser trait</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/typelevel/Laika/tree/main/docs/src/06-sub-modules/02-laikas-parser-combinators.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="laika-s-parser-combinators" class="title">Laika&#39;s Parser Combinators</h1>
        <p>Since the 0.8 release in 2018 Laika comes with its own parser combinator library.</p>
        <p>The decision was based on the goal to find the sweet spot between ease of use, flexibility and performance.
        It&#39;s to a large degree a general purpose parser library for character input, 
        but also has a few aspects tailored for Laika&#39;s main requirements: 
        parsing of text markup which is a multi-pass process and providing a maximum of flexibility for user provided
        extensions of the markup syntax.</p>
        <p>The library is currently part of the <code>laika-core</code> artifact, but has the potential to become a separate micro-lib,
        if some users voice an interest in using it without Laika&#39;s other features.</p>
        
        <h2 id="the-parser-trait" class="section"><a class="anchor-link left" href="#the-parser-trait"><i class="icofont-laika link">&#xef71;</i></a>The Parser Trait</h2>
        <p>A parser instance is invoked at a particular offset into an input and performs the following tasks:</p>
        <p>1) produce a result or fail with a message</p>
        <p>2) optionally consume some of the input</p>
        <p>This is encapsulated in the single abstract method of the <code>Parser</code> trait:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">Parser</span><span>[</span><span class="type-name">T</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">parse</span><span> (</span><span class="identifier">in</span><span>: </span><span class="type-name">SourceCursor</span><span>): </span><span class="type-name">Parsed</span><span>[</span><span class="type-name">T</span><span>]
}</span></code></pre>
        <p>The <code>SourceCursor</code> contains an API for reading from the input at the current offset and for capturing or consuming
        some of the input.</p>
        <p>The returned result of type <code>Parsed[T]</code> is a little ADT with the following types:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Success</span><span>[+</span><span class="type-name">T</span><span>] (</span><span class="identifier">result</span><span>: </span><span class="type-name">T</span><span>, </span><span class="identifier">next</span><span>: </span><span class="type-name">SourceCursor</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Parsed</span><span>[</span><span class="type-name">T</span><span>]

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Failure</span><span> (</span><span class="identifier">msg</span><span>: </span><span class="type-name">Message</span><span>, </span><span class="identifier">next</span><span>: </span><span class="type-name">SourceCursor</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Parsed</span><span>[</span><span class="type-name">Nothing</span><span>]</span></code></pre>
        <p>In case of success the result will be returned alongside a new <code>ParserContext</code> that may have consumed
        some of the input.
        Consuming input is optional as some parsers only look ahead on the input to check a precondition.</p>
        <p>In case of an error the returned value will contain a (lazily constructed) error message 
        and a <code>ParserContext</code> which will usually be at the same offset as the context passed in,
        so that subsequent parsers can try to read from the same location.</p>
        <p>The trait is mostly shown for providing some background about the most basic building block of the combinator library.
        You will rarely create an implementation of <code>Parser</code> yourself as the existing building blocks cover a lot of scenarios
        already.</p>
        
        <h2 id="parsing-text" class="section"><a class="anchor-link left" href="#parsing-text"><i class="icofont-laika link">&#xef71;</i></a>Parsing Text</h2>
        <p>One of the basic building blocks for parsers are the text parsers provided by the library.</p>
        <p>They deliberately do not integrate with or otherwise use regular expressions and prefer a combinator DSL instead.
        While being significantly more verbose, combinators are a more type-safe, composable and also often more legible
        way to define text parsers, in particular with larger, more complex expressions.</p>
        <p>For defining parsers you usually need at least the following imports:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">builders</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">_</span></code></pre>
        <p>When working with character groups this additional import can be used:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">text</span><span>.</span><span class="type-name">CharGroup</span></code></pre>
        <p>The following section demonstrate some of the most commonly used text parsers.
        For the full API see <a class="api" href="https://javadoc.io/doc/org.typelevel/laika-docs_2.12/latest/laika/parse/text/TextParsers$.html">TextParsers</a>.</p>
        
        <h3 id="literal-text" class="section"><a class="anchor-link left" href="#literal-text"><i class="icofont-laika link">&#xef71;</i></a>Literal Text</h3>
        <p>A literal parser only matches on an exactly identical input and is often used for parsing keywords or 
        delimiters consisting of one or more characters.</p>
        <p><code>literal(&quot;class&quot;)</code> for example only matches on the <code>class</code> keyword.</p>
        <p>In many cases declaring the literal parser explicitly can be skipped.
        The imports shown above contain extension methods that allow the use of raw strings 
        where otherwise a <code>Parser</code> type is expected.</p>
        <p><code>&quot;[&quot; ~ anyNot(&#39;]&#39;) ~ &quot;]&quot;</code> is a shortcut for <code>literal(&quot;[&quot;) ~ anyNot(&#39;]&#39;) ~ literal(&quot;]&quot;)</code>.</p>
        
        <h3 id="character-groups" class="section"><a class="anchor-link left" href="#character-groups"><i class="icofont-laika link">&#xef71;</i></a>Character Groups</h3>
        <p>To parse a range of characters you can either provide a set of matching characters or a predicate:</p>
        <ul>
          <li>
            <p><code>anyOf(&#39;*&#39;, &#39;+&#39;, &#39;-&#39;)</code> reads zero or more characters that match any of the three specified symbols.
            E.g. reading <code>**--**..</code> would provide the result <code>**--**</code>.</p>
          </li>
          <li>
            <p><code>anyNot(&#39;*&#39;, &#39;+&#39;, &#39;-&#39;)</code> is the opposite, it reads zero or more characters that do not match the specified symbols.
            E.g. reading <code>..,,**--**</code> would provide the result <code>..,,</code>.</p>
          </li>
          <li>
            <p><code>anyWhile(_.isUpper)</code> reads zero or more upper case characters. Any predicate <code>Char =&gt; Boolean</code> can be specified.</p>
          </li>
          <li>
            <p>The <code>range</code> helper constructs set of characters, e.g. <code>anyOf(range(&#39;a&#39;,&#39;z&#39;))</code>.</p>
          </li>
          <li>
            <p>There are predefined character groups for common scenarios, e.g. <code>anyOf(CharGroup.hexDigit)</code>.</p>
          </li>
        </ul>
        <p>For all the shown parsers the result may be empty and the parser will always succeed.
        There are ways to set conditions on the length of the input shown in the next section.</p>
        
        <h3 id="length-constraints" class="section"><a class="anchor-link left" href="#length-constraints"><i class="icofont-laika link">&#xef71;</i></a>Length Constraints</h3>
        <p>All character parsers come with <code>min</code>, <code>max</code> and <code>take</code> methods to specify constraints on the length of the result.</p>
        <ul>
          <li>
            <p><code>anyOf(CharGroup.alphaNum).min(3)</code> expects 3 or more matching characters. 
            It fails when it matches on fewer than that.</p>
          </li>
          <li>
            <p><code>anyOf(CharGroup.alphaNum).min(3)</code> expects 0 to 3 characters. 
            It always succeeds. After 3 characters are read it simply ignores any further matching input.</p>
          </li>
          <li>
            <p><code>anyOf(CharGroup.alphaNum).take(3)</code> is a shortcut for <code>anyOf(CharGroup.alphaNum).min(3).max(3)</code>.</p>
          </li>
          <li>
            <p><code>someOf</code>, <code>someNot</code> and <code>someWhile</code> builders are shortcuts for <code>anyOf</code>, <code>anyNot</code> and <code>anyWhile</code>
            that expect at least one matching character. 
            E.g. <code>someOf(CharGroup.alphaNum)</code> is equivalent to <code>anyOf(CharGroup.alphaNum).min(1)</code>. 
            That&#39;s not that many characters saved, but used so frequently that it&#39;s worthwhile.</p>
          </li>
          <li>
            <p>Likewise <code>oneOf</code>, <code>oneNot</code> and <code>oneIf</code> are shortcuts for parsers that parse exactly one character.
            E.g. <code>oneOf(CharGroup.alphaNum)</code> is equivalent to <code>anyOf(CharGroup.alphaNum).take(1)</code>.</p>
          </li>
          <li>
            <p>The <code>count</code> method creates a parser that provides the number of characters read as the result.
            Commonly used for parsing decoration where the length is significant, 
            e.g. for Markdown headers starting with one or more <code>#</code>: <code>someOf(&#39;#&#39;).count</code>.</p>
          </li>
        </ul>
        
        <h2 id="combinators" class="section"><a class="anchor-link left" href="#combinators"><i class="icofont-laika link">&#xef71;</i></a>Combinators</h2>
        <p>So far we were only parsing a single range of input based a condition or set of accepted input characters.
        In every kind of real-world scenario you would need to combine these low-level parsers to larger
        constructs.</p>
        
        <h3 id="concatenation" class="section"><a class="anchor-link left" href="#concatenation"><i class="icofont-laika link">&#xef71;</i></a>Concatenation</h3>
        <p>The <code>~</code> combines the result of two parsers and only succeeds if both of them succeed:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">p</span><span> = </span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;$&#39;</span><span>,</span><span class="char-literal">&#39;_&#39;</span><span>) ~ </span><span class="identifier">someOf</span><span>(</span><span class="identifier">range</span><span>(</span><span class="char-literal">&#39;a&#39;</span><span>, </span><span class="char-literal">&#39;z&#39;</span><span>))</span></code></pre>
        <p>The above parser expect exactly one occurrence of either <code>$</code> or <code>_</code>, followed by one or more occurrences of
        a lowercase letter.</p>
        <p>The result will be <code>String ~ String</code>, where <code>~</code> is a case class that allows to map on the result with the
        same symbol:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">p</span><span>.</span><span class="identifier">map</span><span> { </span><span class="keyword">case</span><span> </span><span class="identifier">firstChar</span><span> ~ </span><span class="identifier">lowerCaseLetter</span><span> =&gt; </span><span class="type-name">Seq</span><span>(</span><span class="identifier">firstChar</span><span>, </span><span class="identifier">lowerCaseLetter</span><span>) }</span></code></pre>
        <p>In many cases we are only interested in one of the results of a concatenation, 
        when some of the results are known for example.
        The <code>~&gt;</code> combinator ignores the left result, <code>&lt;~</code> ignores the right one: </p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">p</span><span> = </span><span class="string-literal">&quot;&lt;&quot;</span><span> ~&gt; </span><span class="identifier">someOf</span><span>(</span><span class="identifier">range</span><span>(</span><span class="char-literal">&#39;a&#39;</span><span>, </span><span class="char-literal">&#39;z&#39;</span><span>)) &lt;~ </span><span class="string-literal">&quot;&gt;&quot;</span></code></pre>
        <p>The result of this parser will be <code>String</code> as the first and last result will be ignored.</p>
        
        <h3 id="alternatives" class="section"><a class="anchor-link left" href="#alternatives"><i class="icofont-laika link">&#xef71;</i></a>Alternatives</h3>
        <p>Two parsers can be defined to be tried as alternatives, 
        where the second will only be invoked if the first parser fails:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;</span><span class="string-literal">&quot;</span><span> ~&gt; </span><span class="identifier">anyNot</span><span>(</span><span class="char-literal">&#39;&quot;&#39;</span><span>) &lt;~ </span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;</span><span class="string-literal">&quot;</span><span>) | </span><span class="identifier">someNot</span><span>(</span><span class="char-literal">&#39; &#39;</span><span>)</span></code></pre>
        <p>The example above parses either text enclosed in double quotes or a string without spaces. 
        The type of the result will be the lowest upper bound of the individual results (like with <code>Option.orElse</code>).</p>
        <p>The resulting parser will succeed if either the first or the second parser succeeds.
        If both of them fail, the returned error will be the one from the parser which successfully read the most characters.
        This will of course also apply to longer chains of alternatives like <code>a | b | c | d</code>.
        In many cases this will be the error message that is the most helpful for the user.</p>
        
        <h3 id="repetitions" class="section"><a class="anchor-link left" href="#repetitions"><i class="icofont-laika link">&#xef71;</i></a>Repetitions</h3>
        <p>The same parser can be invoked repeatedly, while collecting all individual results on the way:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">someOf</span><span>(</span><span class="type-name">CharGroup</span><span>.</span><span class="identifier">alphaNum</span><span>) ~ (</span><span class="string-literal">&quot;,&quot;</span><span> ~&gt; </span><span class="identifier">someOf</span><span>(</span><span class="type-name">CharGroup</span><span>.</span><span class="identifier">alphaNum</span><span>).</span><span class="identifier">rep</span><span>)</span></code></pre>
        <p>The above reads a non-empty sequence of alphanumerical characters followed by zero or more repetitions
        of a comma followed by another sequence of characters.
        The result will be <code>String ~ Seq[String]</code></p>
        <p>This pattern is so common that there is also a shortcut for repeating with a separator:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">someOf</span><span>(</span><span class="type-name">CharGroup</span><span>.</span><span class="identifier">alphaNum</span><span>).</span><span class="identifier">rep</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>)</span></code></pre>
        <p>This parser&#39;s behaviour is identical to the previous one.</p>
        <p>The number of repetitions can be further constrained:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">someOf</span><span>(</span><span class="type-name">CharGroup</span><span>.</span><span class="identifier">hexDigit</span><span>).</span><span class="identifier">max</span><span>(</span><span class="number-literal">4</span><span>)</span></code></pre>
        <p>The above reads between 1 to 4 hexadecimal digits.</p>
        <p>When using the <code>min</code> constraint the parser will fail when it does not reach the specified minimum number of repetitions,
        while the <code>max</code> constraint will always succeed and simply ignore subsequent repetitions.</p>
        <p>There is also a shortcut called <code>.take(4)</code> which is identical to <code>.min(4).max(4)</code>.</p>
        
        <h2 id="producing-results" class="section"><a class="anchor-link left" href="#producing-results"><i class="icofont-laika link">&#xef71;</i></a>Producing Results</h2>
        <p>All of our preceding examples defined lower-level text parsers that produce a <code>String</code> result
        or <code>String ~ String</code> in case of concatenation and <code>Seq[String]</code> in case of repetition.</p>
        <p>In many real-world scenarios parsers are used to build up a form of AST of the parsed input.
        All concrete parsers in Laika do this, the ones of text markup, HOCON and CSS all produce a model representing the input.</p>
        <p>First there is the classic map:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">map</span><span>[</span><span class="type-name">U</span><span>] (</span><span class="identifier">f</span><span>: </span><span class="type-name">T</span><span> =&gt; </span><span class="type-name">U</span><span>): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">U</span><span>]</span></code></pre>
        <p>The API also offers methods that allow to check pre-conditions on the result, 
        potentially causing the parser to fail if they are not met:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">evalMap</span><span> [</span><span class="type-name">U</span><span>] (</span><span class="identifier">f</span><span>: </span><span class="type-name">T</span><span> =&gt; </span><span class="type-name">Either</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">U</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">U</span><span>]
</span><span class="keyword">def</span><span> </span><span class="declaration-name">collect</span><span> [</span><span class="type-name">U</span><span>] (</span><span class="identifier">f</span><span>: </span><span class="type-name">PartialFunction</span><span>[</span><span class="type-name">T</span><span>, </span><span class="type-name">U</span><span>]): </span><span class="type-name">Parser</span><span>[</span><span class="type-name">U</span><span>]</span></code></pre>
        <p>While <code>evalMap</code> maps to an <code>Either</code> where a <code>Left</code> result will cause the parser to fail,
        <code>collect</code> applies a partial function and causes the parser to fail if the function is not defined for the result.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">someOf</span><span>(</span><span class="type-name">CharGroup</span><span>.</span><span class="identifier">digit</span><span>).</span><span class="identifier">evalMap</span><span> { </span><span class="identifier">res</span><span> =&gt;
  </span><span class="keyword">val</span><span> </span><span class="identifier">num</span><span> = </span><span class="identifier">res</span><span>.</span><span class="identifier">toInt</span><span>
  </span><span class="type-name">Either</span><span>.</span><span class="identifier">cond</span><span>(</span><span class="identifier">num</span><span> % </span><span class="number-literal">3</span><span> == </span><span class="number-literal">0</span><span>, </span><span class="identifier">num</span><span>, </span><span class="string-literal">&quot;Number must be divisible by three&quot;</span><span>)
}</span></code></pre>
        <p>The example above creates a parser that reads any number divisible by 3 or fails otherwise.</p>
        <p>You can also chain parsers with <code>flatMap</code>.
        The example parses a start delimiter out of 3 options and then looks for a matching delimiter to close the span:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;*&#39;</span><span>, </span><span class="char-literal">&#39;-&#39;</span><span>, </span><span class="char-literal">&#39;+&#39;</span><span>).</span><span class="identifier">flatMap</span><span> { </span><span class="identifier">res</span><span> =&gt;
  </span><span class="identifier">someNot</span><span>(</span><span class="identifier">res</span><span>.</span><span class="identifier">charAt</span><span>(</span><span class="number-literal">0</span><span>)) &lt;~ </span><span class="identifier">literal</span><span>(</span><span class="identifier">res</span><span>)
}</span></code></pre>
        <p>The second parser will receive the result of the first parser and will continue parsing on the input left over
        by the first.</p>
        <p>You can also ignore the original result of a parser and hard-code a result that should be used if the parser succeeds:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">Fence</span><span>

</span><span class="identifier">literal</span><span>(</span><span class="string-literal">&quot;```&quot;</span><span>).</span><span class="identifier">as</span><span>(</span><span class="type-name">Fence</span><span>)</span></code></pre>
        <p>Another option is to ignore the results of a concatenation and instead use the entire consumed input as a result:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;</span><span class="string-literal">&quot;</span><span> ~&gt; </span><span class="identifier">anyNot</span><span>(</span><span class="char-literal">&#39;&quot;&#39;</span><span>) &lt;~ </span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;</span><span class="string-literal">&quot;</span><span>).</span><span class="identifier">source</span></code></pre>
        <p>This is usually more convenient in all cases where the result you would produce would have been the string concatenation
        of the individual results anyway. 
        Laika&#39;s own parsers use this very frequently.</p>
        <p>Finally, while all the methods shown so far are available for all kinds of <code>Parser[T]</code>,
        the <code>laika.parse.implicits._</code> import also provides a few convenient shortcuts for parsers of a certain result type.</p>
        <p>A result of concatenating a single result with a repetition can be combined into a single list with <code>concat</code> for example:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">someOf</span><span>(</span><span class="type-name">CharGroup</span><span>.</span><span class="identifier">alphaNum</span><span>) ~ (</span><span class="string-literal">&quot;,&quot;</span><span> ~ </span><span class="identifier">someOf</span><span>(</span><span class="type-name">CharGroup</span><span>.</span><span class="identifier">alphaNum</span><span>).</span><span class="identifier">rep</span><span>).</span><span class="identifier">concat</span></code></pre>
        <p>This will turn a parser with the result <code>String ~ Seq[String]</code> into a parser for <code>Seq[String]</code>.</p>
        <p>There are similar variants for results of type <code>Seq[T] ~ Seq[T]</code> of various arities.</p>
        
        <h2 id="delimiters" class="section"><a class="anchor-link left" href="#delimiters"><i class="icofont-laika link">&#xef71;</i></a>Delimiters</h2>
        <p>In many cases the task of a parser is not only to verify whether the input at the current position matches
        a particular predicate, but also whether the surrounding characters meet certain criteria.</p>
        <p>Let&#39;s take the parsing of an emphasized span in text markup as an example. 
        Most languages define exceptions where the span <code>*here*</code> is not parsed as emphasized, 
        for example when it appears in the middle of a word like <code>in*this*example</code>. </p>
        <p>Laika&#39;s parser combinators come with convenient helpers to check conditions on preceding and following characters
        without consuming them.
        Doing this manually with existing low-level combinators is possible, but much more verbose and error-prone.</p>
        <p>A simplified definition of such a parser for an emphasized span could look like this:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">letterOrDigit</span><span>: </span><span class="type-name">Char</span><span> =&gt; </span><span class="type-name">Boolean</span><span> = { </span><span class="identifier">c</span><span> =&gt; 
  </span><span class="type-name">Character</span><span>.</span><span class="identifier">isDigit</span><span>(</span><span class="identifier">c</span><span>) || </span><span class="type-name">Character</span><span>.</span><span class="identifier">isLetter</span><span>(</span><span class="identifier">c</span><span>)
}
</span><span class="keyword">val</span><span> </span><span class="identifier">start</span><span> = </span><span class="identifier">delimiter</span><span>(</span><span class="string-literal">&quot;*&quot;</span><span>).</span><span class="identifier">prevNot</span><span>(</span><span class="identifier">letterOrDigit</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">end</span><span>   = </span><span class="identifier">delimiter</span><span>(</span><span class="string-literal">&quot;*&quot;</span><span>).</span><span class="identifier">nextNot</span><span>(</span><span class="identifier">letterOrDigit</span><span>)

</span><span class="identifier">start</span><span> ~&gt; </span><span class="identifier">someNot</span><span>(</span><span class="char-literal">&#39;*&#39;</span><span>) &lt;~ </span><span class="identifier">end</span><span> </span></code></pre>
        <p>Instead of just using a literal parser for the <code>&quot;*&quot;</code> we use the <code>delimiter</code> parser and its integrated
        shortcuts to check conditions before and after the delimiter.</p>
        <p>Instead of just parsing the delimiter itself, an even more powerful variant parses a span of text until
        a specified delimiter is seen.</p>
        <p>The last line in the previous example can be shortened to:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">start</span><span> ~&gt; </span><span class="identifier">delimitedBy</span><span>(</span><span class="identifier">end</span><span>)</span></code></pre>
        <p>But this variant does not only save a bit of typing, it also comes with additional functionality
        for defining the parsed span.
        One of them is the option to specify conditions under which the parser should fail,
        even if it would later see the given delimiter.</p>
        <p>Let&#39;s assume we want an emphasized span that is not allowed to span multiple lines.
        We can express this with <code>failOn</code>:<br></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">start</span><span> ~&gt; </span><span class="identifier">delimitedBy</span><span>(</span><span class="identifier">end</span><span>).</span><span class="identifier">failOn</span><span>(</span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>)</span></code></pre>
        <p>Other methods are <code>acceptEOF</code> which tells the parser to succeed if either the specified delimiter or the end of the
        input is reached or <code>nonEmpty</code> which causes the parser to fail if the delimiter is seen before consuming any input.</p>
        
        <h2 id="parsing-nested-spans" class="section"><a class="anchor-link left" href="#parsing-nested-spans"><i class="icofont-laika link">&#xef71;</i></a>Parsing Nested Spans</h2>
        <p>The last feature area of the parser combinators we are going to look at is the recursive parsing of nested spans,
        which is at the heart of inline text markup parsing and another area where the library takes away a lot of 
        the boilerplate you&#39;d have to write with simple low-level combinators.</p>
        <p>For a real world example, let&#39;s assume we want to parse markup that allows a Markdown-like link syntax,
        between brackets, with potential markup inside. 
        We don&#39;t allow this syntax to span multiple lines.</p>
        <p>This is how a simplified implementation could look like:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">ast</span><span>.</span><span class="type-name">Span</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">markup</span><span>.</span><span class="type-name">InlineParsers</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">text</span><span>.</span><span class="type-name">PrefixedParser</span><span>

</span><span class="keyword">def</span><span> </span><span class="declaration-name">nestedSpanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">PrefixedParser</span><span>[</span><span class="type-name">Span</span><span>]] = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">linkSpanParser</span><span> = </span><span class="identifier">delimitedBy</span><span>(</span><span class="string-literal">&quot;]&quot;</span><span>).</span><span class="identifier">failOn</span><span>(</span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>)

</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="type-name">InlineParsers</span><span>.</span><span class="identifier">spans</span><span>(</span><span class="identifier">linkSpanParser</span><span>).</span><span class="identifier">embedAll</span><span>(</span><span class="identifier">nestedSpanParsers</span><span>)</span></code></pre>
        <p>We skip the definitions of all the nested parsers, with typical markup parsing this would be a handful or a dozen.
        In the second line we define the parser for the link span itself, using the <code>delimitedBy</code> builder 
        which we introduced in the previous section.</p>
        <p>Finally we pass this parser to the <code>InlineParsers.spans</code> constructor and then tell it to embed all the nested
        span parsers we defined.</p>
        <p>The resulting parser will:</p>
        <ul>
          <li>
            <p>Fail when it sees a newline before seeing the end delimiter.</p>
          </li>
          <li>
            <p>Suspend parsing of this span when a pattern signalling the start of a nested span is seen.
            It will then parse the nested span, add it to the result and resume parsing of the top span.</p>
          </li>
          <li>
            <p>It will finally succeed and provide the result (as a <code>Seq[Span]</code>) when it sees the end delimiter.</p>
          </li>
        </ul>
        <p>There is an alternative constructor <code>InlineParsers.text</code> where the result is <code>String</code> and not <code>Seq[Span]</code>.
        It is less often used, but comes in handy when you want to support something like text between parenthesis
        that should not stop when a closing paren of a nested pair is seen.</p>
        <p>The example above is applicable for a scenario where the author of the code has full control over the
        kind of nested spans which are allowed. 
        In Laika&#39;s text markup support this is not the case, as the user can install markup extensions.
        For this scenario the nested parsers need to be injected from the environment,
        which is demonstrated in <a href="../05-extending-laika/04-writing-parser-extensions.html#recursive-parsing">Recursive Parsing</a> in the chapter on writing parser extensions for markup.</p>
        
        <h2 id="performance-optimizations" class="section"><a class="anchor-link left" href="#performance-optimizations"><i class="icofont-laika link">&#xef71;</i></a>Performance Optimizations</h2>
        <p>The final example in the previous section demonstrated the principles behind parsing inline markup.
        These kind of parsers are quite challenging to optimize as they are at a hotspot of markup parsing and
        recurse between user-provided and library-provided parsers which makes it harder to optimize based on static analysis.</p>
        
        <h3 id="inline-parsing-challenges" class="section"><a class="anchor-link left" href="#inline-parsing-challenges"><i class="icofont-laika link">&#xef71;</i></a>Inline Parsing Challenges</h3>
        <p>Laika has therefore chosen an approach where the optimization happens at parser construction time,
        at a point where all participating parsers are known.</p>
        <p>The key point of the optimization is to avoid a naive combinator-based approach for logic that has to
        execute for nearly every character of the input stream.
        A naive approach would try something like <code>spanA | spanB | spanC | spanD | plainText</code> on each character,
        where <code>spanA</code> end so on are the supported inline constructs.
        It would need to try a long chain of parsers where in probably 95% of cases it would need to fall back
        to the last one: read the input as plain text, the most likely outcome.</p>
        <p>On top of the long list of choices, the parser has to look for other conditions, too,
        as shown in the previous section: characters that cause the current span to fail and those who terminate it.</p>
        <p>Laika combines all these aspects into a single quick check, a simple array lookup that first determines
        whether the current input character is an &quot;interesting&quot; one or just a character to consume and move on.
        Only when this condition is met, the actual parsers are invoked.</p>
        
        <h3 id="the-prefixedparser-trait" class="section"><a class="anchor-link left" href="#the-prefixedparser-trait"><i class="icofont-laika link">&#xef71;</i></a>The PrefixedParser trait</h3>
        <p>To facilitate this at runtime, the library comes with an optimizable sub-trait of <code>Parser[T]</code> called
        <code>PrefixedParser[T]</code>. 
        On top of the actual parsing logic it encapsulates a separate condition for the first character.
        With normal parsers this aspect is opaque. </p>
        <p>Some API entry points in hotspots only accept such a kind of parser and not the base trait,
        when they are in a hotspot of the parsing logic.
        You normally do not have to worry about this, as most of the likely candidates for defining the start 
        condition of an inline construct would satisfy the condition.</p>
        <p>But when you get a compiler error <code>expected PrefixedParser[T], got Parser[T]</code> you know why.
        You tried to pass a non-optimizable parser where the library does not accept it.
        This prevents severe performance degradations just because an extension has been installed.</p>
        <p>As a rule of thumb, all text parsers that do not A) build on negation (like <code>oneNot</code> or <code>someNot</code>)
        or B) allow for empty results like all <code>anyOf</code>, <code>anyNot</code> or <code>anyWhile</code> satisfy this condition.</p>
        <p>This design follows the principle of enabling decent performance, but not at the cost of ease of extensibility,
        one key capability of the library.</p>

        
<hr class="footer-rule"/>
<footer>
  Site generated by <a href="https://typelevel.org/Laika/">Laika</a> with the Helium theme.
</footer>


      </main>

    </div>

  </body>

</html>