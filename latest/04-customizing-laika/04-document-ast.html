<!DOCTYPE html>
<html lang="en">
  
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Typelevel Laika + Helium Theme" />
  <title>The Document AST</title>
  
  
  <meta name="description" content="Site and E-book Generator and Customizable Text Markup Transformer for sbt, Scala and Scala.js"/>
  
  
  
  <link rel="icon" sizes="32x32" type="image/png" href="../../img/site/laika-favicon.png"/>
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  
  <link rel="stylesheet" type="text/css" href="../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../css/manual.css" />
  <script src="../helium/site/laika-helium.js"></script>
    <script src="../helium/site/laika-versions.js"></script>
  <script>initVersions("../../", "/04-customizing-laika/04-document-ast.html", "latest", "https://typelevel.org/Laika/");</script>
  
  <script> /* for avoiding page load transitions */ </script>
</head>

  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 1.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="../../olderVersions/">Older Versions</a></li>
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link glyph-link" href="../../"><i class="icofont-laika home" title="Home">&#xef47;</i></a>

  <div class="row links">
    
    <a class="icon-link svg-link" href="https://github.com/typelevel/Laika"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link svg-link" href="https://javadoc.io/doc/org.typelevel/laika-docs_2.12/latest/laika/index.html"><span class="api" title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="../downloads.html"><i class="icofont-laika download" title="Download">&#xef08;</i></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="icon-link svg-link" href="https://github.com/typelevel/Laika"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link svg-link" href="https://javadoc.io/doc/org.typelevel/laika-docs_2.12/latest/laika/index.html"><span class="api" title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="../downloads.html"><i class="icofont-laika download" title="Download">&#xef08;</i></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../table-of-content.html">Table of Content</a></li>
    <li class="level1 nav-leaf"><a href="../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-header">About Laika</li>
    <li class="level2 nav-leaf"><a href="../01-about-laika/01-features.html">Features</a></li>
    <li class="level2 nav-leaf"><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
    <li class="level1 nav-header">Running Laika</li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/01-sbt-plugin.html">sbt Plugin</a></li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/02-library-api.html">Library API</a></li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/03-configuration.html">Configuration</a></li>
    <li class="level1 nav-header">Preparing Content</li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/03-theme-settings.html">Theme Settings</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
    <li class="level1 nav-header">Customizing Laika</li>
    <li class="level2 nav-leaf"><a href="01-overview.html">Customizing Laika - Overview</a></li>
    <li class="level2 nav-leaf"><a href="03-creating-templates.html">Creating Templates</a></li>
    <li class="level2 active nav-leaf"><a href="#">The Document AST</a></li>
    <li class="level2 nav-leaf"><a href="05-ast-rewriting.html">AST Rewriting</a></li>
    <li class="level2 nav-leaf"><a href="06-overriding-renderers.html">Overriding Renderers</a></li>
    <li class="level1 nav-header">Extending Laika</li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/01-overview.html">Extending Laika - Overview</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/02-creating-themes.html">Creating Themes</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/03-implementing-directives.html">Implementing Directives</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/06-adding-syntax-highlighters.html">Adding Syntax Highlighters</a></li>
    <li class="level2 nav-leaf"><a href="../05-extending-laika/07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
    <li class="level1 nav-header">Sub-Modules</li>
    <li class="level2 nav-leaf"><a href="../06-sub-modules/02-laikas-parser-combinators.html">Laika&#39;s Parser Combinators</a></li>
    <li class="level2 nav-leaf"><a href="../06-sub-modules/03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
    <li class="level1 nav-header">Reference</li>
    <li class="level2 nav-leaf"><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">The Document AST</a></p>

  <ul class="nav-list">
    <li class="level1 nav-node"><a href="#trait-hierarchy">Trait Hierarchy</a></li>
    <li class="level2 nav-leaf"><a href="#base-traits">Base Traits</a></li>
    <li class="level2 nav-leaf"><a href="#containers">Containers</a></li>
    <li class="level2 nav-leaf"><a href="#special-types">Special Types</a></li>
    <li class="level1 nav-node"><a href="#container-elements">Container Elements</a></li>
    <li class="level2 nav-leaf"><a href="#lists">Lists</a></li>
    <li class="level2 nav-leaf"><a href="#block-containers">Block Containers</a></li>
    <li class="level2 nav-leaf"><a href="#links-and-references">Links and References</a></li>
    <li class="level2 nav-leaf"><a href="#span-containers">Span Containers</a></li>
    <li class="level2 nav-leaf"><a href="#text-containers">Text Containers</a></li>
    <li class="level1 nav-node"><a href="#other-elements">Other Elements</a></li>
    <li class="level2 nav-leaf"><a href="#block-elements">Block Elements</a></li>
    <li class="level2 nav-leaf"><a href="#span-elements">Span Elements</a></li>
    <li class="level2 nav-leaf"><a href="#template-spans">Template Spans</a></li>
    <li class="level1 nav-leaf"><a href="#ast-element-companions">AST Element Companions</a></li>
    <li class="level1 nav-node"><a href="#document-trees">Document Trees</a></li>
    <li class="level2 nav-leaf"><a href="#the-document-type">The Document Type</a></li>
    <li class="level2 nav-leaf"><a href="#the-documenttree-type">The DocumentTree Type</a></li>
    <li class="level1 nav-leaf"><a href="#cursors">Cursors</a></li>
    <li class="level1 nav-leaf"><a href="#ast-transformation-phases">AST Transformation Phases</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/typelevel/Laika/tree/main/docs/src/04-customizing-laika/04-document-ast.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="the-document-ast" class="title">The Document AST</h1>
        <p>Laika decouples the semantics of the various markup formats and those of the supported output formats
        by representing every document in a generic AST between parsing and rendering.
        This allows to add custom processing logic only operating on the document structure itself, 
        so it can be used with all supported input and output formats unchanged.</p>
        <p>This chapter gives a brief overview over the hierarchy of the main base traits for AST nodes
        as well as short listings for about 80% of available node types.</p>
        
        <h2 id="trait-hierarchy" class="section"><a class="anchor-link left" href="#trait-hierarchy"><i class="icofont-laika link">&#xef71;</i></a>Trait Hierarchy</h2>
        <p>All AST nodes extend one of the base traits from the hierarchy as well as optionally various additional mixins.</p>
        <p>Providing a rich collection of traits that assist with classification and optional functionality
        helps with developing generic processing logic that does not need to know all available concrete types.
        You can, for example, collectively process all <code>BlockContainer</code> or <code>ListContainer</code> nodes without caring
        about their concrete implementation.</p>
        <p>The traits are not sealed as the model is designed to be extensible.</p>
        
        <h3 id="base-traits" class="section"><a class="anchor-link left" href="#base-traits"><i class="icofont-laika link">&#xef71;</i></a>Base Traits</h3>
        <p>At the top of the hierarchy the AST contains the following node types:</p>
        <div class="default-image-block">
          <img src="../../img/document-ast.png" alt="Base Traits of the Document AST" width="872" height="405">
        </div>
        <ul>
          <li>
            <p><code>Element</code> is the base trait of the hierarchy. 
            It extends <code>Product</code> and <code>Serializable</code> and has a single abstract property <code>options: Options</code>.
            The <code>Options</code> type allows to associate an optional id and a set of style names to a node.
            The latter can be interpreted differently as hints by various renderers, 
            in HTML they simply get rendered as class attributes for example.
            <code>Element</code> also includes concrete methods to add or remove ids and style names.
            Most nodes in Laika&#39;s AST extend one of the more concrete sub-traits and not this trait directly.</p>
          </li>
          <li>
            <p><code>Block</code> is one of the two major element types in the AST.
            Block level elements always start on a new line and in markup they often (but not always)
            require a preceding blank line.
            They can contain other block or span elements.
            It is similar to a <code>display: block</code> element in HTML.</p>
          </li>
          <li>
            <p><code>Span</code> is the other of the two major element types in the AST.
            Span elements can start anywhere in the middle of a line or span multiple lines.
            They can contain other span elements, but no block elements.
            It is similar to a <code>display: inline</code> element in HTML.</p>
          </li>
          <li>
            <p>A <code>ListItem</code> can only occur as a child of a <code>ListContainer</code>.
            See <a href="#lists">Lists</a> below for a list of available list types.</p>
          </li>
          <li>
            <p>While most other node types represent content parsed from text markup,
            a <code>TemplateSpan</code> represents a portion of a parsed template.</p>
          </li>
          <li>
            <p>The <code>Container</code> sub-hierarchy (explained in the next section) is not mutually exclusive to the base traits like
            <code>Block</code> or <code>Span</code>. 
            Each container is always also one of the base types, but the mapping is not fixed and therefore not expressed
            in the hierarchy (e.g. a <code>SpanContainer</code> can be a <code>Span</code> or <code>Block</code> element itself). </p>
          </li>
        </ul>
        
        <h3 id="containers" class="section"><a class="anchor-link left" href="#containers"><i class="icofont-laika link">&#xef71;</i></a>Containers</h3>
        <p>Most element types in the AST are containers.</p>
        <ul>
          <li>
            <p><code>Container[+T]</code> is the base trait for all container types. 
            It has a single property <code>content: T</code>.</p>
          </li>
          <li>
            <p><code>TextContainer</code> is a simple <code>Container[String]</code>, a leaf node of the AST.
            See <a href="#text-containers">Text Containers</a> below for a list of concrete types.</p>
          </li>
          <li>
            <p><code>ElementContainer[+E &lt;: Element]</code> is a <code>Container[Seq[E]]</code>. 
            It is the base trait for all containers which hold other AST nodes.</p>
            <p>It mixes in <code>ElementTraversal</code> which has an API that allows to select child nodes (recursively) based on a predicate
            or partial function. </p>
          </li>
          <li>
            <p><code>RewritableContainer</code> is the trait all containers need to mix in when they want to participate 
            in an AST transformation. 
            It has a single abstract method <code>rewriteChildren (rules: RewriteRules): Self</code>.</p>
          </li>
          <li>
            <p><code>BlockContainer</code> is an <code>ElementContainer[Block]</code> and a <code>RewritableContainer</code>.
            See <a href="#block-containers">Block Containers</a> below for a list of concrete types.</p>
          </li>
          <li>
            <p><code>SpanContainer</code> is an <code>ElementContainer[Span]</code> and a <code>RewritableContainer</code>.
            See <a href="#span-containers">Span Containers</a> below for a list of concrete types.</p>
          </li>
          <li>
            <p><code>ListContainer</code> is an <code>ElementContainer[ListItem]</code> and a <code>RewritableContainer</code>.
            See <a href="#lists">Lists</a> below for a list of concrete types.</p>
          </li>
        </ul>
        
        <h3 id="special-types" class="section"><a class="anchor-link left" href="#special-types"><i class="icofont-laika link">&#xef71;</i></a>Special Types</h3>
        <p>The first group of types are traits that can be mixed in to a concrete type:</p>
        <ul>
          <li>
            <p><code>Hidden</code> is a node type that holds metadata or link definitions and will be ignored by renderers.</p>
          </li>
          <li>
            <p><code>Unresolved</code> is a node type that needs to be resolved during an AST transformation,
            for example a reference to a link definition by id.
            Having such a node type in the tree after all transformations are performed and right before rendering
            is an error and will cause the transformation to fail.</p>
          </li>
          <li>
            <p><code>Invalid</code> is a node that has been inserted by a parser or an AST transformation rule to indicate a problem.
            Depending on the configuration the presence of such a node may either cause the transformation to fail,
            or get rendered as part of the page content for visual debugging. 
            See <a href="../02-running-laika/03-configuration.html#error-handling">Error Handling</a> for details on how these nodes drive rendering and error reporting.</p>
          </li>
          <li>
            <p><code>Fallback</code> is a node that holds an &quot;alternative&quot; node type representing the same content.
            When a parser or rewrite rule inserts a custom element type potentially not known by some renderers,
            it can offer a more common alternative, too.</p>
          </li>
          <li>
            <p><code>SpanResolver</code> or <code>BlockResolver</code> nodes are special node types that know how to replace themselves during
            an AST transformation.
            Usually the node types and the rules that replace them during a transformation are decoupled.
            In cases where this is not necessary or not desired, this logic can be embedded in the node type itself.
            These traits have a <code>resolve</code> method that passes in a <code>DocumentCursor</code> that can be used to create the replacement
            node.
            It&#39;s useful for scenarios where producing the final node requires access to the configuration or other documents,
            which is not possible during the parsing phase.
            See <a href="#cursors">Cursors</a> below and the chapter on <a href="05-ast-rewriting.html#ast-rewriting">AST Rewriting</a> for more details.</p>
          </li>
          <li>
            <p><code>RawContent</code> represents a string that the parser should interpret as &quot;pass-through&quot;, intended to be rendered
            to the output unchanged. </p>
          </li>
        </ul>
        <p>Finally, there is a group of concrete types with special behaviour:</p>
        <ul>
          <li>
            <p><code>DocumentFragment</code> holds a named body element that is not supposed to be rendered with the main content.
            It may be used for populating template elements like sidebars and footers.
            See <a href="03-creating-templates.html#document-fragments">Document Fragments</a> for details.</p>
          </li>
          <li>
            <p><code>TargetFormat</code> holds content that should only be included for the specified target formats.
            All other renderers are supposed to ignore this node.
            As an example, you may want to render some content on the generated website, 
            but not in the e-books (EPUB and PDF).</p>
          </li>
          <li>
            <p><code>RuntimeMessage</code> is a node type that contains a message associated with a level.
            The presence of any message with a level of <code>Error</code> or higher usually causes the transformation to fail,
            unless you switched to visual debugging. 
            See <a href="../02-running-laika/03-configuration.html#error-handling">Error Handling</a> for the relevant configuration options.
            Parser extensions, directives or rewrite rules that encounter errors can use this node type to report
            back on the issue in the exact location of the AST it occurred.</p>
          </li>
        </ul>
        
        <h2 id="container-elements" class="section"><a class="anchor-link left" href="#container-elements"><i class="icofont-laika link">&#xef71;</i></a>Container Elements</h2>
        <p>Since the document AST is a recursive structure most elements are either a container of other elements
        or a <code>TextContainer</code>. 
        The few that are neither are listed in <a href="#other-elements">Other Elements</a>.</p>
        <p>The following lists describe the majority of the available types, only leaving out some of the more exotic options.</p>
        
        <h3 id="lists" class="section"><a class="anchor-link left" href="#lists"><i class="icofont-laika link">&#xef71;</i></a>Lists</h3>
        <p>There are four different list types in the core AST model. 
        All types listed below have a corresponding <code>ListItem</code> container, e.g. <code>BulletList</code> nodes hold <code>BulletListItem</code>
        children.</p>
        <ul>
          <li>
            <p><code>BulletList</code> represents a standard bullet list containing a definition of the bullet type alongside the list items.</p>
          </li>
          <li>
            <p><code>EnumList</code> is an enumerated list containing a definition of the enumeration style alongside the list items.
            Supported enumeration styles are <code>Arabic</code>, <code>LowerRoman</code>, <code>UpperRoman</code>, <code>LowerAlpha</code> and <code>UpperAlpha</code>.
            reStructuredText supports all enumeration styles, Markdown only <code>Arabic</code>.</p>
          </li>
          <li>
            <p><code>DefinitionList</code> is a list of definitions that associate terms with descriptions.</p>
          </li>
          <li>
            <p><code>NavigationList</code> is a nested tree structure of internal or external links, 
            often auto-generated from a particular node in the document tree.</p>
          </li>
        </ul>
        
        <h3 id="block-containers" class="section"><a class="anchor-link left" href="#block-containers"><i class="icofont-laika link">&#xef71;</i></a>Block Containers</h3>
        <ul>
          <li>
            <p><code>RootElement</code> represents the root node of a document AST.</p>
          </li>
          <li>
            <p><code>Section</code> represents a single section, containing a title and the block content of the section.
            This node type may contain further nested sections.</p>
          </li>
          <li>
            <p><code>TitledBlock</code> associates a title with block content, but in contrast to a <code>Section</code> it will not 
            contribute to auto-generated navigation structures for the document. </p>
          </li>
          <li>
            <p><code>Figure</code> groups an image with a caption and an optional legend.</p>
          </li>
          <li>
            <p><code>QuotedBlock</code> represent a quotation.</p>
          </li>
          <li>
            <p><code>Footnote</code> represents a footnote that will render differently with each output format.
            In HTML footnotes will render in the location they were defined in, but can be styled differently.
            In PDF they become proper footnotes at the bottom of the page and in EPUB they become popups by default.</p>
          </li>
          <li>
            <p><code>BlockSequence</code> is a generic sequence of blocks without any semantics attached.</p>
          </li>
        </ul>
        
        <h3 id="links-and-references" class="section"><a class="anchor-link left" href="#links-and-references"><i class="icofont-laika link">&#xef71;</i></a>Links and References</h3>
        <p>Most links and references are also a <code>SpanContainer</code> (for the link text), but a few are not.
        Span containers that are not links or references are listed in the next section.</p>
        <p>The <code>Link</code> types differ from the <code>Reference</code> types in that the former are fully resolved, &quot;ready to render&quot;,
        whereas the latter still need to be resolved based on the surrounding content or other documents.</p>
        <p><code>Reference</code> nodes only appear in the AST before the AST transformation step, 
        where they will be either translated to a corresponding <code>Link</code> node or an <code>Invalid</code> node in case of errors.</p>
        <p>For details on this functionality from a markup author&#39;s perspective, see <a href="../03-preparing-content/02-navigation.html#navigation">Navigation</a>. </p>
        <p>Fully resolved <code>Link</code> nodes:</p>
        <ul>
          <li>
            <p><code>SpanLink</code> is a link associated with a sequence of spans, which may be text or images.</p>
          </li>
          <li>
            <p><code>FootnoteLink</code> is a link to a footnote in the same document.
            The link text here is usually just a label or number, e.g. <code>[4]</code>.</p>
          </li>
        </ul>
        <p><code>Reference</code> nodes that need to be resolved during AST rewriting:</p>
        <ul>
          <li>
            <p><code>PathReference</code> refers to a different document or section by a relative path, resolves to <code>SpanLink</code>.</p>
          </li>
          <li>
            <p><code>LinkIdReference</code> refers either to the id of a URL defined elsewhere or directly to a section-id,
            resolves to <code>SpanLink</code>.</p>
          </li>
          <li>
            <p><code>ImageIdReference</code> refers to the id of an image URL defined elsewhere, resolves to <code>Image</code>.</p>
          </li>
          <li>
            <p><code>FootnoteReference</code> refers to a footnote in the same document, resolves to <code>FootnoteLink</code>.
            Supports special label functionality like auto-numbering.</p>
          </li>
          <li>
            <p><code>ContextReference</code> encapsulates a reference in HOCON syntax, e.g. <code>${cursor.currentDocument.title}</code>.
            Resolves to whatever type the <code>Config</code> instance holds for the specified key.</p>
          </li>
        </ul>
        
        <h3 id="span-containers" class="section"><a class="anchor-link left" href="#span-containers"><i class="icofont-laika link">&#xef71;</i></a>Span Containers</h3>
        <ul>
          <li>
            <p><code>Paragraph</code> is the basic span container type. 
            Each block element without explicit markup that indicates a special type like a list or a header 
            is represented by this node type.</p>
          </li>
          <li>
            <p><code>Header</code> is a header element with an associated level.</p>
          </li>
          <li>
            <p><code>Title</code> represents the first header of the document.</p>
          </li>
          <li>
            <p><code>CodeBlock</code> represents a block of code and the name of the language.
            When Laika&#39;s built-in syntax highlighter is active and recognizes this language,
            the content will be a sequence of <code>CodeSpan</code> nodes with associated categories.
            Otherwise a single <code>CodeSpan</code> node will hold the entire content.</p>
          </li>
          <li>
            <p><code>Emphasized</code>, <code>Strong</code>, <code>Deleted</code> and <code>Inserted</code> all contain a sequence of spans with the
            corresponding associated semantics as indicated by the markup.</p>
          </li>
          <li>
            <p><code>SpanSequence</code> is a generic sequence of spans without any semantics attached.</p>
          </li>
        </ul>
        
        <h3 id="text-containers" class="section"><a class="anchor-link left" href="#text-containers"><i class="icofont-laika link">&#xef71;</i></a>Text Containers</h3>
        <ul>
          <li>
            <p><code>Text</code> is the node type representing unformatted text.</p>
          </li>
          <li>
            <p><code>Literal</code> is a literal span type.</p>
          </li>
          <li>
            <p><code>LiteralBlock</code> is a literal block type that usually renders with whitespace preserved.</p>
          </li>
          <li>
            <p><code>CodeSpan</code> is a span of text associated with a code category. 
            Used in a <code>CodeBlock</code> where Laika&#39;s internal syntax highlighter has been applied. </p>
          </li>
          <li>
            <p><code>Comment</code> is a comment in a markup document (not a comment in a code block).
            It is not a <code>Hidden</code> node as renderers for output formats that support comment syntax render this node.</p>
          </li>
        </ul>
        
        <h2 id="other-elements" class="section"><a class="anchor-link left" href="#other-elements"><i class="icofont-laika link">&#xef71;</i></a>Other Elements</h2>
        <p>This section lists the block and span elements that are not containers and the special elements representing templates.</p>
        
        <h3 id="block-elements" class="section"><a class="anchor-link left" href="#block-elements"><i class="icofont-laika link">&#xef71;</i></a>Block Elements</h3>
        <p>Most block elements are either <a href="#span-containers">Span Containers</a> or <a href="#block-containers">Block Containers</a>, but a few are neither:</p>
        <ul>
          <li>
            <p>The <code>Table</code> element represents a table structure with the help of its related types 
            <code>Row</code>, <code>Cell</code>, <code>TableHead</code>, <code>TableBody</code>, <code>Caption</code> and <code>Columns</code>.</p>
            <p>Laika supports three table types out of the box: The grid table and simple table in reStructuredText
            and the table from GitHubFlavor for Markdown.
            All three types parse to the same model structure, 
            but some of the simpler table types might only use a subset of the available node types.</p>
          </li>
          <li>
            <p>The <code>LinkDefinition</code> is a <code>Hidden</code> element that represents a link to an external or internal target mapped
            to an id that can be referenced by other elements.</p>
            <p>Both, the Markdown and reStructuredText parsers produce such an element, albeit with different syntax.
            In Markdown the syntax is <code>[id]: http://foo.com/</code> for example.</p>
            <p>All renderers are supposed to ignore this element and it normally gets removed during the AST transformation phase.</p>
          </li>
          <li>
            <p>The <code>Rule</code> element represents a horizontal rule.</p>
          </li>
          <li>
            <p>The <code>PageBreak</code> element can be used to explicitly request a page break at the position of the node.
            Currently all renderers apart from the one for PDF ignore this element.</p>
          </li>
        </ul>
        
        <h3 id="span-elements" class="section"><a class="anchor-link left" href="#span-elements"><i class="icofont-laika link">&#xef71;</i></a>Span Elements</h3>
        <p>Most span elements are either <a href="#span-containers">Span Containers</a> or <a href="#text-containers">Text Containers</a>, but a few are neither:</p>
        <ul>
          <li>
            <p>The <code>Image</code> element is a <code>Span</code> element that points to an image resource which may be internal or external.
            It supports optional size and title attributes.</p>
            <p>If you want to use an image as a block-level element you can wrap it in a <code>Paragraph</code>. </p>
          </li>
          <li>
            <p>The <code>LineBreak</code> element represents an explicit line break in inline content.</p>
          </li>
        </ul>
        
        <h3 id="template-spans" class="section"><a class="anchor-link left" href="#template-spans"><i class="icofont-laika link">&#xef71;</i></a>Template Spans</h3>
        <p>Templates get parsed into an AST in a similar way as markup documents, but the model is much simpler.
        The most important element types are listed below.</p>
        <ul>
          <li>
            <p>A <code>TemplateString</code> is a <code>TextContainer</code> that holds a raw template element in the target format (e.g. HTML).</p>
          </li>
          <li>
            <p>A <code>TemplateElement</code> is a wrapper around a <code>Block</code> or <code>Span</code> element from a markup AST.</p>
            <p>This allows the use of directives or other techniques that produce markup node types inside templates,
            so that the same directive can be used in template and markup documents.</p>
          </li>
          <li>
            <p>A <code>TemplateSpanSequence</code> is a generic sequence of <code>TemplateSpan</code> elements.</p>
          </li>
          <li>
            <p>The <code>TemplateRoot</code> node is the root element of every template, similar to how <code>RootElement</code> is the root of
            all markup documents. </p>
          </li>
          <li>
            <p><code>EmbeddedRoot</code> is the node holding the merged content from the associated markup document.
            Usually one node of this type gets produced by every AST transformation.</p>
          </li>
        </ul>
        
        <h2 id="ast-element-companions" class="section"><a class="anchor-link left" href="#ast-element-companions"><i class="icofont-laika link">&#xef71;</i></a>AST Element Companions</h2>
        <p>Laika includes base traits called <code>BlockContainerCompanion</code> and <code>SpanContainerCompanion</code> 
        for adding companion objects that provide convenient shortcuts for creating containers.</p>
        <p>They allow to shorten constructor invocations for simple use cases, e.g. <code>Paragraph(Seq(Text(&quot;hello&quot;)))</code>
        can be changed to <code>Paragraph(&quot;hello&quot;)</code>. 
        They also add an <code>empty</code> constructor and a vararg constructor for passing the content.</p>
        <p>If you create a custom element type you can use these base traits to get all these shortcuts with a few lines:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">MyElement</span><span>(</span><span class="identifier">content</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">Block</span><span>], </span><span class="identifier">options</span><span>: </span><span class="type-name">Options</span><span> = </span><span class="type-name">Options</span><span>.</span><span class="identifier">empty</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Block</span><span>
    </span><span class="keyword">with</span><span> </span><span class="type-name">BlockContainer</span><span> {
  </span><span class="keyword">type</span><span> </span><span class="type-name">Self</span><span> = </span><span class="type-name">MyElement</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">withContent</span><span>(</span><span class="identifier">newContent</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">Block</span><span>]): </span><span class="type-name">MyElement</span><span> = </span><span class="identifier">copy</span><span>(</span><span class="identifier">content</span><span> = </span><span class="identifier">newContent</span><span>)
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">withOptions</span><span>(</span><span class="identifier">options</span><span>: </span><span class="type-name">Options</span><span>): </span><span class="type-name">MyElement</span><span>       = </span><span class="identifier">copy</span><span>(</span><span class="identifier">options</span><span> = </span><span class="identifier">options</span><span>)
}

</span><span class="keyword">object</span><span> </span><span class="type-name">MyElement</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">BlockContainerCompanion</span><span> {
  </span><span class="keyword">type</span><span> </span><span class="type-name">ContainerType</span><span> = </span><span class="type-name">MyElement</span><span>
  </span><span class="keyword">override</span><span> </span><span class="keyword">protected</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">createBlockContainer</span><span> (</span><span class="identifier">blocks</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">Block</span><span>]): </span><span class="type-name">ContainerType</span><span> = 
    </span><span class="type-name">MyElement</span><span>(</span><span class="identifier">blocks</span><span>)
}</span></code></pre>
        
        <h2 id="document-trees" class="section"><a class="anchor-link left" href="#document-trees"><i class="icofont-laika link">&#xef71;</i></a>Document Trees</h2>
        <p>So far we dealt with <code>Element</code> types which are used to represent the content of a single markup document or template.</p>
        <p>When a transformation of inputs from an entire directory gets processed, the content gets
        assembled into a <code>DocumentTree</code>, consisting of nested <code>DocumentTree</code> nodes and leaf <code>Document</code> nodes.</p>
        
        <h3 id="the-document-type" class="section"><a class="anchor-link left" href="#the-document-type"><i class="icofont-laika link">&#xef71;</i></a>The Document Type</h3>
        <p>The <code>Document</code> class contains the following properties:</p>
        <ul>
          <li>
            <p>The <code>path</code> property holds the absolute, virtual path of the document inside the tree.
            It is virtual as no content in Laika has to originate from the file system.
            See <a href="../03-preparing-content/01-directory-structure.html#virtual-tree-abstraction">Virtual Tree Abstraction</a> for details.</p>
          </li>
          <li>
            <p>The <code>content</code> property holds the parsed content of the markup document.
            Its type <code>RootElement</code> is one of the types listed under <a href="#block-containers">Block Containers</a> above.</p>
          </li>
          <li>
            <p>The <code>fragment</code> property holds a map of fragments, which are named body elements that are not supposed
            to be rendered with the main content.
            It may be used for populating template elements like sidebars and footers.
            See <a href="03-creating-templates.html#document-fragments">Document Fragments</a> for details.</p>
          </li>
          <li>
            <p>The <code>config</code> property holds the configuration parsed from an optional HOCON header in the markup document.
            It is an empty instance if there is no such header.
            See <a href="../06-sub-modules/03-laikas-hocon-api.html#laika-s-hocon-api">Laika&#39;s HOCON API</a> for details.</p>
          </li>
          <li>
            <p>The <code>position</code> property represents the position of the document in a tree.
            It can be used for functionality like auto-numbering.
            It is not populated if the transformation deals with a single document only.</p>
          </li>
          <li>
            <p><code>title: Option[SpanSequence]</code> provides the title of the document, either from the configuration header or
            the first header in the markup. It is empty when none of the two are defined.</p>
          </li>
          <li>
            <p><code>sections: Seq[SectionInfo]</code> provides the hierarchical structure of sections, obtained from the headers
            inside the document and their assigned levels.</p>
          </li>
        </ul>
        
        <h3 id="the-documenttree-type" class="section"><a class="anchor-link left" href="#the-documenttree-type"><i class="icofont-laika link">&#xef71;</i></a>The DocumentTree Type</h3>
        <p>In a multi-input transformation all <code>Document</code> instances get assembled 
        into a recursive structure of <code>DocumentTree</code> instances.</p>
        <ul>
          <li>
            <p>Like with documents, the <code>path: Path</code> property holds the absolute, virtual path of the document inside the tree.
            For the root tree it will be <code>Root</code>.</p>
          </li>
          <li>
            <p>The <code>content: Seq[TreeContent]</code> property holds the child trees and documents of this tree.
            Its type <code>TreeContent</code> is a trait implemented by both <code>Document</code> and <code>DocumentTree</code>.</p>
          </li>
          <li>
            <p>The <code>titleDocument: Option[TitleDocument]</code> property holds an optional title document for this tree.
            A tree often represents a logical structure like a chapter.
            It is used as a section headline in auto-generated site navigation 
            as well as the first content of this tree in linearized e-book output (EPUB or PDF).
            See <a href="../03-preparing-content/01-directory-structure.html#title-documents">Title Documents</a> for details.</p>
          </li>
          <li>
            <p>The <code>templates: Seq[TemplateDocument]</code> property holds the AST of all templates parsed inside this tree
            (excluding templates from child trees).
            The AST nodes it can hold are described in <a href="#template-spans">Template Spans</a> above.
            See <a href="03-creating-templates.html#creating-templates">Creating Templates</a> for more details on the template engine.</p>
          </li>
          <li>
            <p>The <code>config: Config</code> property holds the configuration parsed from an optional HOCON document named <code>directory.conf</code>.
            It is an empty instance if there is no file.
            It can also be populated programmatically in cases where the content is generated and not loaded from the file system.
            See <a href="../06-sub-modules/03-laikas-hocon-api.html#laika-s-hocon-api">Laika&#39;s HOCON API</a> for details.</p>
          </li>
          <li>
            <p>The <code>position: TreePosition</code> property represents the position of the document in a tree.
            It can be used for functionality like auto-numbering.
            It is not populated if the transformation deals with a single document only.</p>
          </li>
        </ul>
        <p>The API provides additional methods as shortcuts for selecting content from the tree:</p>
        <ul>
          <li>
            <p><code>selectSubtree</code>, <code>selectTemplate</code> and <code>selectDocument</code> all accept a <code>RelativePath</code> argument to select
            content from the tree structure, including content from sub-trees.</p>
          </li>
          <li>
            <p><code>allDocuments: Seq[Document]</code> selects all documents contained in this tree, fetched recursively, depth-first.
            This is in contrast to the <code>content</code> property which selects documents and sub-trees on the current level.</p>
          </li>
          <li>
            <p>The <code>runtimeMessage</code> method selects any <code>RuntimeMessage</code> matching the specified filter.
            Useful for reporting errors and warnings in the parsed result.</p>
          </li>
        </ul>
        
        <h2 id="cursors" class="section"><a class="anchor-link left" href="#cursors"><i class="icofont-laika link">&#xef71;</i></a>Cursors</h2>
        <p>During an AST transformation the rewrite rule might require access to more than just the AST node passed to it.
        When it is a rule for resolving references or creating a table of contents, it needs access to the AST of other
        documents, too.</p>
        <p>The <code>Cursor</code> type provides this access, but in contrast to the recursive <code>DocumentTree</code> which is a classic tree
        structure, it represents the tree from the perspective of the current document, with methods to navigate to
        parents, siblings or the root tree.</p>
        <p>An instance of <code>DocumentCursor</code> is passed to rewrite rules for AST transformations (see <a href="05-ast-rewriting.html#ast-rewriting">AST Rewriting</a>, 
        and to directive implementations that request access to it (see <a href="../05-extending-laika/03-implementing-directives.html#implementing-directives">Implementing Directives</a>).</p>
        <p>Let&#39;s look at some of its properties:</p>
        <ul>
          <li>
            <p><code>target: Document</code> represents the document this cursor points to.</p>
          </li>
          <li>
            <p><code>parent: TreeCursor</code> represents the parent tree this document belongs to.
            A <code>TreeCursor</code> is similar to a <code>DocumentCursor</code>, just that its target is a <code>DocumentTree</code> instead. </p>
          </li>
          <li>
            <p><code>root: RootCursor</code> represents the root of the entire tree.</p>
          </li>
          <li>
            <p><code>previousDocument: Option[DocumentCursor]</code> and <code>nextDocument: Option[DocumentCursor]</code> represent its siblings.
            For a cursor pointing to the first document in a sub-tree (chapter), <code>previousDocument</code> will be empty, 
            for the last document <code>nextDocument</code> will be empty.</p>
          </li>
          <li>
            <p><code>flattenedSiblings.previousDocument</code> and <code>flattenedSiblings.nextDocument</code> are alternatives that look beyond
            the current sub-tree and flatten the hierarchy into a single list in depth-first traversal.</p>
          </li>
        </ul>
        
        <h2 id="ast-transformation-phases" class="section"><a class="anchor-link left" href="#ast-transformation-phases"><i class="icofont-laika link">&#xef71;</i></a>AST Transformation Phases</h2>
        <p>In most transformations the AST moves through three different phases between parsing and rendering:</p>
        <p>1) The first shape will be the AST produced by the parsers for text markup or templates.
           Since parsers do not have access to the surrounding nodes or the configuration,
           some parsers for elements like links or navigation structures need to insert temporary node types.</p>
        <p>2) After parsing of all participating documents and templates completes,
           the first AST transformation is performed.
           It resolves links, variables, footnotes, builds the document&#39;s section structure or generates a table of contents.
           These transformations are defined in rewrite rules.
           The library contains a basic set of rules internally for linking and navigation,
           but users can provide additional, custom rules.
           See <a href="05-ast-rewriting.html#ast-rewriting">AST Rewriting</a> for details.</p>
        <p>3) Finally, the resolved AST representing the markup document is applied to the AST of the template.
           It is merely the insertion of one AST at a particular node in another AST.</p>
        <p>The result obtained from step 3 is then passed to renderers.
        When rendering the same content to multiple output formats, the steps 1 and 2 are always only executed once.
        Only step 3 has to be repeated for each output format, as each format comes with its own templates.</p>

        
<hr class="footer-rule"/>
<footer>
  Site generated by <a href="https://typelevel.org/Laika/">Laika</a> with the Helium theme.
</footer>


      </main>

    </div>

  </body>

</html>