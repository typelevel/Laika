<!DOCTYPE html>
<html lang="en">
  
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Typelevel Laika + Helium Theme" />
  <title>Adding Syntax Highlighters</title>
  
  
  <meta name="description" content="Site and E-book Generator and Customizable Text Markup Transformer for sbt, Scala and Scala.js"/>
  
  
  
  <link rel="icon" sizes="32x32" type="image/png" href="../../img/site/laika-favicon.png"/>
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  
  <link rel="stylesheet" type="text/css" href="../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../css/manual.css" />
  <script src="../helium/site/laika-helium.js"></script>
    <script src="../helium/site/laika-versions.js"></script>
  <script>initVersions("../../", "/05-extending-laika/06-adding-syntax-highlighters.html", "latest", "https://typelevel.org/Laika/");</script>
  
  <script> /* for avoiding page load transitions */ </script>
</head>

  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 1.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="../../olderVersions/">Older Versions</a></li>
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link glyph-link" href="../../"><i class="icofont-laika home" title="Home">&#xef47;</i></a>

  <div class="row links">
    
    <a class="icon-link svg-link" href="https://github.com/typelevel/Laika"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link svg-link" href="https://javadoc.io/doc/org.typelevel/laika-docs_2.12/latest/laika/index.html"><span class="api" title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="../downloads.html"><i class="icofont-laika download" title="Download">&#xef08;</i></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="icon-link svg-link" href="https://github.com/typelevel/Laika"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link svg-link" href="https://javadoc.io/doc/org.typelevel/laika-docs_2.12/latest/laika/index.html"><span class="api" title="API"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M75,47.5c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm-50,-0c13.246,-0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,-0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm2.705,16.735l7.239,0l0.622,-4.904l-21.833,0l-0,4.904l7.589,0l0,22.067l6.383,0l-0,-22.067Zm58.076,7.265c-0,-8.757 -3.698,-14.166 -10.781,-14.166c-7.083,-0 -10.781,5.604 -10.781,14.166c0,8.757 3.698,14.166 10.781,14.166c7.083,0 10.781,-5.604 10.781,-14.166Zm-6.539,0c0,6.538 -1.128,9.496 -4.242,9.496c-2.997,0 -4.242,-2.88 -4.242,-9.496c-0,-6.616 1.206,-9.496 4.242,-9.496c3.036,-0 4.242,2.88 4.242,9.496Zm-29.242,-67c13.246,0 24,10.754 24,24c0,13.246 -10.754,24 -24,24c-13.246,0 -24,-10.754 -24,-24c0,-13.246 10.754,-24 24,-24Zm0.512,9.834c-7.122,-0 -12.609,5.098 -12.609,14.127c-0,9.263 5.215,14.205 12.532,14.205c4.164,0 7.083,-1.634 9.068,-3.658l-2.88,-3.697c-1.518,1.206 -3.153,2.413 -5.838,2.413c-3.697,-0 -6.266,-2.763 -6.266,-9.263c-0,-6.616 2.724,-9.379 6.149,-9.379c2.102,-0 3.892,0.778 5.371,1.984l3.113,-3.775c-2.257,-1.868 -4.748,-2.957 -8.64,-2.957Z"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="../downloads.html"><i class="icofont-laika download" title="Download">&#xef08;</i></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../table-of-content.html">Table of Content</a></li>
    <li class="level1 nav-leaf"><a href="../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-header">About Laika</li>
    <li class="level2 nav-leaf"><a href="../01-about-laika/01-features.html">Features</a></li>
    <li class="level2 nav-leaf"><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
    <li class="level1 nav-header">Running Laika</li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/01-sbt-plugin.html">sbt Plugin</a></li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/02-library-api.html">Library API</a></li>
    <li class="level2 nav-leaf"><a href="../02-running-laika/03-configuration.html">Configuration</a></li>
    <li class="level1 nav-header">Preparing Content</li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/03-theme-settings.html">Theme Settings</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
    <li class="level2 nav-leaf"><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
    <li class="level1 nav-header">Customizing Laika</li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/01-overview.html">Customizing Laika - Overview</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/03-creating-templates.html">Creating Templates</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/04-document-ast.html">The Document AST</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/05-ast-rewriting.html">AST Rewriting</a></li>
    <li class="level2 nav-leaf"><a href="../04-customizing-laika/06-overriding-renderers.html">Overriding Renderers</a></li>
    <li class="level1 nav-header">Extending Laika</li>
    <li class="level2 nav-leaf"><a href="01-overview.html">Extending Laika - Overview</a></li>
    <li class="level2 nav-leaf"><a href="02-creating-themes.html">Creating Themes</a></li>
    <li class="level2 nav-leaf"><a href="03-implementing-directives.html">Implementing Directives</a></li>
    <li class="level2 nav-leaf"><a href="04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
    <li class="level2 active nav-leaf"><a href="#">Adding Syntax Highlighters</a></li>
    <li class="level2 nav-leaf"><a href="07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
    <li class="level1 nav-header">Sub-Modules</li>
    <li class="level2 nav-leaf"><a href="../06-sub-modules/02-laikas-parser-combinators.html">Laika&#39;s Parser Combinators</a></li>
    <li class="level2 nav-leaf"><a href="../06-sub-modules/03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
    <li class="level1 nav-header">Reference</li>
    <li class="level2 nav-leaf"><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
    <li class="level2 nav-leaf"><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Adding Syntax Highlighters</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#design-goals">Design Goals</a></li>
    <li class="level1 nav-leaf"><a href="#prerequisites">Prerequisites</a></li>
    <li class="level1 nav-leaf"><a href="#the-syntaxhighlighter-trait">The SyntaxHighlighter Trait</a></li>
    <li class="level1 nav-node"><a href="#using-existing-building-blocks">Using Existing Building Blocks</a></li>
    <li class="level2 nav-leaf"><a href="#string-literals">String Literals</a></li>
    <li class="level2 nav-leaf"><a href="#character-literals">Character Literals</a></li>
    <li class="level2 nav-leaf"><a href="#numeric-literals">Numeric Literals</a></li>
    <li class="level2 nav-leaf"><a href="#identifiers">Identifiers</a></li>
    <li class="level2 nav-leaf"><a href="#keywords">Keywords</a></li>
    <li class="level2 nav-leaf"><a href="#comments">Comments</a></li>
    <li class="level1 nav-leaf"><a href="#defining-custom-parsers">Defining Custom Parsers</a></li>
    <li class="level1 nav-leaf"><a href="#embedding-other-languages">Embedding other Languages</a></li>
    <li class="level1 nav-leaf"><a href="#parser-precedence">Parser Precedence</a></li>
    <li class="level1 nav-leaf"><a href="#registering-a-highlighter">Registering a Highlighter</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/typelevel/Laika/tree/main/docs/src/05-extending-laika/06-adding-syntax-highlighters.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="adding-syntax-highlighters" class="title">Adding Syntax Highlighters</h1>
        <p>Laika has its own built-in syntax highlighters (based on its parser combinators). </p>
        <p>This manual itself is a showcase for this functionality. 
        All code samples shown are highlighted by Laika&#39;s own syntax support. </p>
        <p>This chapter explains the general design goals as well as the basic building blocks for adding your own highlighters.</p>
        
        <h2 id="design-goals" class="section"><a class="anchor-link left" href="#design-goals"><i class="icofont-laika link">&#xef71;</i></a>Design Goals</h2>
        <ul>
          <li>
            <p><strong>Everything is pluggable and customizable.</strong></p>
            <p>This includes making it easy to add support for additional languages as well as ignoring the built-in
            highlighter altogether and use external tools like <code>highlight.js</code> instead.</p>
          </li>
          <li>
            <p><strong>The mechanism is not tied to HTML output.</strong></p>
            <p>The analyzed code is part of the document AST and can be processed and transformed like other
            AST nodes before rendering, making it a part of the common processing pipeline and not a bolt-on step after rendering,
            that would require the availability of JavaScript for the rendered output for example.</p>
            <p>This way the highlighted nodes can be rendered in any output format like EPUB, PDF or any 3rd-party format.</p>
          </li>
          <li>
            <p><strong>Focus on display comfort over validation.</strong></p>
            <p>It&#39;s primary use case is documentation or blogs, where the highlighter is supposed to improve the readability
            of the code.
            It is not designed to serve as a basis for code editors or include error highlighting and messages.</p>
            <p>Therefore it is also beyond the scope of this utility to detect larger constructs like entire method signatures.
            In some languages like Java this would come with a lot of ambiguity as a method declaration does not start 
            with a keyword like <code>def</code>.
            It would require to get much closer to having a full blown lexer and analyzer for the language than this
            utility is designed for.</p>
            <p>As a consequence its syntax definitions are more similar in scope and precision to those of lightweight tools
            like <code>highlight.js</code> than to the lower-level nature of sublime-text syntax definitions for example.
            If validation is required the recommended approach in Laika is to rely on other tools like MDoc for Scala
            validation and then only use Laika for highlighting the result.</p>
          </li>
          <li>
            <p><strong>Avoiding the regular expression mazes of other tools.</strong></p>
            <p>It offers a lot of higher level building blocks for assembling highlighters for common constructs like 
            string or number literals which are often quite similar between languages.
            The definitions then become more of a declarative list of supported constructs.</p>
            <p>But even in cases where a custom parser is required, it encourages the use of Laika&#39;s built-in parser combinator 
            framework, 
            which is a more composable and type-safe way to define a parser than a cryptic (and stringly) regular expression.</p>
            <p>None of the built-in parsers for text markup, HOCON, CSS or syntax highlighting use any regular expressions.</p>
          </li>
        </ul>
        
        <h2 id="prerequisites" class="section"><a class="anchor-link left" href="#prerequisites"><i class="icofont-laika link">&#xef71;</i></a>Prerequisites</h2>
        <p>The content of this chapter builds on top of concepts introduced in other chapters.</p>
        <p>First, even though Laika&#39;s highlighting support defines a lot of higher level building blocks that
        allow for a mere declarative assembling of the supported constructs for a language,
        some additions of custom parsers might be necessary, depending on the complexity of the target language.
        In that case it&#39;s recommended to use <a href="../06-sub-modules/02-laikas-parser-combinators.html#laika-s-parser-combinators">Laika&#39;s Parser Combinators</a>.</p>
        <p>Second, highlighters produce a list of <code>CodeSpan</code> nodes which is one node type of Laika&#39;s document AST. 
        Even though this is usually the only node type you deal with, 
        it might help to get familiar with <a href="../04-customizing-laika/04-document-ast.html#the-document-ast">The Document AST</a> first.</p>
        
        <h2 id="the-syntaxhighlighter-trait" class="section"><a class="anchor-link left" href="#the-syntaxhighlighter-trait"><i class="icofont-laika link">&#xef71;</i></a>The SyntaxHighlighter Trait</h2>
        <p>These are the two abstract methods a new highlighter needs to implement:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">language</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">String</span><span>]

</span><span class="keyword">def</span><span> </span><span class="declaration-name">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>]</span></code></pre>
        <ul>
          <li>
            <p>The <code>language</code> property holds one or more names for the language that will be used to identify the language
            when syntax like fenced code blocks are used.</p>
            <p>Concretely this means that if you specify <code>python</code> and <code>py</code> as the names for example, 
            the implementation will be used for any fenced code block that starts with
            either <code>```py</code> or <code>```python</code>.</p>
            <p>It&#39;s not tied to Markdown syntax though. 
            reStructuredText has its own way of specifying a code block with language identifier, 
            and the highlighter will be used for those, too.</p>
          </li>
          <li>
            <p>The <code>spanParsers</code> property holds the actual parsers.
            Like with markup parsers they can be defined independently and then simply get listed in this trait.</p>
          </li>
        </ul>
        <p>Let&#39;s start by looking at how you can assemble these span parsers by using some of the building blocks for 
        common language constructs.</p>
        <p>We later look at how to add other constructs based on custom parsers.</p>
        
        <h2 id="using-existing-building-blocks" class="section"><a class="anchor-link left" href="#using-existing-building-blocks"><i class="icofont-laika link">&#xef71;</i></a>Using Existing Building Blocks</h2>
        <p>The building blocks shown in this section are meant to be used as shortcuts.
        Whenever they do not provide the exact syntax option that you need, 
        you can always fall back to <a href="#defining-custom-parsers">Defining Custom Parsers</a>.</p>
        <p>Our code examples in this section define highlighters for a Scala-ish language, 
        but omit many details for the sake of brevity.
        You can examine the source code of Laika&#39;s built-in highlighters for more complete examples.</p>
        
        <h3 id="string-literals" class="section"><a class="anchor-link left" href="#string-literals"><i class="icofont-laika link">&#xef71;</i></a>String Literals</h3>
        <p>There are shortcuts for defining single- and multi-line strings together with escape sequences:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="type-name">CodeSpanParser</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="identifier">common</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">StringLiteral</span><span>.</span><span class="identifier">multiLine</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;\&quot;\&quot;</span><span class="string-literal">&quot;</span><span>),
  </span><span class="type-name">StringLiteral</span><span>.</span><span class="identifier">singleLine</span><span>(</span><span class="char-literal">&#39;&quot;&#39;</span><span>).</span><span class="identifier">embed</span><span>(
    </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">unicode</span><span> ++ </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">char</span><span>
  )
)</span></code></pre>
        <p>The <code>multiline</code> and <code>singleLine</code> builders both require to specify the delimiter.
        When the start and end delimiter are identical you can use the single-argument overload.</p>
        <p>For a single line string we also define valid escape sequences which will be used
        to detect nested spans. 
        These are existing building blocks, too.</p>
        <p>There are additional escape options like octal and hex, as well as building blocks to define substitutions,
        e.g. Scala&#39;s <code>s&quot;some $ref&quot;</code> syntax.</p>
        
        <h3 id="character-literals" class="section"><a class="anchor-link left" href="#character-literals"><i class="icofont-laika link">&#xef71;</i></a>Character Literals</h3>
        <p>Character literals have fewer options than string literals, but are otherwise quite similar:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="type-name">CodeSpanParser</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="identifier">common</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">CharLiteral</span><span>.</span><span class="identifier">standard</span><span>.</span><span class="identifier">embed</span><span>(
    </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">unicode</span><span> ++ </span><span class="type-name">StringLiteral</span><span>.</span><span class="type-name">Escape</span><span>.</span><span class="identifier">char</span><span>
  )
)</span></code></pre>
        <p>The <code>standard</code> builder uses single quotes as delimiters, but you can specify a different one if required.
        Like with our string literal example, we define two kinds of escapes that can occur in a character literal.</p>
        
        <h3 id="numeric-literals" class="section"><a class="anchor-link left" href="#numeric-literals"><i class="icofont-laika link">&#xef71;</i></a>Numeric Literals</h3>
        <p>There are shortcuts for the most common types of decimal, hex, octal and binary number literals:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="type-name">CodeSpanParser</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="identifier">common</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">NumberLiteral</span><span>.</span><span class="identifier">hex</span><span>
    .</span><span class="identifier">withUnderscores</span><span>
    .</span><span class="identifier">withSuffix</span><span>(</span><span class="type-name">NumberLiteral</span><span>.</span><span class="identifier">suffix</span><span>.</span><span class="identifier">long</span><span>),
  </span><span class="type-name">NumberLiteral</span><span>.</span><span class="identifier">decimalInt</span><span>
    .</span><span class="identifier">withUnderscores</span><span>
    .</span><span class="identifier">withSuffix</span><span>(</span><span class="type-name">NumberLiteral</span><span>.</span><span class="identifier">suffix</span><span>.</span><span class="identifier">long</span><span> | </span><span class="type-name">NumberLiteral</span><span>.</span><span class="identifier">suffix</span><span>.</span><span class="identifier">float</span><span>)
)</span></code></pre>
        <p>Here we are defining two types of number literals: hexadecimal and decimal integers.</p>
        <p>In both cases we allow the use of underscores as separators (e.g. <code>1_000_000</code>).</p>
        <p>We also define which kinds of type indicators we allow as a suffix and again use 
        existing parsers for widely used syntax (<code>NumericSuffix.long</code> parses <code>L</code> or <code>l</code> for example).</p>
        
        <h3 id="identifiers" class="section"><a class="anchor-link left" href="#identifiers"><i class="icofont-laika link">&#xef71;</i></a>Identifiers</h3>
        <p>This is how the identifier category is defined for the Scala highlighter:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">identifier</span><span> = </span><span class="type-name">Identifier</span><span>.</span><span class="identifier">alphaNum</span><span>
  .</span><span class="identifier">withIdStartChars</span><span>(</span><span class="char-literal">&#39;_&#39;</span><span>,</span><span class="char-literal">&#39;$&#39;</span><span>)
  .</span><span class="identifier">withCategoryChooser</span><span>(</span><span class="type-name">Identifier</span><span>.</span><span class="identifier">upperCaseTypeName</span><span>)</span></code></pre>
        <p>It expects any alphanumerical identifier that is also allowed to have <code>_</code> or <code>$</code> as a start character.</p>
        <p>We then pass a function as a &quot;category chooser&quot; that assigns a category based on the parsed identifier.
        It is a very simple function that serves as a relatively useful approximation:
        it picks <code>CodeCategory.TypeName</code> when the identifier starts with an uppercase letter,
        otherwise it assigns <code>CodeCategory.Identifier</code>.</p>
        <p>This is obviously not always correct, but good enough for most use cases.
        As discussed in the design goals, this highlighting utility does not aim to get close to defining
        full lexers and parsers, and assigning the category correctly in all cases would require full context
        of the parsed construct. 
        Many highlighters you might be using with other tools are equally pragmatic.</p>
        
        <h3 id="keywords" class="section"><a class="anchor-link left" href="#keywords"><i class="icofont-laika link">&#xef71;</i></a>Keywords</h3>
        <p>Keywords can simply be listed as string literals:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">keywords</span><span> =
  </span><span class="type-name">Keywords</span><span>(</span><span class="string-literal">&quot;abstract&quot;</span><span>, </span><span class="string-literal">&quot;case&quot;</span><span>, </span><span class="string-literal">&quot;catch&quot;</span><span>, </span><span class="string-literal">&quot;class&quot;</span><span>, </span><span class="string-literal">&quot;def&quot;</span><span>)</span></code></pre>
        <p>It detects word boundaries so that it will not match on sub-strings.</p>
        <p>By default the parser will assign <code>CodeCategory.Keyword</code> to any matching string.
        If you want to use literal matches, but with a different code category, there is an alternative constructor:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="type-name">CodeCategory</span><span>

</span><span class="type-name">Keywords</span><span>(</span><span class="type-name">CodeCategory</span><span>.</span><span class="type-name">BooleanLiteral</span><span>)(</span><span class="string-literal">&quot;true&quot;</span><span>, </span><span class="string-literal">&quot;false&quot;</span><span>)</span></code></pre>
        
        <h3 id="comments" class="section"><a class="anchor-link left" href="#comments"><i class="icofont-laika link">&#xef71;</i></a>Comments</h3>
        <p>Shortcuts exist for defining single- and multi-line comments:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">Comment</span><span>.</span><span class="identifier">singleLine</span><span>(</span><span class="string-literal">&quot;//&quot;</span><span>),
  </span><span class="type-name">Comment</span><span>.</span><span class="identifier">multiLine</span><span>(</span><span class="string-literal">&quot;/*&quot;</span><span>, </span><span class="string-literal">&quot;*/&quot;</span><span>)
)</span></code></pre>
        <p>The code should be self-explanatory here, we simply define the delimiters for the comment syntax of our language.
        The single-line variant terminates at the end of the line.</p>
        
        <h2 id="defining-custom-parsers" class="section"><a class="anchor-link left" href="#defining-custom-parsers"><i class="icofont-laika link">&#xef71;</i></a>Defining Custom Parsers</h2>
        <p>The basic building blocks presented in the previous section help a lot with reducing boilerplate, 
        but in most cases you end up with the need to have at least a handful of hand-written parsers, too.</p>
        <p>For a little example, let&#39;s implement a highlighter for Scala&#39;s backtick identifiers (e.g. <code>`tag-name`</code>)
        which is quite straightforward, but not included in the reusable builders since it&#39;s not a very common construct:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">builders</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="type-name">CodeCategory</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">backtickId</span><span>: </span><span class="type-name">CodeSpanParser</span><span> = </span><span class="type-name">CodeSpanParser</span><span>(</span><span class="type-name">CodeCategory</span><span>.</span><span class="type-name">Identifier</span><span>) {
    (</span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;`&#39;</span><span>) ~ </span><span class="identifier">anyNot</span><span>(</span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;`&#39;</span><span>) ~ </span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;`&#39;</span><span>)).</span><span class="identifier">source</span><span>
  }</span></code></pre>
        <p>In the first line of the definition we specify the category that should be assigned to the result of the parser.</p>
        <p>The next line is a standard parser definition using some of the building blocks of <a href="../06-sub-modules/02-laikas-parser-combinators.html#laika-s-parser-combinators">Laika&#39;s Parser Combinators</a>.
        We simply expect a backtick as the start and end delimiter and allow anything in-between apart from newline or
        backtick characters.</p>
        <p>The call to <code>.source</code> is a convenient shortcut that discards the result of the three parsers and instead
        provides the source of the entire input consumed by those three parsers as the result. 
        This is often preferable when all we would do with the three results would be to concatenate them back to one string.</p>
        <p>The code parser we now defined can then be registered in our <code>spanParsers</code> sequence like in all other examples.</p>
        <p>The entry point above is just one option.
        It&#39;s only appropriate if we provide a string parser and want the same category assigned to the entire string.</p>
        <p>There is an alternative factory method, where we specify a <code>PrefixedParser[Seq[CodeSpan]]</code> 
        where we have full control over how we slice the input into multiple categories.</p>
        
        <h2 id="embedding-other-languages" class="section"><a class="anchor-link left" href="#embedding-other-languages"><i class="icofont-laika link">&#xef71;</i></a>Embedding other Languages</h2>
        <p>In some cases a language or format may have regions that require a highlighter for a different syntax.
        A classic example is HTML which may have CSS syntax inside a <code>&lt;style&gt;</code> tag and JavaScript syntax inside
        a <code>&lt;script&gt;</code> tag.</p>
        <p>Laika comes with a parser builder that helps with the creation of such a parser.</p>
        <p>Let&#39;s pick CSS in HTML as an example and show a simplified definition for a such a style tag:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">ast</span><span>.</span><span class="type-name">CodeSpan</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">builders</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="type-name">CodeCategory</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="identifier">common</span><span>.</span><span class="type-name">EmbeddedCodeSpans</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="identifier">languages</span><span>.</span><span class="type-name">CSSSyntax</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">text</span><span>.</span><span class="type-name">PrefixedParser</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">styleTagParser</span><span>: </span><span class="type-name">PrefixedParser</span><span>[</span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpan</span><span>]] = {
  </span><span class="keyword">val</span><span> </span><span class="identifier">cat</span><span> = </span><span class="type-name">CodeCategory</span><span>.</span><span class="type-name">Tag</span><span>.</span><span class="type-name">Name</span><span>
  </span><span class="keyword">val</span><span> </span><span class="identifier">bodyAndEndTag</span><span> = 
    </span><span class="type-name">EmbeddedCodeSpans</span><span>.</span><span class="identifier">parser</span><span>(</span><span class="identifier">delimitedBy</span><span>(</span><span class="string-literal">&quot;&lt;/style&gt;&quot;</span><span>), </span><span class="type-name">CSSSyntax</span><span>)
    
  (</span><span class="identifier">literal</span><span>(</span><span class="string-literal">&quot;&lt;style&gt;&quot;</span><span>) ~&gt; </span><span class="identifier">bodyAndEndTag</span><span>).</span><span class="identifier">map</span><span> { </span><span class="identifier">css</span><span> =&gt;
    </span><span class="type-name">CodeSpan</span><span>(</span><span class="string-literal">&quot;&lt;style&gt;&quot;</span><span>, </span><span class="identifier">cat</span><span>) +: </span><span class="identifier">css</span><span> :+ </span><span class="type-name">CodeSpan</span><span>(</span><span class="string-literal">&quot;&lt;/style&gt;&quot;</span><span>, </span><span class="identifier">cat</span><span>)
  }
}</span></code></pre>
        <p>The key here is the third line.
        We define a region to parse with <code>delimitedBy(&quot;&lt;/style&gt;&quot;)</code> which consumes text until it sees the specified
        end delimiter. See <a href="../06-sub-modules/02-laikas-parser-combinators.html#delimiters">Delimiters</a> for details.
        And we specify the syntax to switch to until we reach that delimiter, in this case the existing <code>CSSSyntax</code></p>
        <p>The result (the <code>css</code> param) is of type <code>Seq[CodeSpan]</code>, containing the spans detected by the CSS highlighter.
        We then wrap the code spans for the start tag and end tag around it for the final result.</p>
        <p>One of the simplifications to keep the example simple is that we assign the category <code>CodeCategory.Tag.Name</code>
        to the entire tag, including the angle brackets.
        Normally you would keep them separate under <code>CodeCategory.Tag.Punctuation</code>.</p>
        
        <h2 id="parser-precedence" class="section"><a class="anchor-link left" href="#parser-precedence"><i class="icofont-laika link">&#xef71;</i></a>Parser Precedence</h2>
        <p>The precedence rules are identical to those for declaring markup parsers.</p>
        <p>The parser precedence is determined by the order you specify them in.
        This means they will be &quot;tried&quot; on input in that exact order.
        The second parser in the list will only be invoked on a particular input when the first fails, and so on.</p>
        <p>This is the logical execution model only, the exact runtime behaviour may differ due to performance optimizations,
        but without breaking the guarantees of respecting the order you specify.</p>
        <p>In many cases the difference in the syntax between constructs is high enough that the precedence does not matter.
        But in some cases extra care is needed.</p>
        <p>If, for example, you provide a parser for a span delimited by one or two occurrences of the same character,
        the two-character version must be specified first, as otherwise the parser with the single-character delimiter 
        would 100% shadow the double one and consume all matching input itself, unless it contains a guard against it.</p>
        <p>Similarly, parsers like those for identifiers which do not have a limited set of start delimiters 
        usually need to occur near the bottom of the list of parsers you register.</p>
        
        <h2 id="registering-a-highlighter" class="section"><a class="anchor-link left" href="#registering-a-highlighter"><i class="icofont-laika link">&#xef71;</i></a>Registering a Highlighter</h2>
        <p>First you have to assemble all the parsers in a <code>SyntaxHighlighter</code> implementation:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">data</span><span>.</span><span class="type-name">NonEmptyList</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">api</span><span>.</span><span class="identifier">bundle</span><span>.</span><span class="type-name">SyntaxHighlighter</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">parse</span><span>.</span><span class="identifier">code</span><span>.</span><span class="type-name">CodeSpanParser</span><span>

</span><span class="keyword">object</span><span> </span><span class="type-name">FooHighlighter</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">SyntaxHighlighter</span><span> {

  </span><span class="keyword">val</span><span> </span><span class="identifier">language</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="type-name">NonEmptyList</span><span>.</span><span class="identifier">one</span><span>(</span><span class="string-literal">&quot;foo&quot;</span><span>)
  
  </span><span class="keyword">val</span><span> </span><span class="identifier">spanParsers</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">CodeSpanParser</span><span>] = </span><span class="type-name">Seq</span><span>(
    </span><span class="comment">// all your definitions here
</span><span>  )

}</span></code></pre>
        <p>Finally, like all other types of extensions, the highlighter needs to be registered with an <code>ExtensionBundle</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">api</span><span>.</span><span class="identifier">bundle</span><span>.{ </span><span class="type-name">ExtensionBundle</span><span>, </span><span class="type-name">ParserBundle</span><span> }

</span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">MyExtensions</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ExtensionBundle</span><span> {
  
  </span><span class="keyword">val</span><span> </span><span class="identifier">description</span><span>: </span><span class="type-name">String</span><span> = </span><span class="string-literal">&quot;Foo Syntax Highlighter&quot;</span><span>
  
  </span><span class="keyword">override</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">parsers</span><span>: </span><span class="type-name">ParserBundle</span><span> = </span><span class="keyword">new</span><span> </span><span class="type-name">ParserBundle</span><span>(
    </span><span class="identifier">syntaxHighlighters</span><span> = </span><span class="type-name">Seq</span><span>(
      </span><span class="type-name">FooHighlighter</span><span>
    )
  )
}</span></code></pre>
        <p>You can bundle multiple highlighters in a single instance.</p>
        <p>Finally, you can register your extension together with any built-in extensions you may use:</p>
        <div class="tab-container" data-tab-group="config">
          <ul class="tab-group">
            <li class="tab active" data-choice-name="sbt"><a href="#">sbt Plugin</a></li>
            <li class="tab" data-choice-name="library"><a href="#">Library API</a></li>
          </ul>
          <div class="tab-content active" data-choice-name="sbt">
            <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">format</span><span>.</span><span class="type-name">Markdown</span><span>

</span><span class="identifier">laikaExtensions</span><span> := </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">Markdown</span><span>.</span><span class="type-name">GitHubFlavor</span><span>,
  </span><span class="type-name">MyExtensions</span><span>
)</span></code></pre>
          </div>
          <div class="tab-content" data-choice-name="library">
            <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">api</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">format</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">Markdown</span><span>.</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyExtensions</span><span>)
  .</span><span class="identifier">build</span></code></pre>
          </div>
        </div>

        
<hr class="footer-rule"/>
<footer>
  Site generated by <a href="https://typelevel.org/Laika/">Laika</a> with the Helium theme.
</footer>


      </main>

    </div>

  </body>

</html>