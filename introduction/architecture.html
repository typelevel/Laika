<div>
  <!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="intro.html">Overview</a></li>
          <li class="active"><a href="#">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using Laika Embedded</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
          <h1>Architecture</h1>
        </div>
        <p>This page aims to give a very high level overview of the inner workings of Laika.</p>
        <p>Understanding the architecture of the toolkit is not required for basic usage.
        However if you intend to extend Laika, contribute to it, or if you are simply
        curious, then read on.</p>
        
        <h2 id="design-principles" class="section">Design Principles</h2>
        <ul>
          <li>
            <p>Fully decouple the aspects of input/output, parsing, rendering, templating and document tree rewriting, 
            making each of these steps pluggable.</p>
          </li>
          <li>
            <p>Provide a very convenient and simple high level API for common transformation tasks.</p>
          </li>
          <li>
            <p>Build a generic document tree model that does not reflect specifics of a particular 
            supported markup language like Markdown or reStructuredText.</p>
          </li>
          <li>
            <p>Allow for easy modification of the rendering for a particular node type only, without
            the need to sub-class or modify an existing renderer.</p>
          </li>
          <li>
            <p>Allow customization of rewrite rules for transforming the document tree before rendering
            (e.g for resolving cross-references).</p>
          </li>
          <li>
            <p>Provide concise and type-safe extension APIs for extensible markup definitions.</p>
          </li>
          <li>
            <p>Create the built-in parsers with the Scala parser combinators, providing efficient and
            reusable base parsers that encapsulate requirements common to all lightweight markup languages,
            while keeping the basic contract for plugging in a new parser function as simple and generic as 
            <code>Input =&gt; Document</code>, so that other parser frameworks or tools can be used, too.</p>
          </li>
          <li>
            <p>Designed for robustness: Laika has more than 600 tests, it is protected against malicious
            or accidentally malformed input like endless recursion (a type of guard most other text markup 
            parsers do not include) and parsers like the URI parser are based on the actual relevant RFCs
            (and not just a rough approximation like in many other parsers). </p>
          </li>
        </ul>
        
        <h2 id="transformation-flow" class="section">Transformation Flow</h2>
        <p><img src="../img/architecture.png" alt="Internal Architecture"></p>
        <p>This diagram shows the major phases of a transformation with extension hooks shown as little
        red boxes:</p>
        <ul>
          <li>
            <p><code>Input</code> and <code>Output</code> are just little IO abstractions, so that the other parts of the system
            do not need to deal with the low-level details of where to read from and to write to. The toolkit
            supports files, strings and streams, writers and readers from <code>java.io</code>.</p>
          </li>
          <li>
            <p><code>Parse</code> represents the actual parsing step, a pluggable function of type <code>Input =&gt; Document</code> 
            (or `Input =&gt; TemplateDocument for templates).
            Supported out of the box are Markdown and reStructuredText. Other parsers can easily be added
            to the system and they do not need to be based on the SDK&#39;s parser combinators like the built-in
            parsers. Parsers can be extended with custom tags called Directives that allow to add new
            constructs to markup without extending the parser.</p>
          </li>
          <li>
            <p><code>Rewrite</code> is a customizable step for transforming the document tree model before rendering.
            There is always a default rewrite step involved, that looks for nodes in the model that need
            to be resolved, like link references, footnote references, etc. But custom rules can be added
            based on a partial function that deals with specific node types only.</p>
          </li>
          <li>
            <p>The <code>Merge</code> step finally combines the rewritten document tree originating from text markup
            with the document tree from the template, based on the directives used in the template.
            It is basically just a merge of two trees consisting of case classes. The use of templates
            is optional, so this step may get skipped.</p>
          </li>
          <li>
            <p><code>Render</code> is the final render step. Currently supported out of the box are HTML and PrettyPrint,
            the latter visualizing the document tree for debugging purposes. Planned for future releases
            are support for PDF, DocBook and epub. Like with the rewrite step, the entire renderer can be replaced
            by a custom one, or an existing one can customized based on a partial function that deals with
            specific node types only.</p>
          </li>
        </ul>      

      </div>
    </div>

  </div>


    <!-- javascript
    ================================================== -->
    <script src="../js/jquery-1.8.3.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>


</body></html>
</div>