<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="img/laika-top.png"/></div>
          <li class="nav-header">Introduction</li>
          <li><a href="index.html#top">Getting Started</a></li>
          <li><a href="index.html#features">Features</a></li>
          <li><a href="index.html#road-map">Road Map</a></li>
          <li><a href="index.html#design-principles">Design Principles</a></li>
          <li><a href="index.html#release-history">Release History</a></li>
          
          <li class="nav-header">Transformation Basics</li>
          <li><a href="basics.html#top">Transform API</a></li>
          <li><a href="basics.html#parse">Parse API</a></li>
          <li><a href="basics.html#render">Render API</a></li>
          
          <li class="nav-header">Supported Markup</li>
          <li><a href="markup.html#top">Markdown</a></li>
          <li><a href="markup.html#rst">reStructuredText</a></li>
          
          <li class="nav-header">Customizing Renderers</li>
          <li class="active"><a href="#top">Using the Transform API</a></li>
          <li><a href="#render">Using the Render API</a></li>
          <li><a href="#writer">The Writer APIs</a></li>
          
          <li class="nav-header">Document Tree Rewriting</li>
          <li><a href="tree-rewriting.html#top">Using the rewrite Method</a></li>
          <li><a href="tree-rewriting.html#transform">Using the Transform API</a></li>
          
          <li class="nav-header">Implementing a Parser</li>
          <li><a href="parser.html#top">Providing an API</a></li>
          <li><a href="parser.html#markup-parsers">Trait MarkupParsers</a></li>
          <li><a href="parser.html#inline-parsers">Trait InlineParsers</a></li>
          <li><a href="parser.html#block-parsers">Trait BlockParsers</a></li>
          
          <li class="nav-header">Implementing a Renderer</li>
          <li><a href="renderer.html#top">Providing an API</a></li>
          <li><a href="renderer.html#function">The Render Function</a></li>
          <div class="nav-bottom"><img src="img/laika-bottom.png" border="1"/></div>
        </ul>
      </div>
      
      
      
      
      <div class="span8" id="top">

        <div>
  <div class="page-header">
    <h1>Customizing Renderers</h1>
  </div>
  <p>In some cases you might want to override the output of a renderer for a few types
  of document tree nodes only, while keeping the default for the rest. Both the
  Transform and Render APIs offer a hook to easily do that without modifying
  or extending the existing renderer. </p>
  <p>This is the signature of a custom renderer hook:</p>
  <pre>W =&gt; PartialFunction[Element,Unit]
</pre>
  <p><code>W</code> is a generic type representing the writer API which is different for each 
  output format. For HTML it is <code>HTMLWriter</code>, for PrettyPrint it is <code>TextWriter</code>,
  a superclass of <code>HTMLWriter</code>. This way renderers can offer the most convenient
  API for a specific output format.</p>
  <p>Creating a function that expects a writer instance and returns the actual custom
  render function in form of a partial function allows to &apos;capture&apos; the writer
  in a concise way like the examples below will show.</p>
  <h2 id="transform">Using the Transform API</h2>
  <p>In the following example only the HTML output for emphasized text will be modified,
  adding a specific style class:</p>
  <pre>val open = &quot;&quot;&quot;&lt;em class=&quot;big&quot;&gt;&quot;&quot;&quot;
val close = &quot;&lt;/em&gt;&quot;

Transform from Markdown to HTML rendering { out =&gt; 
  { case Emphasized(content, _) =&gt; out &lt;&lt; open &lt;&lt; content &lt;&lt; close } 
} fromFile &quot;hello.md&quot; toFile &quot;hello.html&quot;
</pre>
  <p>For HTML <code>out</code> is of type <code>HTMLWriter</code> and <code>&lt;&lt;</code> is one of the methods to append text.</p>
  <p>For all node types where the partial function is not defined, the default renderer
  will be used.</p>
  <p>Multiple custom renderers can be specified, they will be tried in the order you added
  them, falling back to the default in case none is defined for a specific node.</p>
  <p>The <code>content</code> value above is of type <code>Seq[Span]</code>. <code>&lt;&lt;</code> and other methods of the
  <code>HTMLWriter</code> API are overloaded and accept <code>String</code>, <code>Element</code> or <code>Seq[Element]</code> 
  as a parameter, with <code>Element</code> being the abstract base type of all tree nodes.
  This way rendering child elements can be delegated to other renderers, either another
  custom renderer or the default. In almost all cases, a custom renderer should not render
  the children of a node passed to the function itself.</p>
  <h2 id="render">Using the Render API</h2>
  <p>The principles are the same as described for the Transform API above, in case you
  skipped the previous section. </p>
  <p>The syntax is very similar, applying the same renderer as in the example above
  with the Render API looks like this:</p>
  <pre>val doc: Document = ...

val open = &quot;&quot;&quot;&lt;em class=&quot;big&quot;&gt;&quot;&quot;&quot;
val close = &quot;&lt;/em&gt;&quot;

Render as HTML using { out =&gt; 
  { case Emphasized(content, _) =&gt; out &lt;&lt; open &lt;&lt; content &lt;&lt; close } 
} from doc toString

</pre>
  <h2 id="writer">The Writer APIs</h2>
  <p>In the examples above we only needed the basic <code>&lt;&lt;</code> method. This secion provides
  an overview over the full API.</p>
  <p>Btw: in case you do not fancy operators as method names, the writer APIs are the only ones
  in Laika making use of them. It turned out to improve readability for most common
  scenarios where you have to chain lots of elements, often including indentation
  and newline characters for making the output prettier. There are not that many,
  so it should be easy to memorize them.</p>
  <p>Writers differ from all other Laika objects in that they are stateful. But the
  only state they keep internally is the current level of indentation for prettier
  output which greatly simplifies the use of the API for rendering elements
  recursively. A new writer instance is created for each render operation,
  so there is no need to share it between threads.<br></p>
  
  <h3>TextWriter</h3>
  <p>This is the base API supported by both the <code>PrettyPrint</code> and <code>HTML</code> renderer,
  while the latter adds a few additional methods specific to HTML.</p>
  <p>All methods below are overloaded and accept <code>String</code>, <code>Element</code> or <code>Seq[Element]</code> 
  as a parameter, with <code>Element</code> being the abstract base type of all tree nodes.
  When passing Elements to the writer it will delegate to the renderers responsible
  for those nodes.</p>
  <ul>
    <li>
      <p><code>&lt;&lt;</code> appends to the output on the current line.</p>
    </li>
    <li>
      <p><code>&lt;&lt;|</code> appends to the output on a new line, with the current level of indentation</p>
    </li>
    <li>
      <p><code>&lt;&lt;|&gt;</code> appends to the output on a new line, increasing indentation one level to the right</p>
    </li>
  </ul>
  <p>When using the last method with Element instances which might themselves delegate
  rendering of their children, you get a nicely formatted output without much effort.</p>
  
  <h3>HTMLWriter</h3>
  <p>This writer supports all methods of the <code>TextWriter</code> API shown above, and adds
  the following methods:</p>
  <ul>
    <li>
      <p>For the three methods above, there is a variant that replaces special HTML
      characters with HTML entities and should be used for writing text nodes. They
      are named <code>&lt;&lt;&amp;</code>, <code>&lt;&lt;|&amp;</code> and <code>&lt;&lt;|&gt;&amp;</code> and otherwise behave the same as their
      counterparts without the <code>&amp;</code>.</p>
    </li>
    <li>
      <p>The <code>&lt;&lt;&lt;&amp;</code> method does not have a counterpart without <code>&amp;</code>. Like the others
      it replaces special HTML characters, but it writes without any indentation,
      no matter which level of indentation the writer currently has,
      which is needed for writing nodes like <code>&lt;pre&gt;</code> where indentation would be
      significant. </p>
    </li>
    <li>
      <p>The <code>&lt;&lt;@</code> method is a convenient way to write an HTML attribute. It is overloaded
      and either takes <code>(String, String)</code> or <code>(String, Option[String])</code> as parameters
      for name and value of the attribute. If the value is None, nothing will be written,
      but it often makes writing optional attributes more concise.</p>
    </li>
  </ul>
</div>        

      </div>
    </div>

  </div>


    <!-- javascript
    ================================================== -->
    <script src="js/jquery-1.8.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>


</body></html>