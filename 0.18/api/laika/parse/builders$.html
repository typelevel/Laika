<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../lib/index.js"></script>
      <script type="text/javascript" src="../../index.js"></script>
      <script type="text/javascript" src="../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="../../laika/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.code" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="code"></a><a id="code:code"></a>
      <span class="permalink">
      <a href="../../laika/parse/code/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="code/index.html"><span class="name">code</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.combinator" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="combinator"></a><a id="combinator:combinator"></a>
      <span class="permalink">
      <a href="../../laika/parse/combinator/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="combinator/index.html"><span class="name">combinator</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.css" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="css"></a><a id="css:css"></a>
      <span class="permalink">
      <a href="../../laika/parse/css/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="css/index.html"><span class="name">css</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.directive" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="directive"></a><a id="directive:directive"></a>
      <span class="permalink">
      <a href="../../laika/parse/directive/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="directive/index.html"><span class="name">directive</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.hocon" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hocon"></a><a id="hocon:hocon"></a>
      <span class="permalink">
      <a href="../../laika/parse/hocon/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="hocon/index.html"><span class="name">hocon</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.markup" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markup"></a><a id="markup:markup"></a>
      <span class="permalink">
      <a href="../../laika/parse/markup/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="markup/index.html"><span class="name">markup</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.text" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text"></a><a id="text:text"></a>
      <span class="permalink">
      <a href="../../laika/parse/text/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="text/index.html"><span class="name">text</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.uri" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="uri"></a><a id="uri:uri"></a>
      <span class="permalink">
      <a href="../../laika/parse/uri/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="uri/index.html"><span class="name">uri</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li class="current-entities indented2">
                        <a class="object" href="BlockSource$.html" title="Companion for creating BlockSource instances."></a>
                        <a class="class" href="BlockSource.html" title="A block source represents the source for a block level element where each individual line might have a different x-offset to the root source."></a>
                        <a href="BlockSource.html" title="A block source represents the source for a block level element where each individual line might have a different x-offset to the root source.">BlockSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Failure$.html" title=""></a>
                        <a class="class" href="Failure.html" title="The failure case of Parsed containing an error message and the remaining input."></a>
                        <a href="Failure.html" title="The failure case of Parsed containing an error message and the remaining input.">Failure</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="GeneratedSource$.html" title="Represents a generated source, where an AST node has been created programmatically and cannot be traced back to the corresponding input source."></a>
                        <a href="GeneratedSource$.html" title="Represents a generated source, where an AST node has been created programmatically and cannot be traced back to the corresponding input source.">GeneratedSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="LineSource$.html" title="Companion for creating LineSource instances."></a>
                        <a class="class" href="LineSource.html" title="A line source represents all or part of a single line from the root input source."></a>
                        <a href="LineSource.html" title="A line source represents all or part of a single line from the root input source.">LineSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Message$.html" title="Message companion providing several pre-built messages and factory methods."></a>
                        <a class="trait" href="Message.html" title="Represents a lazy failure message."></a>
                        <a href="Message.html" title="Represents a lazy failure message.">Message</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Parsed.html" title="Represents the result of a Parser, a value of type T in case of success, a message in case of failure as well as the SourceCursor for the remaining input."></a>
                        <a href="Parsed.html" title="Represents the result of a Parser, a value of type T in case of success, a message in case of failure as well as the SourceCursor for the remaining input.">Parsed</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Parser$.html" title="Companion factory for creating new parser instances."></a>
                        <a class="class" href="Parser.html" title="The abstract base for all parser implementations."></a>
                        <a href="Parser.html" title="The abstract base for all parser implementations.">Parser</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Position.html" title="Represents an offset into a source string."></a>
                        <a href="Position.html" title="Represents an offset into a source string.">Position</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="RootSource.html" title="A root source represents the full input string of a parsing operation."></a>
                        <a href="RootSource.html" title="A root source represents the full input string of a parsing operation.">RootSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="SourceCursor$.html" title="Companion for creating new SourceCursor instances."></a>
                        <a class="trait" href="SourceCursor.html" title="Represents the state and context of a parsing operation, containing the input string as well as positional information."></a>
                        <a href="SourceCursor.html" title="Represents the state and context of a parsing operation, containing the input string as well as positional information.">SourceCursor</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="SourceFragment.html" title="Represents any source cursor other than the root cursor and it is mandated by some APIs that solely deal with recursive parsing where the root input will never be used as the source for the parser."></a>
                        <a href="SourceFragment.html" title="Represents any source cursor other than the root cursor and it is mandated by some APIs that solely deal with recursive parsing where the root input will never be used as the source for the parser.">SourceFragment</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Success.html" title="The success case of Parsed containing the result and the remaining input."></a>
                        <a href="Success.html" title="The success case of Parsed containing the result and the remaining input.">Success</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="" title="Grouping of all parser builders that allows to construct most common parsers with a single import."></a>
                        <a href="" title="Grouping of all parser builders that allows to construct most common parsers with a single import.">builders</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="implicits$.html" title="Collection of extension methods that helps keeping parser definitions concise."></a>
                        <a href="implicits$.html" title="Collection of extension methods that helps keeping parser definitions concise.">implicits</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="object value">
      <div id="definition">
        <div class="big-circle object">o</div>
        <p id="owner"><a href="../index.html" class="extype" name="laika">laika</a>.<a href="index.html" class="extype" name="laika.parse">parse</a></p>
        <h1>builders<span class="permalink">
      <a href="../../laika/parse/builders$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">builders</span><span class="result"> extends <a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a> with <a href="markup/InlineParsers.html" class="extype" name="laika.parse.markup.InlineParsers">InlineParsers</a> with <a href="markup/BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Grouping of all parser builders that allows to construct most common parsers with a single import.</p><p>These include the base parsers like <code>opt</code> and <code>not</code>, the text parsers like <code>literal</code> and <code>anyOf(Char*)</code>,
as well as the more specialized parsers for text markup like <code>spans</code> and <code>blocks</code>.</p><p>Alternatively these groups can be brought into scope individually.
</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="markup/BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a>, <a href="markup/InlineParsers.html" class="extype" name="laika.parse.markup.InlineParsers">InlineParsers</a>, <a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a>, <a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="laika.parse.builders"><span>builders</span></li><li class="in" name="laika.parse.markup.BlockParsers"><span>BlockParsers</span></li><li class="in" name="laika.parse.markup.InlineParsers"><span>InlineParsers</span></li><li class="in" name="laika.parse.text.TextParsers"><span>TextParsers</span></li><li class="in" name="laika.parse.combinator.Parsers"><span>Parsers</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="laika.parse.combinator.Parsers.ParserException" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ParserExceptionextendsRuntimeExceptionwithProductwithSerializable"></a><a id="ParserException:ParserException"></a>
      <span class="permalink">
      <a href="../../laika/parse/combinator/Parsers$ParserException.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="" href="combinator/Parsers$ParserException.html"><span class="name">ParserException</span></a><span class="params">(<span name="result">result: <a href="Failure.html" class="extype" name="laika.parse.Failure">Failure</a></span>)</span><span class="result"> extends <span class="extype" name="scala.RuntimeException">RuntimeException</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers.TryOps" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TryOps[A]extendsAnyRef"></a><a id="TryOps[A]:TryOps[A]"></a>
      <span class="permalink">
      <a href="../../laika/parse/combinator/Parsers$TryOps.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides additional methods to Try via implicit conversion." href="combinator/Parsers$TryOps.html"><span class="name">TryOps</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides additional methods to <code>Try</code> via implicit conversion.</p><div class="fullcomment"><div class="comment cmt"><p>Provides additional methods to <code>Try</code> via implicit conversion.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#anyChars" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyChars:laika.parse.text.Characters[String]"></a><a id="anyChars:Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#anyChars:laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">anyChars</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any kind of input, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any kind of input, always succeeds.
 This parser would consume the entire input unless a <code>max</code> constraint
 is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#anyNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]"></a><a id="anyNot(NonEmptySet[Char]):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#anyNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences that are not one of the specified characters.
Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#anyNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyNot(char:Char,chars:Char*):laika.parse.text.Characters[String]"></a><a id="anyNot(Char,Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#anyNot(char:Char,chars:Char*):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#anyOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]"></a><a id="anyOf(NonEmptySet[Char]):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#anyOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#anyOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(char:Char,chars:Char*):laika.parse.text.Characters[String]"></a><a id="anyOf(Char,Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#anyOf(char:Char,chars:Char*):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#anyWhile" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]"></a><a id="anyWhile((Char)⇒Boolean):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#anyWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters which satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters which satisfy the specified predicate.
Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#atStart" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="atStart:laika.parse.Parser[Unit]"></a><a id="atStart:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#atStart:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">atStart</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the start of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the start of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#blankLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blankLine:laika.parse.Parser[String]"></a><a id="blankLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#blankLine:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLine</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a blank line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a blank line from the current input offset (which may not be at the
 start of the line). Fails for lines that contain any non-whitespace character.
 Does always produce an empty string as the result, discarding any whitespace
 characters found in the line.</p><p> Since it also succeeds at the end of the input
 it should never be used in the form of <code>(blankLine *)</code> or <code>(blankLine +)</code>. Use
 the <code>blankLines</code> parser instead in these cases.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#blankLines" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blankLines:laika.parse.Parser[List[String]]"></a><a id="blankLines:Parser[List[String]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#blankLines:laika.parse.Parser[List[String]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLines</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Parses one or more blank lines, producing a list of empty strings corresponding
to the number of blank lines consumed.</p><div class="fullcomment"><div class="comment cmt"><p>Parses one or more blank lines, producing a list of empty strings corresponding
to the number of blank lines consumed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.markup.BlockParsers#block" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="block(firstLinePrefix:laika.parse.Parser[Any],linePrefix:=&gt;laika.parse.Parser[Any],nextBlockPrefix:=&gt;laika.parse.Parser[Any]):laika.parse.Parser[laika.parse.BlockSource]"></a><a id="block(Parser[Any],⇒Parser[Any],⇒Parser[Any]):Parser[BlockSource]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#block(firstLinePrefix:laika.parse.Parser[Any],linePrefix:=&gt;laika.parse.Parser[Any],nextBlockPrefix:=&gt;laika.parse.Parser[Any]):laika.parse.Parser[laika.parse.BlockSource]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">block</span><span class="params">(<span name="firstLinePrefix">firstLinePrefix: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="linePrefix">linePrefix: ⇒ <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="nextBlockPrefix">nextBlockPrefix: ⇒ <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="BlockSource.html" class="extype" name="laika.parse.BlockSource">BlockSource</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a full block based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full block based on the specified helper parsers.</p><p>The result of this parser will not contain the characters consumed by any of the specified prefix
parsers.
The block source returned by this method maintains x-offsets for each individual line so that it can be
passed down to recursive block or span parsers without losing position tracking.
</p></div><dl class="paramcmts block"><dt class="param">firstLinePrefix</dt><dd class="cmt"><p>parser that recognizes the start of the first line of this block</p></dd><dt class="param">linePrefix</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">nextBlockPrefix</dt><dd class="cmt"><p>parser that recognizes whether a line after one or more blank lines still belongs to the same block</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="markup/BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.markup.BlockParsers#block" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="block(firstLinePrefix:laika.parse.Parser[Any],linePrefix:=&gt;laika.parse.Parser[Any]):laika.parse.Parser[laika.parse.BlockSource]"></a><a id="block(Parser[Any],⇒Parser[Any]):Parser[BlockSource]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#block(firstLinePrefix:laika.parse.Parser[Any],linePrefix:=&gt;laika.parse.Parser[Any]):laika.parse.Parser[laika.parse.BlockSource]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">block</span><span class="params">(<span name="firstLinePrefix">firstLinePrefix: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="linePrefix">linePrefix: ⇒ <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="BlockSource.html" class="extype" name="laika.parse.BlockSource">BlockSource</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a full block based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full block based on the specified helper parsers.</p><p>The string result of this parser will not contain the characters consumed by any of the specified prefix
parsers.
</p></div><dl class="paramcmts block"><dt class="param">firstLinePrefix</dt><dd class="cmt"><p>parser that recognizes the start of the first line of this block</p></dd><dt class="param">linePrefix</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="markup/BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#consumeAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="consumeAll[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="consumeAll[T](Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#consumeAll[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">consumeAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.consumeAll.T">T</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.consumeAll.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that succeeds if the specified parser succeeds and all input has been consumed.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that succeeds if the specified parser succeeds and all input has been consumed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimitedBy(delimiter:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimitedText"></a><a id="delimitedBy(PrefixedParser[String]):DelimitedText"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#delimitedBy(delimiter:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="delimiter">delimiter: <a href="text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="text/DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until the specified delimiter parser
succeeds on the input.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters until the specified delimiter parser
succeeds on the input.</p><p>This constructor is limited to the sub-trait <code>PrefixedParser</code>
as only those can be optimized for an assertion that needs to be performed on each
character. Most parsers for non-empty text implement this trait, e.g <code>oneOf</code>, <code>someOf</code>,
<code>delimiter</code> or the literal parsers for a character or string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimitedBy(str:String):laika.parse.text.DelimitedText"></a><a id="delimitedBy(String):DelimitedText"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#delimitedBy(str:String):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="str">str: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="text/DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until the specified string delimiter
is encountered on the input string.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters until the specified string delimiter
is encountered on the input string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimitedBy(chars:cats.data.NonEmptySet[Char]):laika.parse.text.DelimitedText"></a><a id="delimitedBy(NonEmptySet[Char]):DelimitedText"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#delimitedBy(chars:cats.data.NonEmptySet[Char]):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="text/DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until one of the specified characters
is encountered on the input string.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters until one of the specified characters
is encountered on the input string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimitedBy(char:Char,chars:Char*):laika.parse.text.DelimitedText"></a><a id="delimitedBy(Char,Char*):DelimitedText"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#delimitedBy(char:Char,chars:Char*):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="text/DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until one of the specified characters
is encountered on the input string.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters until one of the specified characters
is encountered on the input string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimiter(parser:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimiterParser"></a><a id="delimiter(PrefixedParser[String]):DelimiterParser"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#delimiter(parser:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimiterParser" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimiter</span><span class="params">(<span name="parser">parser: <a href="text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="text/DelimiterParser.html" class="extype" name="laika.parse.text.DelimiterParser">DelimiterParser</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates a parser for a delimiter with an API that allows to specify
predicates for the characters immediately preceding or following
the delimiter, a common task in markup parsing.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser for a delimiter with an API that allows to specify
predicates for the characters immediately preceding or following
the delimiter, a common task in markup parsing.</p><p>This specified underlying parser needs to implement the sub-trait <code>PrefixedParser</code>
as only those can be optimized for an assertion that needs to be performed on each
character. Most parsers for non-empty text implement this trait, e.g <code>oneOf</code>, <code>someOf</code>,
<code>delimiter</code> or the literal parsers for a character or string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimiter(delim:String):laika.parse.text.DelimiterParser"></a><a id="delimiter(String):DelimiterParser"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#delimiter(delim:String):laika.parse.text.DelimiterParser" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimiter</span><span class="params">(<span name="delim">delim: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="text/DelimiterParser.html" class="extype" name="laika.parse.text.DelimiterParser">DelimiterParser</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates a parser for a delimiter based on a literal string with an API that
allows to specify predicates for the characters immediately
preceding or following the delimiter, a common task in markup parsing.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser for a delimiter based on a literal string with an API that
allows to specify predicates for the characters immediately
preceding or following the delimiter, a common task in markup parsing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimiter(char:Char,chars:Char*):laika.parse.text.DelimiterParser"></a><a id="delimiter(Char,Char*):DelimiterParser"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#delimiter(char:Char,chars:Char*):laika.parse.text.DelimiterParser" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimiter</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="text/DelimiterParser.html" class="extype" name="laika.parse.text.DelimiterParser">DelimiterParser</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates a parser for a delimiter based on the given set of delimiter characters
with an API that allows to specify predicates for the characters immediately
preceding or following the delimiter, a common task in markup parsing.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser for a delimiter based on the given set of delimiter characters
with an API that allows to specify predicates for the characters immediately
preceding or following the delimiter, a common task in markup parsing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#eof" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eof:laika.parse.Parser[String]"></a><a id="eof:Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#eof:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">eof</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#eol" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eol:laika.parse.Parser[Unit]"></a><a id="eol:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#eol:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">eol</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the end of a line, including the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of a line, including the end of the input.
 Produces an empty string as a result and consumes any new line characters.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#failure" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="failure(msg:String):laika.parse.Parser[Nothing]"></a><a id="failure(String):Parser[Nothing]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#failure(msg:String):laika.parse.Parser[Nothing]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that always fails with the specified message.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that always fails with the specified message.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.markup.BlockParsers#indentedBlock" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="indentedBlock(minIndent:Int,linePredicate:=&gt;laika.parse.Parser[Any],endsOnBlankLine:Boolean,firstLineIndented:Boolean,maxIndent:Int):laika.parse.Parser[laika.parse.BlockSource]"></a><a id="indentedBlock(Int,⇒Parser[Any],Boolean,Boolean,Int):Parser[BlockSource]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#indentedBlock(minIndent:Int,linePredicate:=&gt;laika.parse.Parser[Any],endsOnBlankLine:Boolean,firstLineIndented:Boolean,maxIndent:Int):laika.parse.Parser[laika.parse.BlockSource]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">indentedBlock</span><span class="params">(<span name="minIndent">minIndent: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>, <span name="linePredicate">linePredicate: ⇒ <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>] = <span class="symbol"><span class="name"><a href="../index.html">success(())</a></span></span></span>, <span name="endsOnBlankLine">endsOnBlankLine: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="firstLineIndented">firstLineIndented: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="maxIndent">maxIndent: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">Int.MaxValue</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="BlockSource.html" class="extype" name="laika.parse.BlockSource">BlockSource</a>]</span>
      </span>
      
      <p class="shortcomment cmt"> Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first.</p><div class="fullcomment"><div class="comment cmt"><p> Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first. The indentation may vary between the parts of the indented
 block, so that this parser only cuts off the minimum indentation shared by all lines,
 but each line must have at least the specified minimum indentation.
</p></div><dl class="paramcmts block"><dt class="param">minIndent</dt><dd class="cmt"><p>the minimum indentation that each line in this block must have</p></dd><dt class="param">linePredicate</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">endsOnBlankLine</dt><dd class="cmt"><p>indicates whether parsing should end on the first blank line</p></dd><dt class="param">firstLineIndented</dt><dd class="cmt"><p>indicates whether the first line is expected to be indented, too</p></dd><dt class="param">maxIndent</dt><dd class="cmt"><p>the maximum indentation that will get dropped from the start of each line of the result</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that produces the raw text of the parsed block with the indentation removed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="markup/BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.markup.BlockParsers#indentedBlockWithLevel" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="indentedBlockWithLevel(minIndent:Int,linePredicate:=&gt;laika.parse.Parser[Any],endsOnBlankLine:Boolean,firstLineIndented:Boolean,maxIndent:Int):laika.parse.Parser[(laika.parse.BlockSource,Int)]"></a><a id="indentedBlockWithLevel(Int,⇒Parser[Any],Boolean,Boolean,Int):Parser[(BlockSource,Int)]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#indentedBlockWithLevel(minIndent:Int,linePredicate:=&gt;laika.parse.Parser[Any],endsOnBlankLine:Boolean,firstLineIndented:Boolean,maxIndent:Int):laika.parse.Parser[(laika.parse.BlockSource,Int)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">indentedBlockWithLevel</span><span class="params">(<span name="minIndent">minIndent: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>, <span name="linePredicate">linePredicate: ⇒ <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>] = <span class="symbol"><span class="name"><a href="../index.html">success(())</a></span></span></span>, <span name="endsOnBlankLine">endsOnBlankLine: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="firstLineIndented">firstLineIndented: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="maxIndent">maxIndent: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">Int.MaxValue</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<a href="BlockSource.html" class="extype" name="laika.parse.BlockSource">BlockSource</a>, <span class="extype" name="scala.Int">Int</span>)]</span>
      </span>
      
      <p class="shortcomment cmt"> Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first.</p><div class="fullcomment"><div class="comment cmt"><p> Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first. The indentation may vary between the parts of the indented
 block, so that this parser only cuts off the minimum indentation shared by all lines,
 but each line must have at least the specified minimum indentation.
</p></div><dl class="paramcmts block"><dt class="param">minIndent</dt><dd class="cmt"><p>the minimum indentation that each line in this block must have</p></dd><dt class="param">linePredicate</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">endsOnBlankLine</dt><dd class="cmt"><p>indicates whether parsing should end on the first blank line</p></dd><dt class="param">firstLineIndented</dt><dd class="cmt"><p>indicates whether the first line is expected to be indented, too</p></dd><dt class="param">maxIndent</dt><dd class="cmt"><p>the maximum indentation that will get dropped from the start of each line of the result</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that produces the raw text of the parsed block with the indentation removed and the
         indentation level (number of whitespace characters removed from the text lines)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="markup/BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lazily" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lazily[T](p:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lazily[T](⇒Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#lazily[T](p:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lazily</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lazily.T">T</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lazily.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Constructs a parser lazily, useful when breaking circles in recursive parsing.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a parser lazily, useful when breaking circles in recursive parsing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#literal" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="literal(expected:String):laika.parse.text.PrefixedParser[String]"></a><a id="literal(String):PrefixedParser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#literal(expected:String):laika.parse.text.PrefixedParser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> A parser that matches only the specified literal string.</p><div class="fullcomment"><div class="comment cmt"><p> A parser that matches only the specified literal string.</p><p> The method is implicit so that strings can automatically be lifted to their parsers.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead(offset:Int,value:String):laika.parse.Parser[String]"></a><a id="lookAhead(Int,String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#lookAhead(offset:Int,value:String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal value at the specified offset
behind the current position.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal value at the specified offset
behind the current position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead[T](offset:Int,p:laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lookAhead[T](Int,Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#lookAhead[T](offset:Int,p:laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead(value:String):laika.parse.Parser[String]"></a><a id="lookAhead(String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#lookAhead(value:String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal value at the current
position.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal value at the current
position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lookAhead[T](Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#lookAhead[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser at the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser at the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookBehind" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookBehind[T](offset:Int,parser:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lookBehind[T](Int,⇒Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#lookBehind[T](offset:Int,parser:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookBehind</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="parser">parser: ⇒ <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookBehind.T">T</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookBehind.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#nextIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="nextIn(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#nextIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextIn</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is one of those specified.
Fails at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#nextIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextIn(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="nextIn(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#nextIn(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextIn</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is one of those specified.
Fails at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#nextIs" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="nextIs((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#nextIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextIs</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character does not satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character does not satisfy the specified predicate.
Fails at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#nextNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="nextNot((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#nextNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextNot</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character does not satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character does not satisfy the specified predicate.
Succeeds at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#nextNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="nextNot(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#nextNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is not one of those specified.
Succeeds at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#nextNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextNot(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="nextNot(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#nextNot(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is not one of those specified.
Succeeds at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#not" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="not(value:String):laika.parse.Parser[Unit]"></a><a id="not(String):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#not(value:String):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that only succeeds if the parsing the specified literal value
fails and vice versa, it never consumes any input.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that only succeeds if the parsing the specified literal value
fails and vice versa, it never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#not" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="not[T](p:laika.parse.Parser[T]):laika.parse.Parser[Unit]"></a><a id="not[T](Parser[T]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#not[T](p:laika.parse.Parser[T]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.not.T">T</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that only succeeds if the specified parser fails and
 vice versa, it never consumes any input.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that only succeeds if the specified parser fails and
 vice versa, it never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#oneChar" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneChar:laika.parse.Parser[String]"></a><a id="oneChar:Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#oneChar:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">oneChar</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses exactly one character from the input, fails only at the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Parses exactly one character from the input, fails only at the end of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#oneIf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneIf(p:Char=&gt;Boolean):laika.parse.Parser[String]"></a><a id="oneIf((Char)⇒Boolean):Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#oneIf(p:Char=&gt;Boolean):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneIf</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it satisfies the specified predicate, fails otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one character if it satisfies the specified predicate, fails otherwise.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#oneNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[String]"></a><a id="oneNot(NonEmptySet[Char]):Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#oneNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it is not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one character if it is not one of the specified characters.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#oneNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneNot(char:Char,chars:Char*):laika.parse.Parser[String]"></a><a id="oneNot(Char,Char*):Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#oneNot(char:Char,chars:Char*):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it is not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one character if it is not one of the specified characters.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#oneOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixedParser[String]"></a><a id="oneOf(NonEmptySet[Char]):PrefixedParser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#oneOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixedParser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it matches one of the specified characters, fails otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one character if it matches one of the specified characters, fails otherwise.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#oneOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="oneOf(char:Char,chars:Char*):laika.parse.text.PrefixedParser[String]"></a><a id="oneOf(Char,Char*):PrefixedParser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#oneOf(char:Char,chars:Char*):laika.parse.text.PrefixedParser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOf</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it matches one of the specified characters, fails otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one character if it matches one of the specified characters, fails otherwise.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#opt" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt(value:String):laika.parse.Parser[Option[String]]"></a><a id="opt(String):Parser[Option[String]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#opt(value:String):laika.parse.Parser[Option[String]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">A parser for an optional literal string that always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>A parser for an optional literal string that always succeeds.</p><p>If the underlying parser succeeds this parser will contain its result as a <code>Some</code>,
if it fails this parser will succeed with a <code>None</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#opt" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt[T](p:laika.parse.Parser[T]):laika.parse.Parser[Option[T]]"></a><a id="opt[T](Parser[T]):Parser[Option[T]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#opt[T](p:laika.parse.Parser[T]):laika.parse.Parser[Option[T]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.opt.T">T</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.combinator.Parsers.opt.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">A parser for an optional element that always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>A parser for an optional element that always succeeds.</p><p>If the underlying parser succeeds this parser will contain its result as a <code>Some</code>,
if it fails this parser will succeed with a <code>None</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#prevIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="prevIn(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#prevIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevIn</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is one of those specified.
Fails at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#prevIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevIn(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="prevIn(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#prevIn(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevIn</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is one of those specified.
Fails at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#prevIs" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="prevIs((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#prevIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevIs</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character satisfies the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character satisfies the specified predicate.
Fails at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#prevNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="prevNot((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#prevNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevNot</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character does not satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character does not satisfy the specified predicate.
Succeeds at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#prevNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="prevNot(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#prevNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is not one of those specified.
Succeeds at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#prevNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevNot(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="prevNot(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#prevNot(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is not one of those specified.
Succeeds at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#range" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="range(fromChar:Char,toChar:Char):cats.data.NonEmptySet[Char]"></a><a id="range(Char,Char):NonEmptySet[Char]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#range(fromChar:Char,toChar:Char):cats.data.NonEmptySet[Char]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">range</span><span class="params">(<span name="fromChar">fromChar: <span class="extype" name="scala.Char">Char</span></span>, <span name="toChar">toChar: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a NonEmptySet from a Character range.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a NonEmptySet from a Character range.
This set can then be passed to parsers like <code>anyOf</code> or <code>oneOf</code>
which expect a NonEmptySet as a parameter.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#restOfLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restOfLine:laika.parse.Parser[String]"></a><a id="restOfLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#restOfLine:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">restOfLine</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text. Does not include the eol character(s).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#someNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="someNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]"></a><a id="someNot(NonEmptySet[Char]):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#someNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters that are not one of the specified characters,
fails for empty results.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one or more characters that are not one of the specified characters,
fails for empty results.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#someNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="someNot(char:Char,chars:Char*):laika.parse.text.Characters[String]"></a><a id="someNot(Char,Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#someNot(char:Char,chars:Char*):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters that are not one of the specified characters,
fails for empty results.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one or more characters that are not one of the specified characters,
fails for empty results.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#someOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="someOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixCharacters[String]"></a><a id="someOf(NonEmptySet[Char]):PrefixCharacters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#someOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixCharacters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="text/PrefixCharacters.html" class="extype" name="laika.parse.text.PrefixCharacters">PrefixCharacters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters if they match one of the specified characters,
fails if the first character does not match.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one or more characters if they match one of the specified characters,
fails if the first character does not match.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#someOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="someOf(char:Char,chars:Char*):laika.parse.text.PrefixCharacters[String]"></a><a id="someOf(Char,Char*):PrefixCharacters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#someOf(char:Char,chars:Char*):laika.parse.text.PrefixCharacters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someOf</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="text/PrefixCharacters.html" class="extype" name="laika.parse.text.PrefixCharacters">PrefixCharacters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters if they match one of the specified characters,
fails if the first character does not match.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one or more characters if they match one of the specified characters,
fails if the first character does not match.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#someWhile" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="someWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]"></a><a id="someWhile((Char)⇒Boolean):Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#someWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters which satisfy the specified predicate,
fails for empty results.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes one or more characters which satisfy the specified predicate,
fails for empty results.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.markup.InlineParsers#spans" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spans(parser:=&gt;laika.parse.text.DelimitedText):laika.parse.markup.InlineParser[laika.ast.Span,List[laika.ast.Span]]"></a><a id="spans(⇒DelimitedText):InlineParser[Span,List[Span]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#spans(parser:=&gt;laika.parse.text.DelimitedText):laika.parse.markup.InlineParser[laika.ast.Span,List[laika.ast.Span]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">spans</span><span class="params">(<span name="parser">parser: ⇒ <a href="text/DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>)</span><span class="result">: <a href="markup/InlineParser.html" class="extype" name="laika.parse.markup.InlineParser">InlineParser</a>[<a href="../ast/Span.html" class="extype" name="laika.ast.Span">Span</a>, <span class="extype" name="scala.List">List</span>[<a href="../ast/Span.html" class="extype" name="laika.ast.Span">Span</a>]]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a new parser that reads input until the delimiters in the specified parser are detected.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new parser that reads input until the delimiters in the specified parser are detected.</p><p>The returned parser allows to register parsers for child spans with its <code>embed</code> method.
Without calling it, the result of this parser would always just be a single span of type <code>Text</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="markup/InlineParsers.html" class="extype" name="laika.parse.markup.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#success" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="success[T](v:T):laika.parse.Parser[T]"></a><a id="success[T](T):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#success[T](v:T):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: <span class="extype" name="laika.parse.combinator.Parsers.success.T">T</span></span>)</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.success.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that always succeeds with the specified value.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that always succeeds with the specified value.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.markup.InlineParsers#text" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text(parser:=&gt;laika.parse.text.DelimitedText):laika.parse.markup.InlineParser[String,String]"></a><a id="text(⇒DelimitedText):InlineParser[String,String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#text(parser:=&gt;laika.parse.text.DelimitedText):laika.parse.markup.InlineParser[String,String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">text</span><span class="params">(<span name="parser">parser: ⇒ <a href="text/DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>)</span><span class="result">: <a href="markup/InlineParser.html" class="extype" name="laika.parse.markup.InlineParser">InlineParser</a>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a new parser that reads text until the delimiters in the specified parser are detected.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new parser that reads text until the delimiters in the specified parser are detected.</p><p>The returned parser allows to register parsers for child spans with its <code>embed</code> method,
for example for reading escape sequences.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="markup/InlineParsers.html" class="extype" name="laika.parse.markup.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#textLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="textLine:laika.parse.Parser[String]"></a><a id="textLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#textLine:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">textLine</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a single text line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single text line from the current input offset (which may not be at the
 start of the line). Fails for blank lines. Does not include the eol character(s).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#ws" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ws:laika.parse.text.Characters[String]"></a><a id="ws:Characters[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#ws:laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">ws</span><span class="result">: <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses horizontal whitespace (space and tab).</p><div class="fullcomment"><div class="comment cmt"><p>Parses horizontal whitespace (space and tab).
Always succeeds, consuming all whitespace found.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#wsEol" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wsEol:laika.parse.Parser[Unit]"></a><a id="wsEol:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/builders$.html#wsEol:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">wsEol</span><span class="result">: <a href="Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses any number of whitespace characters followed
by a newline character.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any number of whitespace characters followed
by a newline character.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></dd></dl></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="laika.parse.markup.BlockParsers">
              <h3>Inherited from <a href="markup/BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a></h3>
            </div><div class="parent" name="laika.parse.markup.InlineParsers">
              <h3>Inherited from <a href="markup/InlineParsers.html" class="extype" name="laika.parse.markup.InlineParsers">InlineParsers</a></h3>
            </div><div class="parent" name="laika.parse.text.TextParsers">
              <h3>Inherited from <a href="text/TextParsers.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></h3>
            </div><div class="parent" name="laika.parse.combinator.Parsers">
              <h3>Inherited from <a href="combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
