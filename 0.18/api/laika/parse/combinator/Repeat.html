<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="../../../laika/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../../../laika/parse/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.combinator" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="combinator"></a><a id="combinator:combinator"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">combinator</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li class="current-entities indented3">
                        <a class="object" href="Parsers$.html" title=""></a>
                        <a class="trait" href="Parsers.html" title="Generic base parsers which are not specifically tailored for parsing of text markup."></a>
                        <a href="Parsers.html" title="Generic base parsers which are not specifically tailored for parsing of text markup.">Parsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="" title="Parser implementation for repeatedly applying the specified base parser until it fails."></a>
                        <a href="" title="Parser implementation for repeatedly applying the specified base parser until it fails.">Repeat</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="class type">
      <div id="definition">
        <div class="big-circle class">c</div>
        <p id="owner"><a href="../../index.html" class="extype" name="laika">laika</a>.<a href="../index.html" class="extype" name="laika.parse">parse</a>.<a href="index.html" class="extype" name="laika.parse.combinator">combinator</a></p>
        <h1>Repeat<span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Repeat</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Parser implementation for repeatedly applying the specified base parser until it fails.</p><p>By default the parser allows for any number of successful parser invocations,
including empty results. Use of the <code>min</code>, <code>max</code> and <code>take</code> methods allows
to apply additional constrains on the expected number of results.
</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]], <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="laika.parse.combinator.Repeat"><span>Repeat</span></li><li class="in" name="laika.parse.Parser"><span>Parser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="laika.parse.combinator.Repeat#&lt;init&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(parser:laika.parse.Parser[T],min:Int,max:Int,sep:Option[laika.parse.Parser[Unit]]):laika.parse.combinator.Repeat[T]"></a><a id="&lt;init&gt;:Repeat[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#&lt;init&gt;(parser:laika.parse.Parser[T],min:Int,max:Int,sep:Option[laika.parse.Parser[Unit]]):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Repeat</span><span class="params">(<span name="parser">parser: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>, <span name="min">min: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>, <span name="max">max: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">Int.MaxValue</span></span>, <span name="sep">sep: <span class="extype" name="scala.Option">Option</span>[<a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]] = <span class="symbol">None</span></span>)</span>
      </span>
      
      
    </li></ol>
            </div>

        

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#*" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="*:laika.parse.combinator.Repeat[T]"></a><a id="*:Repeat[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#*:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $times" class="name">*</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that repeatedly applies this parser.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that repeatedly applies this parser.
 It will always succeed, potentially with an empty list as the result.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#+" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+:laika.parse.combinator.Repeat[T]"></a><a id="+:Repeat[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#+:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="name">+</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser (at least once).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser (at least once).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#&lt;~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T]"></a><a id="&lt;~[U](Parser[U]):Parser[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#&lt;~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$tilde" class="name">&lt;~</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&lt;~.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser,
 but only keeps the left result.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser,
 but only keeps the left result.</p><p> <code>a &lt;~ b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#&lt;~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;~(value:String):laika.parse.Parser[T]"></a><a id="&lt;~(String):Parser[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#&lt;~(value:String):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$tilde" class="name">&lt;~</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the left result.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the left result.</p><p><code>a &lt;~ b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#&gt;&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&gt;&gt;[U](fq:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="&gt;&gt;[U]((List[T])⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#&gt;&gt;[U](fq:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $greater$greater" class="name">&gt;&gt;</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="fq">fq: (<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&gt;&gt;.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&gt;&gt;.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Operator synonym for <code>flatMap</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Operator synonym for <code>flatMap</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#?" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="?:laika.parse.Parser[Option[T]]"></a><a id="?:Parser[Option[List[T]]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#?:laika.parse.Parser[Option[T]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $qmark" class="name">?</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that optionally parses what this parser parses.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that optionally parses what this parser parses.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#^^" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="^^[U](f:T=&gt;U):laika.parse.Parser[U]"></a><a id="^^[U]((List[T])⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#^^[U](f:T=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $up$up" class="name">^^</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]) ⇒ <span class="extype" name="laika.parse.Parser.^^.U">U</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.^^.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> A synonym for <code>map</code>, allowing the grammar to be declared in a concise way.</p><div class="fullcomment"><div class="comment cmt"><p> A synonym for <code>map</code>, allowing the grammar to be declared in a concise way.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#as" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="as[U](v:=&gt;U):laika.parse.Parser[U]"></a><a id="as[U](⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#as[U](v:=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">as</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="v">v: ⇒ <span class="extype" name="laika.parse.Parser.as.U">U</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.as.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that ignores the result of this parser (if it succeeds)
 and returns the specified result instead.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that ignores the result of this parser (if it succeeds)
 and returns the specified result instead.</p><p> Subclasses may override this method to avoid any expensive
 result processing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#collect" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collect[U,V&gt;:T](f:PartialFunction[T,U],error:V=&gt;String):laika.parse.Parser[U]"></a><a id="collect[U,V&gt;:List[T]](PartialFunction[List[T],U],(V)⇒String):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#collect[U,V&gt;:T](f:PartialFunction[T,U],error:V=&gt;String):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="U">U</span>, <span name="V">V &gt;: <span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>]</span><span class="params">(<span name="f">f: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>], <span class="extype" name="laika.parse.Parser.collect.U">U</span>]</span>, <span name="error">error: (<span class="extype" name="laika.parse.Parser.collect.V">V</span>) ⇒ <span class="extype" name="scala.Predef.String">String</span> = <span class="defval" name="(r:V) =&gt; s&quot;Constructor function not defined at $r&quot;">...</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.collect.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that applies a partial function to the result of this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that applies a partial function to the result of this parser.</p><p><code>p.collect(f)</code> succeeds if <code>p</code> succeeds and <code>f</code> is defined at the result of <code>p</code>,
In that case it returns <code>f</code> applied to the result of <code>p</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>a partial function that will be applied to this parser's result.</p></dd><dt class="param">error</dt><dd class="cmt"><p>an optional function that takes the same argument as <code>f</code> and produces an error message.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#count" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="count:laika.parse.Parser[Int]"></a><a id="count:Parser[Int]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#count:laika.parse.Parser[Int]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">count</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that produces the number of characters
consumed by this parser while discarding the original result.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that produces the number of characters
consumed by this parser while discarding the original result.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#cursor" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cursor:laika.parse.Parser[laika.parse.SourceFragment]"></a><a id="cursor:Parser[SourceFragment]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#cursor:laika.parse.Parser[laika.parse.SourceFragment]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cursor</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../SourceFragment.html" class="extype" name="laika.parse.SourceFragment">SourceFragment</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Provides a cursor over the input consumed by this parser while discarding the actual result.</p><div class="fullcomment"><div class="comment cmt"><p>Provides a cursor over the input consumed by this parser while discarding the actual result.
Use <code>withCursor</code> if you also need access to the result.</p><p>This is required for parsers that create AST nodes that need to be resolved in a rewrite step
and need to report the source location in case of failure.
It is also required when passing a result of a first-pass parser to a recursive parser
to preserve line positions.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#evalMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalMap[U](f:T=&gt;Either[String,U]):laika.parse.Parser[U]"></a><a id="evalMap[U]((List[T])⇒Either[String,U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#evalMap[U](f:T=&gt;Either[String,U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalMap</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]) ⇒ <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="laika.parse.Parser.evalMap.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.evalMap.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that applies a function to the result of this parser producing an <code>Either</code>
 where <code>Left</code> is interpreted as failure.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that applies a function to the result of this parser producing an <code>Either</code>
 where <code>Left</code> is interpreted as failure. It is an alternative to <code>^?<code> for scenarios
 where the conditional check cannot be easily performed in a pattern match.</code></code></p><p> <code>p.evalMap(f)</code> succeeds if <code>p</code> succeeds and <code>f</code> returns a <code>Right</code> when applied to the result
 of <code>p</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#flatMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMap[U](f:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="flatMap[U]((List[T])⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#flatMap[U](f:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.flatMap.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.flatMap.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a new parser by applying the specified function
to the result of this parser and subsequently applying
the parser returned by that function to the input left
over by this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a new parser by applying the specified function
to the result of this parser and subsequently applying
the parser returned by that function to the input left
over by this parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#handleErrorWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="handleErrorWith[U&gt;:List[T]]((Failure)⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleErrorWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>]</span><span class="params">(<span name="f">f: (<a href="../Failure.html" class="extype" name="laika.parse.Failure">Failure</a>) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.handleErrorWith.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.handleErrorWith.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Handle any error, potentially recovering from it, by mapping it to a new parser that
will be applied at the same starting position than the failing parser.</p><div class="fullcomment"><div class="comment cmt"><p>Handle any error, potentially recovering from it, by mapping it to a new parser that
will be applied at the same starting position than the failing parser.</p><p>This is similar to the <code>orElse</code> or <code>|</code> method, but allows the alternative
parser to inspect the error of the preceding one.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="../Parser.html#recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]" class="extmbr" name="laika.parse.Parser#recoverWith">recoverWith</a> to recover from only certain errors.</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.Parser#map" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[U](f:T=&gt;U):laika.parse.Parser[U]"></a><a id="map[U]((List[T])⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#map[U](f:T=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]) ⇒ <span class="extype" name="laika.parse.Parser.map.U">U</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.map.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a new parser by applying the specified function
to the result of this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a new parser by applying the specified function
to the result of this parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Repeat#max" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="max(num:Int):laika.parse.combinator.Repeat[T]"></a><a id="max(Int):Repeat[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#max(num:Int):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">max</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Specifies a maximum number of successful invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Specifies a maximum number of successful invocations.
When this number is reached, this parser will stop invoking
the base parser even if it would be able to produce more results.
</p></div></div>
    </li><li name="laika.parse.combinator.Repeat#min" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="min(num:Int):laika.parse.combinator.Repeat[T]"></a><a id="min(Int):Repeat[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#min(num:Int):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">min</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Specifies a minimum number of successful invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Specifies a minimum number of successful invocations.
If the base parser fails before reaching this number
of results, this parser will fail.
</p></div></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#orElse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="orElse[U&gt;:T](p0:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="orElse[U&gt;:List[T]](⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#orElse[U&gt;:T](p0:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">orElse</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>]</span><span class="params">(<span name="p0">p0: ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.orElse.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.orElse.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser when this parser fails.</p><p> <code>a orElse b</code> succeeds if either of the parsers succeeds.</p><p> In case both parsers fail, the <code>Failure</code> instance will
 be from the parser with the most successfully read characters.
 In the case of multiple failures having the same number of characters,
 the one with the highest precedence (this parser) will be chosen.</p><p> Implementation note:
 The parameter is by-name to allow the definition of
 recursive parsers. In contrast to the former SDK
 parser combinators this is the only place where
 a parser with a by-name parameter is used whereas
 in all other places the additional cost is avoided.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Repeat#parse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse(source:laika.parse.SourceCursor):laika.parse.Parsed[List[T]]"></a><a id="parse(SourceCursor):Parsed[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#parse(source:laika.parse.SourceCursor):laika.parse.Parsed[List[T]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="params">(<span name="source">source: <a href="../SourceCursor.html" class="extype" name="laika.parse.SourceCursor">SourceCursor</a></span>)</span><span class="result">: <a href="../Parsed.html" class="extype" name="laika.parse.Parsed">Parsed</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the string content in the specified context
and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the string content in the specified context
and returns the result.</p><p>This is the only abstract method in <code>Parser</code> that
concrete implementations need to implement.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a> → <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#parse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse(in:String):laika.parse.Parsed[T]"></a><a id="parse(String):Parsed[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#parse(in:String):laika.parse.Parsed[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="params">(<span name="in">in: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parsed.html" class="extype" name="laika.parse.Parsed">Parsed</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the specified string and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the specified string and returns the result.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#recoverWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]"></a><a id="recoverWith[U&gt;:List[T]](PartialFunction[Failure,Parser[U]]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">recoverWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>]</span><span class="params">(<span name="pf">pf: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Failure.html" class="extype" name="laika.parse.Failure">Failure</a>, <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.recoverWith.U">U</span>]]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.recoverWith.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Handle certain errors, potentially recovering from it, by mapping them to a new parser that
will be applied at the same starting position than the failing parser.</p><div class="fullcomment"><div class="comment cmt"><p>Handle certain errors, potentially recovering from it, by mapping them to a new parser that
will be applied at the same starting position than the failing parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="../Parser.html#handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" class="extmbr" name="laika.parse.Parser#handleErrorWith">handleErrorWith</a> to handle any/all errors.</p></span></dd></dl></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep(separator:String):laika.parse.combinator.Repeat[T]"></a><a id="rep(String):Repeat[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#rep(separator:String):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="params">(<span name="separator">separator: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser with the specified
separator string between those invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser with the specified
separator string between those invocations.</p><p><code>p.rep(sep).min(1)</code> is equivalent to <code>(p ~ (sep ~&gt; p).rep).concat</code>.</p><p>The returned parser offers an API to specify further constraints
like <code>min</code> or <code>max</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep(separator:laika.parse.Parser[Unit]):laika.parse.combinator.Repeat[T]"></a><a id="rep(Parser[Unit]):Repeat[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#rep(separator:laika.parse.Parser[Unit]):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="params">(<span name="separator">separator: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser with the specified
separator parser between those invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser with the specified
separator parser between those invocations.</p><p><code>p.rep(sep).min(1)</code> is equivalent to <code>(p ~ (sep ~&gt; p).rep).concat</code>.</p><p>The returned parser offers an API to specify further constraints
like <code>min</code> or <code>max</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep:laika.parse.combinator.Repeat[T]"></a><a id="rep:Repeat[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#rep:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that repeatedly applies this parser.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that repeatedly applies this parser.
 The returned parser offers an API to specify further constraints
 like <code>min</code> or <code>max</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#repUntil" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repUntil[U](endCondition:laika.parse.Parser[U]):laika.parse.Parser[(List[T],Option[U])]"></a><a id="repUntil[U](Parser[U]):Parser[(List[List[T]],Option[U])]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#repUntil[U](endCondition:laika.parse.Parser[U]):laika.parse.Parser[(List[T],Option[U])]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repUntil</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="endCondition">endCondition: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.repUntil.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]], <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.Parser.repUntil.U">U</span>])]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser until either this parser fails or the specified
end condition is met.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser until either this parser fails or the specified
end condition is met.
The end condition will be applied after each successful invocation of this parser.</p><p>The result of the returned parser is a tuple consisting of the list containing the
result of the invocations of this parser plus the result of the end condition.
The latter is returned as an <code>Option</code> as it might be empty when the parsing finished because of this parser failing.</p><p>Note that it is more convenient to include the end condition in the repeating parser itself and use
the simpler <code>rep</code> method.
This combinator is an alternative if you need to know the result of the end condition.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#repWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repWith[U&gt;:T](next:U=&gt;laika.parse.Parser[U]):laika.parse.Parser[List[U]]"></a><a id="repWith[U&gt;:List[T]]((U)⇒Parser[U]):Parser[List[U]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#repWith[U&gt;:T](next:U=&gt;laika.parse.Parser[U]):laika.parse.Parser[List[U]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>]</span><span class="params">(<span name="next">next: (<span class="extype" name="laika.parse.Parser.repWith.U">U</span>) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.repWith.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.Parser.repWith.U">U</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that invokes the specified function repeatedly,
passing the result of this parser if it succeeds, to produce new
parsers that get applied until one of them fails.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that invokes the specified function repeatedly,
passing the result of this parser if it succeeds, to produce new
parsers that get applied until one of them fails.</p><p>The result of the returned parser is a list containing the
result of this parser (if it succeeds) plus the results of
successful invocations of the parsers returned by the specified
function.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#source" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="source:laika.parse.Parser[String]"></a><a id="source:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#source:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">source</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Retrieves the part of the input consumed by this parser while discarding the result.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves the part of the input consumed by this parser while discarding the result.</p><p>This is useful in scenarios where many string-based parsers are combined and produce a deeply nested result
like <code>String ~ Option[String] ~ List[String]</code> where it would require some boilerplate to concatenate the results.
Using the source method, the entire text consumed by this combination of parsers will be returned.</p><p>If you also need the position within the input or need to pass the result to a recursive parser manually,
use the <code>cursor</code> method instead.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.combinator.Repeat#take" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="take(num:Int):laika.parse.combinator.Repeat[T]"></a><a id="take(Int):Repeat[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#take(num:Int):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">take</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Specifies the exact number of successful invocations, a shortcut for
<code>.min(num).max(num)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Specifies the exact number of successful invocations, a shortcut for
<code>.min(num).max(num)</code>.</p><p>If the base parser fails before reaching the minimum number
of results, this parser will fail.
When the maximum number is reached, this parser will stop invoking
the base parser even if it would be able to produce more results.
</p></div></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#void" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="void:laika.parse.Parser[Unit]"></a><a id="void:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#void:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">void</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Discards the result of a successful parser.</p><div class="fullcomment"><div class="comment cmt"><p>Discards the result of a successful parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#withCursor" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withCursor:laika.parse.Parser[(T,laika.parse.SourceFragment)]"></a><a id="withCursor:Parser[(List[T],SourceFragment)]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#withCursor:laika.parse.Parser[(T,laika.parse.SourceFragment)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withCursor</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>], <a href="../SourceFragment.html" class="extype" name="laika.parse.SourceFragment">SourceFragment</a>)]</span>
      </span>
      
      <p class="shortcomment cmt">Provides the result of this parser together with a cursor over the input,
capturing the consumed source string and its position within the root input.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the result of this parser together with a cursor over the input,
capturing the consumed source string and its position within the root input.
Use <code>cursor</code> if you do not need access to the actual result.</p><p>This is required for parsers that create AST nodes that need to be resolved in a rewrite step
and need to report the source location in case of failure.
It is also required when passing a result of a first-pass parser to a recursive parser
to preserve line positions.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#withFailureMessage" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withFailureMessage(msg:String):laika.parse.Parser[T]"></a><a id="withFailureMessage(String):Parser[List[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#withFailureMessage(msg:String):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFailureMessage</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt"> Changes the failure message produced by a parser.</p><div class="fullcomment"><div class="comment cmt"><p> Changes the failure message produced by a parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#|" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="|(value:String)(implicitev:T&lt;:&lt;String):laika.parse.Parser[String]"></a><a id="|(String)(&lt;:&lt;[List[T],String]):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#|(value:String)(implicitev:T&lt;:&lt;String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bar" class="name">|</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>], <span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Attempts to parse the specified literal string when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Attempts to parse the specified literal string when this parser fails.</p><p> <code>a | b</code> succeeds if either of the parsers succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#|" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="|[U&gt;:T](p:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="|[U&gt;:List[T]](⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#|[U&gt;:T](p:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bar" class="name">|</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.|.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.|.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser when this parser fails.</p><p> <code>a | b</code> succeeds if either of the parsers succeeds.</p><p> Implementation note:
 The parameter is by-name to allow the definition of
 recursive parsers. In contrast to the former SDK
 parser combinators this is the only place where
 a parser with a by-name parameter is used whereas
 in all other places the additional cost is avoided.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T~U]"></a><a id="~[U](Parser[U]):Parser[~[List[T],U]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T~U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../../ast/package$$$tilde.html" class="extype" name="laika.ast.~">~</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>], <span class="extype" name="laika.parse.Parser.~.U">U</span>]]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser
 and combines the two results.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser
 and combines the two results.</p><p> <code>a ~ b</code> only succeeds if both parsers succeed, with the results
 in a wrapper class named <code>~</code> for convenient pattern matching:</p><pre>a ~ b ~ c ^^ {
  <span class="kw">case</span> a ~ b ~ c <span class="kw">=&gt;</span> processResult(a, b, c)
}</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~(value:String):laika.parse.Parser[T~String]"></a><a id="~(String):Parser[~[List[T],String]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#~(value:String):laika.parse.Parser[T~String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../../ast/package$$$tilde.html" class="extype" name="laika.ast.~">~</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>], <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over
by this parser and combines the two results.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over
by this parser and combines the two results.</p><p> <code>a ~ b</code> only succeeds if both parsers succeed, with the results
 in a wrapper class named <code>~</code> for convenient pattern matching:</p><pre>a ~ b ~ c ^^ {
  <span class="kw">case</span> a ~ b ~ c <span class="kw">=&gt;</span> processResult(a, b, c)
}</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~&gt;[U](p:laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="~&gt;[U](Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#~&gt;[U](p:laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde$greater" class="name">~&gt;</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~&gt;.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~&gt;.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser,
 but only keeps the right result.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser,
 but only keeps the right result.</p><p> <code>a ~&gt; b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~&gt;(value:String):laika.parse.Parser[String]"></a><a id="~&gt;(String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Repeat.html#~&gt;(value:String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde$greater" class="name">~&gt;</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the right result.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the right result.</p><p> <code>a ~&gt; b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="laika.parse.Parser">
              <h3>Inherited from <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.combinator.Repeat.T">T</span>]]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
