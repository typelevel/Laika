<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="../../../laika/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../../../laika/parse/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.markup" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markup"></a><a id="markup:markup"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">markup</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li class="current-entities indented3">
                        <a class="object" href="BlockParsers$.html" title="Instance that allows to import all block parsers in isolation."></a>
                        <a class="trait" href="BlockParsers.html" title="Provides base parsers that abstract aspects of block parsing common to most lightweight markup languages."></a>
                        <a href="BlockParsers.html" title="Provides base parsers that abstract aspects of block parsing common to most lightweight markup languages.">BlockParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="DefaultEscapedTextParsers.html" title="Default implementation for parsing escape sequences."></a>
                        <a href="DefaultEscapedTextParsers.html" title="Default implementation for parsing escape sequences.">DefaultEscapedTextParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="DefaultRecursiveParsers.html" title="Default implementation for parsing inline markup and blocks recursively."></a>
                        <a href="DefaultRecursiveParsers.html" title="Default implementation for parsing inline markup and blocks recursively.">DefaultRecursiveParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="DefaultRecursiveSpanParsers.html" title="Default implementation for parsing inline markup recursively."></a>
                        <a href="DefaultRecursiveSpanParsers.html" title="Default implementation for parsing inline markup recursively.">DefaultRecursiveSpanParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="DocumentParser$.html" title="Responsible for creating the top level parsers for text markup and template documents, by combining the parser for the root element with a parser for an (optional) configuration header."></a>
                        <a href="DocumentParser$.html" title="Responsible for creating the top level parsers for text markup and template documents, by combining the parser for the root element with a parser for an (optional) configuration header.">DocumentParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="EndDelimiter.html" title="The result in case the end delimiter for the text has been parsed."></a>
                        <a href="EndDelimiter.html" title="The result in case the end delimiter for the text has been parsed.">EndDelimiter</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="EscapedTextParsers.html" title="Provides parsers for escaped text, custom span parser implementations can use these without knowing the rules of the host markup language for escaping text."></a>
                        <a href="EscapedTextParsers.html" title="Provides parsers for escaped text, custom span parser implementations can use these without knowing the rules of the host markup language for escaping text.">EscapedTextParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="InlineDelimiter.html" title="Delimiter implementation for parsing inline spans that distinguishes between a delimiter that marks the end of the span and a delimiter that marks the start of a nested span."></a>
                        <a href="InlineDelimiter.html" title="Delimiter implementation for parsing inline spans that distinguishes between a delimiter that marks the end of the span and a delimiter that marks the start of a nested span.">InlineDelimiter</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="" title="Generic base parser that parses inline elements with potentially nested spans."></a>
                        <a href="" title="Generic base parser that parses inline elements with potentially nested spans.">InlineParser</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="InlineParsers$.html" title="Instance that allows to import all inline parsers in isolation."></a>
                        <a class="trait" href="InlineParsers.html" title="Provides base parsers that abstract aspects of inline parsing common to most lightweight markup languages."></a>
                        <a href="InlineParsers.html" title="Provides base parsers that abstract aspects of inline parsing common to most lightweight markup languages.">InlineParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="InlineResult.html" title="The result of text parsed with an InlineDelimiter."></a>
                        <a href="InlineResult.html" title="The result of text parsed with an InlineDelimiter.">InlineResult</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="NestedDelimiter.html" title="The result in case the start character of a nested span has been parsed."></a>
                        <a href="NestedDelimiter.html" title="The result in case the start character of a nested span has been parsed.">NestedDelimiter</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveBlockParser.html" title="Parses a sequence of blocks based on the available block types of the host markup language."></a>
                        <a href="RecursiveBlockParser.html" title="Parses a sequence of blocks based on the available block types of the host markup language.">RecursiveBlockParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveParsers.html" title="Provides parsers for nested blocks, custom block parser implementations can use these without knowing the available span or block types of the host markup language."></a>
                        <a href="RecursiveParsers.html" title="Provides parsers for nested blocks, custom block parser implementations can use these without knowing the available span or block types of the host markup language.">RecursiveParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveSpanParser.html" title="Parses a sequence of spans based on the available spans types of the host markup language."></a>
                        <a href="RecursiveSpanParser.html" title="Parses a sequence of spans based on the available spans types of the host markup language.">RecursiveSpanParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveSpanParsers.html" title="Provides parsers for nested spans, custom span parser implementations can use these without knowing the available span types of the host markup language."></a>
                        <a href="RecursiveSpanParsers.html" title="Provides parsers for nested spans, custom span parser implementations can use these without knowing the available span types of the host markup language.">RecursiveSpanParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="RootParser.html" title="Responsible of assembling all the block, inline, text and configuration parsers supported by a text markup language."></a>
                        <a href="RootParser.html" title="Responsible of assembling all the block, inline, text and configuration parsers supported by a text markup language.">RootParser</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="trait type">
      <div id="definition">
        <div class="big-circle trait">t</div>
        <p id="owner"><a href="../../index.html" class="extype" name="laika">laika</a>.<a href="../index.html" class="extype" name="laika.parse">parse</a>.<a href="index.html" class="extype" name="laika.parse.markup">markup</a></p>
        <h1>InlineParser<span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">InlineParser</span><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">To</span>]</span><span class="result"> extends <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Generic base parser that parses inline elements with potentially nested spans.</p><p>The two embed methods allow the registration of parsers for nested child spans.
They can be invoked multiple times. Child parsers passed first have higher
precedence than those passed later.</p><p>Only parsers of type <code>PrefixedParser[T]</code> can be passed to the embed methods,
which are parsers with known, stable prefixes of the child span consisting
of a limited set of characters so that the checks that need to be performed
for each character can be optimized for performance.
</p></div><dl class="paramcmts block"><dt class="tparam">Elem</dt><dd class="cmt"><p>the element type produced by a single parser for a nested span</p></dd><dt class="tparam">To</dt><dd class="cmt"><p>the type of the result this parser produces</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>], <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="laika.parse.markup.InlineParser"><span>InlineParser</span></li><li class="in" name="laika.parse.Parser"><span>Parser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        <div class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="laika.parse.markup.InlineParser#embed" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="embed(parser:=&gt;laika.parse.text.PrefixedParser[Elem]):laika.parse.markup.InlineParser[Elem,To]"></a><a id="embed(⇒PrefixedParser[Elem]):InlineParser[Elem,To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#embed(parser:=&gt;laika.parse.text.PrefixedParser[Elem]):laika.parse.markup.InlineParser[Elem,To]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">embed</span><span class="params">(<span name="parser">parser: ⇒ <a href="../text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="laika.parse.markup.InlineParser.Elem">Elem</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.markup.InlineParser">InlineParser</a>[<span class="extype" name="laika.parse.markup.InlineParser.Elem">Elem</span>, <span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      
    </li><li name="laika.parse.markup.InlineParser#embedAll" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="embedAll(parsers:=&gt;Seq[laika.parse.text.PrefixedParser[Elem]]):laika.parse.markup.InlineParser[Elem,To]"></a><a id="embedAll(⇒Seq[PrefixedParser[Elem]]):InlineParser[Elem,To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#embedAll(parsers:=&gt;Seq[laika.parse.text.PrefixedParser[Elem]]):laika.parse.markup.InlineParser[Elem,To]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">embedAll</span><span class="params">(<span name="parsers">parsers: ⇒ <span class="extype" name="scala.Seq">Seq</span>[<a href="../text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="laika.parse.markup.InlineParser.Elem">Elem</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.markup.InlineParser">InlineParser</a>[<span class="extype" name="laika.parse.markup.InlineParser.Elem">Elem</span>, <span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      
    </li><li name="laika.parse.Parser#parse" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="parse(in:laika.parse.SourceCursor):laika.parse.Parsed[T]"></a><a id="parse(SourceCursor):Parsed[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#parse(in:laika.parse.SourceCursor):laika.parse.Parsed[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="params">(<span name="in">in: <a href="../SourceCursor.html" class="extype" name="laika.parse.SourceCursor">SourceCursor</a></span>)</span><span class="result">: <a href="../Parsed.html" class="extype" name="laika.parse.Parsed">Parsed</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the string content in the specified context
and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the string content in the specified context
and returns the result.</p><p>This is the only abstract method in <code>Parser</code> that
concrete implementations need to implement.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li></ol>
            </div>

        <div class="values members">
              <h3>Concrete Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#*" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="*:laika.parse.combinator.Repeat[T]"></a><a id="*:Repeat[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#*:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $times" class="name">*</span><span class="result">: <a href="../combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that repeatedly applies this parser.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that repeatedly applies this parser.
 It will always succeed, potentially with an empty list as the result.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#+" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="+:laika.parse.combinator.Repeat[T]"></a><a id="+:Repeat[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#+:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="name">+</span><span class="result">: <a href="../combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser (at least once).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser (at least once).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#&lt;~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T]"></a><a id="&lt;~[U](Parser[U]):Parser[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#&lt;~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$tilde" class="name">&lt;~</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&lt;~.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser,
 but only keeps the left result.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser,
 but only keeps the left result.</p><p> <code>a &lt;~ b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#&lt;~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;~(value:String):laika.parse.Parser[T]"></a><a id="&lt;~(String):Parser[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#&lt;~(value:String):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$tilde" class="name">&lt;~</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the left result.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the left result.</p><p><code>a &lt;~ b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#&gt;&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&gt;&gt;[U](fq:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="&gt;&gt;[U]((To)⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#&gt;&gt;[U](fq:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $greater$greater" class="name">&gt;&gt;</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="fq">fq: (<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&gt;&gt;.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&gt;&gt;.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Operator synonym for <code>flatMap</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Operator synonym for <code>flatMap</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#?" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="?:laika.parse.Parser[Option[T]]"></a><a id="?:Parser[Option[To]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#?:laika.parse.Parser[Option[T]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $qmark" class="name">?</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that optionally parses what this parser parses.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that optionally parses what this parser parses.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#^^" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="^^[U](f:T=&gt;U):laika.parse.Parser[U]"></a><a id="^^[U]((To)⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#^^[U](f:T=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $up$up" class="name">^^</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>) ⇒ <span class="extype" name="laika.parse.Parser.^^.U">U</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.^^.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> A synonym for <code>map</code>, allowing the grammar to be declared in a concise way.</p><div class="fullcomment"><div class="comment cmt"><p> A synonym for <code>map</code>, allowing the grammar to be declared in a concise way.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#as" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="as[U](v:=&gt;U):laika.parse.Parser[U]"></a><a id="as[U](⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#as[U](v:=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">as</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="v">v: ⇒ <span class="extype" name="laika.parse.Parser.as.U">U</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.as.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that ignores the result of this parser (if it succeeds)
 and returns the specified result instead.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that ignores the result of this parser (if it succeeds)
 and returns the specified result instead.</p><p> Subclasses may override this method to avoid any expensive
 result processing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#collect" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collect[U](f:PartialFunction[T,U],error:T=&gt;String):laika.parse.Parser[U]"></a><a id="collect[U](PartialFunction[To,U],(To)⇒String):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#collect[U](f:PartialFunction[T,U],error:T=&gt;String):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <span class="extype" name="laika.parse.Parser.collect.U">U</span>]</span>, <span name="error">error: (<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>) ⇒ <span class="extype" name="scala.Predef.String">String</span> = <span class="defval" name="r =&gt; s&quot;Constructor function not defined at $r&quot;">...</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.collect.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that applies a partial function to the result of this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that applies a partial function to the result of this parser.</p><p><code>p.collect(f)</code> succeeds if <code>p</code> succeeds and <code>f</code> is defined at the result of <code>p</code>,
In that case it returns <code>f</code> applied to the result of <code>p</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>a partial function that will be applied to this parser's result.</p></dd><dt class="param">error</dt><dd class="cmt"><p>an optional function that takes the same argument as <code>f</code> and produces an error message.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#count" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="count:laika.parse.Parser[Int]"></a><a id="count:Parser[Int]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#count:laika.parse.Parser[Int]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">count</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that produces the number of characters
consumed by this parser while discarding the original result.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that produces the number of characters
consumed by this parser while discarding the original result.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#cursor" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cursor:laika.parse.Parser[laika.parse.SourceFragment]"></a><a id="cursor:Parser[SourceFragment]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#cursor:laika.parse.Parser[laika.parse.SourceFragment]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cursor</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../SourceFragment.html" class="extype" name="laika.parse.SourceFragment">SourceFragment</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Provides a cursor over the input consumed by this parser while discarding the actual result.</p><div class="fullcomment"><div class="comment cmt"><p>Provides a cursor over the input consumed by this parser while discarding the actual result.
Use <code>withCursor</code> if you also need access to the result.</p><p>This is required for parsers that create AST nodes that need to be resolved in a rewrite step
and need to report the source location in case of failure.
It is also required when passing a result of a first-pass parser to a recursive parser
to preserve line positions.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#evalMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalMap[U](f:T=&gt;Either[String,U]):laika.parse.Parser[U]"></a><a id="evalMap[U]((To)⇒Either[String,U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#evalMap[U](f:T=&gt;Either[String,U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalMap</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>) ⇒ <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="laika.parse.Parser.evalMap.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.evalMap.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that applies a function to the result of this parser producing an <code>Either</code>
 where <code>Left</code> is interpreted as failure.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that applies a function to the result of this parser producing an <code>Either</code>
 where <code>Left</code> is interpreted as failure. It is an alternative to <code>^?<code> for scenarios
 where the conditional check cannot be easily performed in a pattern match.</code></code></p><p> <code>p.evalMap(f)</code> succeeds if <code>p</code> succeeds and <code>f</code> returns a <code>Right</code> when applied to the result
 of <code>p</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#flatMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMap[U](f:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="flatMap[U]((To)⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#flatMap[U](f:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.flatMap.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.flatMap.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a new parser by applying the specified function
to the result of this parser and subsequently applying
the parser returned by that function to the input left
over by this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a new parser by applying the specified function
to the result of this parser and subsequently applying
the parser returned by that function to the input left
over by this parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#handleErrorWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="handleErrorWith[U&gt;:To]((Failure)⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleErrorWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.markup.InlineParser.To">To</span></span>]</span><span class="params">(<span name="f">f: (<a href="../Failure.html" class="extype" name="laika.parse.Failure">Failure</a>) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.handleErrorWith.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.handleErrorWith.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Handle any error, potentially recovering from it, by mapping it to a new parser that
will be applied at the same starting position than the failing parser.</p><div class="fullcomment"><div class="comment cmt"><p>Handle any error, potentially recovering from it, by mapping it to a new parser that
will be applied at the same starting position than the failing parser.</p><p>This is similar to the <code>orElse</code> or <code>|</code> method, but allows the alternative
parser to inspect the error of the preceding one.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="../Parser.html#recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]" class="extmbr" name="laika.parse.Parser#recoverWith">recoverWith</a> to recover from only certain errors.</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.Parser#map" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[U](f:T=&gt;U):laika.parse.Parser[U]"></a><a id="map[U]((To)⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#map[U](f:T=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>) ⇒ <span class="extype" name="laika.parse.Parser.map.U">U</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.map.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a new parser by applying the specified function
to the result of this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a new parser by applying the specified function
to the result of this parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#orElse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="orElse[U&gt;:T](p0:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="orElse[U&gt;:To](⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#orElse[U&gt;:T](p0:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">orElse</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.markup.InlineParser.To">To</span></span>]</span><span class="params">(<span name="p0">p0: ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.orElse.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.orElse.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser when this parser fails.</p><p> <code>a orElse b</code> succeeds if either of the parsers succeeds.</p><p> In case both parsers fail, the <code>Failure</code> instance will
 be from the parser with the most successfully read characters.
 In the case of multiple failures having the same number of characters,
 the one with the highest precedence (this parser) will be chosen.</p><p> Implementation note:
 The parameter is by-name to allow the definition of
 recursive parsers. In contrast to the former SDK
 parser combinators this is the only place where
 a parser with a by-name parameter is used whereas
 in all other places the additional cost is avoided.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#parse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse(in:String):laika.parse.Parsed[T]"></a><a id="parse(String):Parsed[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#parse(in:String):laika.parse.Parsed[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="params">(<span name="in">in: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parsed.html" class="extype" name="laika.parse.Parsed">Parsed</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the specified string and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the specified string and returns the result.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#recoverWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]"></a><a id="recoverWith[U&gt;:To](PartialFunction[Failure,Parser[U]]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">recoverWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.markup.InlineParser.To">To</span></span>]</span><span class="params">(<span name="pf">pf: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="../Failure.html" class="extype" name="laika.parse.Failure">Failure</a>, <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.recoverWith.U">U</span>]]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.recoverWith.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Handle certain errors, potentially recovering from it, by mapping them to a new parser that
will be applied at the same starting position than the failing parser.</p><div class="fullcomment"><div class="comment cmt"><p>Handle certain errors, potentially recovering from it, by mapping them to a new parser that
will be applied at the same starting position than the failing parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="../Parser.html#handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" class="extmbr" name="laika.parse.Parser#handleErrorWith">handleErrorWith</a> to handle any/all errors.</p></span></dd></dl></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep(separator:String):laika.parse.combinator.Repeat[T]"></a><a id="rep(String):Repeat[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#rep(separator:String):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="params">(<span name="separator">separator: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser with the specified
separator string between those invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser with the specified
separator string between those invocations.</p><p><code>p.rep(sep).min(1)</code> is equivalent to <code>(p ~ (sep ~&gt; p).rep).concat</code>.</p><p>The returned parser offers an API to specify further constraints
like <code>min</code> or <code>max</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep(separator:laika.parse.Parser[Unit]):laika.parse.combinator.Repeat[T]"></a><a id="rep(Parser[Unit]):Repeat[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#rep(separator:laika.parse.Parser[Unit]):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="params">(<span name="separator">separator: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>)</span><span class="result">: <a href="../combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser with the specified
separator parser between those invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser with the specified
separator parser between those invocations.</p><p><code>p.rep(sep).min(1)</code> is equivalent to <code>(p ~ (sep ~&gt; p).rep).concat</code>.</p><p>The returned parser offers an API to specify further constraints
like <code>min</code> or <code>max</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep:laika.parse.combinator.Repeat[T]"></a><a id="rep:Repeat[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#rep:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="result">: <a href="../combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that repeatedly applies this parser.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that repeatedly applies this parser.
 The returned parser offers an API to specify further constraints
 like <code>min</code> or <code>max</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#repUntil" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repUntil[U](endCondition:laika.parse.Parser[U]):laika.parse.Parser[(List[T],Option[U])]"></a><a id="repUntil[U](Parser[U]):Parser[(List[To],Option[U])]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#repUntil[U](endCondition:laika.parse.Parser[U]):laika.parse.Parser[(List[T],Option[U])]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repUntil</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="endCondition">endCondition: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.repUntil.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>], <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.Parser.repUntil.U">U</span>])]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser until either this parser fails or the specified
end condition is met.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser until either this parser fails or the specified
end condition is met.
The end condition will be applied after each successful invocation of this parser.</p><p>The result of the returned parser is a tuple consisting of the list containing the
result of the invocations of this parser plus the result of the end condition.
The latter is returned as an <code>Option</code> as it might be empty when the parsing finished because of this parser failing.</p><p>Note that it is more convenient to include the end condition in the repeating parser itself and use
the simpler <code>rep</code> method.
This combinator is an alternative if you need to know the result of the end condition.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#repWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repWith[U&gt;:T](next:U=&gt;laika.parse.Parser[U]):laika.parse.Parser[List[U]]"></a><a id="repWith[U&gt;:To]((U)⇒Parser[U]):Parser[List[U]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#repWith[U&gt;:T](next:U=&gt;laika.parse.Parser[U]):laika.parse.Parser[List[U]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.markup.InlineParser.To">To</span></span>]</span><span class="params">(<span name="next">next: (<span class="extype" name="laika.parse.Parser.repWith.U">U</span>) ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.repWith.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.Parser.repWith.U">U</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that invokes the specified function repeatedly,
passing the result of this parser if it succeeds, to produce new
parsers that get applied until one of them fails.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that invokes the specified function repeatedly,
passing the result of this parser if it succeeds, to produce new
parsers that get applied until one of them fails.</p><p>The result of the returned parser is a list containing the
result of this parser (if it succeeds) plus the results of
successful invocations of the parsers returned by the specified
function.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#source" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="source:laika.parse.Parser[String]"></a><a id="source:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#source:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">source</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Retrieves the part of the input consumed by this parser while discarding the result.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves the part of the input consumed by this parser while discarding the result.</p><p>This is useful in scenarios where many string-based parsers are combined and produce a deeply nested result
like <code>String ~ Option[String] ~ List[String]</code> where it would require some boilerplate to concatenate the results.
Using the source method, the entire text consumed by this combination of parsers will be returned.</p><p>If you also need the position within the input or need to pass the result to a recursive parser manually,
use the <code>cursor</code> method instead.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#void" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="void:laika.parse.Parser[Unit]"></a><a id="void:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#void:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">void</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Discards the result of a successful parser.</p><div class="fullcomment"><div class="comment cmt"><p>Discards the result of a successful parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#withCursor" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withCursor:laika.parse.Parser[(T,laika.parse.SourceFragment)]"></a><a id="withCursor:Parser[(To,SourceFragment)]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#withCursor:laika.parse.Parser[(T,laika.parse.SourceFragment)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withCursor</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <a href="../SourceFragment.html" class="extype" name="laika.parse.SourceFragment">SourceFragment</a>)]</span>
      </span>
      
      <p class="shortcomment cmt">Provides the result of this parser together with a cursor over the input,
capturing the consumed source string and its position within the root input.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the result of this parser together with a cursor over the input,
capturing the consumed source string and its position within the root input.
Use <code>cursor</code> if you do not need access to the actual result.</p><p>This is required for parsers that create AST nodes that need to be resolved in a rewrite step
and need to report the source location in case of failure.
It is also required when passing a result of a first-pass parser to a recursive parser
to preserve line positions.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#withFailureMessage" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withFailureMessage(msg:String):laika.parse.Parser[T]"></a><a id="withFailureMessage(String):Parser[To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#withFailureMessage(msg:String):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFailureMessage</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Changes the failure message produced by a parser.</p><div class="fullcomment"><div class="comment cmt"><p> Changes the failure message produced by a parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#|" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="|(value:String)(implicitev:T&lt;:&lt;String):laika.parse.Parser[String]"></a><a id="|(String)(&lt;:&lt;[To,String]):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#|(value:String)(implicitev:T&lt;:&lt;String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bar" class="name">|</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Attempts to parse the specified literal string when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Attempts to parse the specified literal string when this parser fails.</p><p> <code>a | b</code> succeeds if either of the parsers succeeds.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#|" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="|[U&gt;:T](p:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="|[U&gt;:To](⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#|[U&gt;:T](p:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bar" class="name">|</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.markup.InlineParser.To">To</span></span>]</span><span class="params">(<span name="p">p: ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.|.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.|.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser when this parser fails.</p><p> <code>a | b</code> succeeds if either of the parsers succeeds.</p><p> Implementation note:
 The parameter is by-name to allow the definition of
 recursive parsers. In contrast to the former SDK
 parser combinators this is the only place where
 a parser with a by-name parameter is used whereas
 in all other places the additional cost is avoided.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T~U]"></a><a id="~[U](Parser[U]):Parser[~[To,U]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T~U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../../ast/package$$$tilde.html" class="extype" name="laika.ast.~">~</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <span class="extype" name="laika.parse.Parser.~.U">U</span>]]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser
 and combines the two results.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser
 and combines the two results.</p><p> <code>a ~ b</code> only succeeds if both parsers succeed, with the results
 in a wrapper class named <code>~</code> for convenient pattern matching:</p><pre>a ~ b ~ c ^^ {
  <span class="kw">case</span> a ~ b ~ c <span class="kw">=&gt;</span> processResult(a, b, c)
}</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~(value:String):laika.parse.Parser[T~String]"></a><a id="~(String):Parser[~[To,String]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#~(value:String):laika.parse.Parser[T~String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../../ast/package$$$tilde.html" class="extype" name="laika.ast.~">~</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over
by this parser and combines the two results.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over
by this parser and combines the two results.</p><p> <code>a ~ b</code> only succeeds if both parsers succeed, with the results
 in a wrapper class named <code>~</code> for convenient pattern matching:</p><pre>a ~ b ~ c ^^ {
  <span class="kw">case</span> a ~ b ~ c <span class="kw">=&gt;</span> processResult(a, b, c)
}</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~&gt;[U](p:laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="~&gt;[U](Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#~&gt;[U](p:laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde$greater" class="name">~&gt;</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~&gt;.U">U</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~&gt;.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser,
 but only keeps the right result.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser,
 but only keeps the right result.</p><p> <code>a ~&gt; b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li><li name="laika.parse.Parser#~&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~&gt;(value:String):laika.parse.Parser[String]"></a><a id="~&gt;(String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#~&gt;(value:String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde$greater" class="name">~&gt;</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the right result.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the right result.</p><p> <code>a ~&gt; b</code> only succeeds if both parsers succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd></dl></div>
    </li>
              </ol>
            </div>

        

        <div class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="laika.parse.Parser#withContext" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withContext:laika.parse.Parser[(T,laika.parse.SourceFragment)]"></a><a id="withContext:Parser[(To,SourceFragment)]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#withContext:laika.parse.Parser[(T,laika.parse.SourceFragment)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 0.17.0) use withCursor, which is positioned at the beginning of the consumed input">withContext</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <a href="../SourceFragment.html" class="extype" name="laika.parse.SourceFragment">SourceFragment</a>)]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.17.0)</i> use withCursor, which is positioned at the beginning of the consumed input</p></dd></dl></div>
    </li><li name="laika.parse.Parser#withPosition" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withPosition:laika.parse.Parser[(T,laika.parse.Position)]"></a><a id="withPosition:Parser[(To,Position)]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#withPosition:laika.parse.Parser[(T,laika.parse.Position)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 0.17.0) use withCursor which contains the position">withPosition</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <a href="../Position.html" class="extype" name="laika.parse.Position">Position</a>)]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.17.0)</i> use withCursor which contains the position</p></dd></dl></div>
    </li><li name="laika.parse.Parser#withSource" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withSource:laika.parse.Parser[(T,String)]"></a><a id="withSource:Parser[(To,String)]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html#withSource:laika.parse.Parser[(T,String)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 0.17.0) use withCursor which contains the input string">withSource</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>, <span class="extype" name="scala.Predef.String">String</span>)]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a></dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 0.17.0)</i> use withCursor which contains the input string</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="laika.parse.Parser">
              <h3>Inherited from <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
