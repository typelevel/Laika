<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using the Library API</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li><a href="../using-laika/syntax.html">Syntax Highlighting</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="tree-rewriting.html">Document Tree Rewriting</a></li>
          <li class="active"><a href="#">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1>Separate Parsing and Rendering</h1>
        </div>
        <p>The chapter [Using the Library API] introduced the API
        for performing a full transformation from text markup to
        output format. In many cases this is all you need.</p>
        <p>Alternatively the parse and render operations can be executed
        separately, which is useful for special cases when you need to 
        process the document tree before rendering or when parsing 
        and rendering should not happen at the same time or even for
        creating the tree model programmatically instead of reading
        from text input.</p>
        
        <h2 id="the-parser-api" class="section">The Parser API</h2>
        <p>The Parser API is quite similar to the Transform API, but leaves
        out the rendering step.</p>
        
        <h3 id="parsing-a-single-document" class="section">Parsing a Single Document</h3>
        <p>Reading from a String:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">input</span><span> = </span><span class="string-literal">&quot;some *text* example&quot;</span><span>    
</span><span class="keyword">val</span><span> </span><span class="identifier">document</span><span> = </span><span class="type-name">Parser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">parse</span><span>(</span><span class="identifier">input</span><span>)</span></code></pre>
        <p>The <code>document</code> instance gives you the full document model. See
        the <a href="../api/laika/ast/">AST Scaladoc</a> for details.</p>
        <p>The <code>content</code> property of the <code>document</code> instance holds
        the parsed content of the document in the form a tree 
        of case classes.</p>
        <p>You can then specify rewrite
        rules to transform some nodes of the model (see <a href="tree-rewriting.html#document-tree-rewriting">Document Tree Rewriting</a> for 
        details) and use the Render API (explained below) to render
        it to various output formats.</p>
        
        <h3 id="parsing-an-entire-directory" class="section">Parsing an Entire Directory</h3>
        <p>Similar to the full transformation step, you need to specify the <code>ContextShift</code>
        and <code>Blocker</code> to use for blocking IO and parallel processing:</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">cs</span><span>: </span><span class="type-name">ContextShift</span><span>[</span><span class="type-name">IO</span><span>] = 
  </span><span class="type-name">IO</span><span>.</span><span class="identifier">contextShift</span><span>(</span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">global</span><span>)
  
</span><span class="keyword">val</span><span> </span><span class="identifier">blocker</span><span> = </span><span class="type-name">Blocker</span><span>.</span><span class="identifier">liftExecutionContext</span><span>(
  </span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">fromExecutor</span><span>(</span><span class="type-name">Executors</span><span>.</span><span class="identifier">newCachedThreadPool</span><span>())
)</span></code></pre>
        <p>These will then be used to build a parallel parser instance:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="type-name">Parser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>)
  .</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>]
  .</span><span class="identifier">build</span></code></pre>
        <p>Finally, you can obtain a tree instance from the parser:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">tree</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">DocumentTreeRoot</span><span>] = </span><span class="identifier">parser</span><span>
  .</span><span class="identifier">fromDirectory</span><span>(</span><span class="string-literal">&quot;source&quot;</span><span>)
  .</span><span class="identifier">parse</span></code></pre>
        <p>The tree instance is of type <code>DocumentTreeRoot</code> which gives you access
        to all documents, templates and subdirectories contained in the
        parsed directory.</p>
        
        <h3 id="character-encoding" class="section">Character Encoding</h3>
        <p>Laika uses the same platform-dependent defaults for file encodings as the
        IO classes in the Scala SDK. The most convenient way to specify an encoding
        is via an implicit:</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">codec</span><span>:</span><span class="type-name">Codec</span><span> = </span><span class="type-name">Codec</span><span>.</span><span class="type-name">UTF8</span></code></pre>
        <p>This codec will then be used by <code>fromDirectory</code> and other methods 
        shown in the examples above.</p>
        
        <h2 id="the-renderer-api" class="section">The Renderer API</h2>
        <p>The Renderer API is similar to the Transformer API, but expects
        that you already have a document tree model, either obtained
        by a previous parsing step or built programmatically, and now
        want to render it to a specific output format.</p>
        
        <h3 id="reusing-the-parser-configuration" class="section">Reusing the parser configuration</h3>
        <p>In contrast to the Transformer, the Parser and Renderer keep these
        two operations completely separate. However, this also means that the
        renderer does not know about any custom renderers the parser might 
        provide as extensions for rendering custom AST nodes the default renderer
        does not know about.</p>
        <p>For this reason it is always best to copy the parser configuration over
        to the Render API:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="type-name">Parser</span><span>.</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>).</span><span class="identifier">strict</span><span>.</span><span class="identifier">build</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">renderer</span><span> = </span><span class="type-name">Renderer</span><span>.</span><span class="identifier">of</span><span>(</span><span class="type-name">HTML</span><span>).</span><span class="identifier">withConfig</span><span>(</span><span class="identifier">parser</span><span>.</span><span class="identifier">config</span><span>).</span><span class="identifier">build</span></code></pre>
        <p>For the sake of brevity we omit this detail from the following examples.</p>
        
        <h3 id="rendering-a-single-document" class="section">Rendering a Single Document</h3>
        <p>Rendering as a string:</p>
        <pre><code class="nohighlight"><span class="comment">// obtained from a parse step or created programmatically
</span><span class="keyword">val</span><span> </span><span class="identifier">doc</span><span>: </span><span class="type-name">Document</span><span> = ... 

</span><span class="keyword">val</span><span> </span><span class="identifier">res</span><span>: </span><span class="type-name">String</span><span> = </span><span class="identifier">renderer</span><span>.</span><span class="identifier">render</span><span>(</span><span class="identifier">doc</span><span>)</span></code></pre>
        
        <h3 id="rendering-an-entire-directory-as-html" class="section">Rendering an Entire Directory as HTML</h3>
        <p>Like for the Parser and Transformer APIs, you need to specify the <code>ContextShift</code>
        and <code>Blocker</code> to use for blocking IO and parallel processing:</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">cs</span><span>: </span><span class="type-name">ContextShift</span><span>[</span><span class="type-name">IO</span><span>] = 
  </span><span class="type-name">IO</span><span>.</span><span class="identifier">contextShift</span><span>(</span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">global</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">blocker</span><span> = </span><span class="type-name">Blocker</span><span>.</span><span class="identifier">liftExecutionContext</span><span>(
  </span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">fromExecutor</span><span>(</span><span class="type-name">Executors</span><span>.</span><span class="identifier">newCachedThreadPool</span><span>())
)</span></code></pre>
        <p>You can then render the result to a files in a target directory:</p>
        <pre><code class="nohighlight"><span class="comment">// obtained from a parse step or created programmatically
</span><span class="keyword">val</span><span> </span><span class="identifier">tree</span><span>: </span><span class="type-name">DocumentTreeRoot</span><span> = ???

</span><span class="keyword">val</span><span> </span><span class="identifier">renderer</span><span> = </span><span class="type-name">Renderer</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>)
  .</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>]
  .</span><span class="identifier">build</span><span>
    
</span><span class="keyword">val</span><span> </span><span class="identifier">op</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">renderer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="identifier">tree</span><span>)
  .</span><span class="identifier">toDirectory</span><span>(</span><span class="string-literal">&quot;target&quot;</span><span>)
  .</span><span class="identifier">render</span></code></pre>
        <p>The <code>target</code> directory is expected to exist, while any required
        subdirectories will be automatically created during rendering. There
        will be one HTML file for each input file in the same directory layout.</p>
        
        <h3 id="rendering-an-entire-directory-as-pdf" class="section">Rendering an Entire Directory as PDF</h3>
        <pre><code class="nohighlight"><span class="comment">// obtained from a parse step or created programmatically
</span><span class="keyword">val</span><span> </span><span class="identifier">tree</span><span>: </span><span class="type-name">DocumentTreeRoot</span><span> = ???

</span><span class="keyword">val</span><span> </span><span class="identifier">op</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">renderer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="identifier">tree</span><span>)
  .</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;out.pdf&quot;</span><span>)
  .</span><span class="identifier">render</span><span>    </span></code></pre>
        <p>Here the input files get rendered into a single PDF document, with
        the directory structure getting translated into the document structure
        (optionally including bookmarks and table of contents).</p>
        
        <h3 id="character-encoding-1" class="section">Character Encoding</h3>
        <p>Laika uses the same platform-dependent defaults for file encodings as the
        IO classes in the Scala SDK. The most convenient way to specify an encoding
        is via an implicit:</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">codec</span><span>:</span><span class="type-name">Codec</span><span> = </span><span class="type-name">Codec</span><span>.</span><span class="type-name">UTF8</span></code></pre>
        <p>This codec will then be used by <code>toDirectory</code> and other methods 
        shown in the examples above.</p>      

      </div>
    </div>

  </div>

</body></html>
