<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using Laika Embedded</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="tree-rewriting.html">Document Tree Rewriting</a></li>
          <li class="active"><a href="#">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
          <h1>Separate Parsing and Rendering</h1>
        </div>
        <p>The chapter [Using Laika Embedded] introduced the API
        for performing a full transformation from text markup to
        output format. In many cases this is all you need.</p>
        <p>Alternatively the parse and render operations can be executed
        separately, which is useful for special cases when you need to 
        process the document tree before rendering or when parsing 
        and rendering should not happen at the same time or even for
        creating the tree model programmatically instead of reading
        from text input.</p>
        
        <h2 id="the-parse-api" class="section">The Parse API</h2>
        <p>The Parse API is quite similar to the Transform API, but leaves
        out the rendering step.</p>
        
        <h3 id="parsing-a-single-document" class="section">Parsing a Single Document</h3>
        <p>Reading from a file:</p>
        <pre>val document = Parse as Markdown fromFile &quot;hello.md&quot;
</pre>
        <p>Reading from a String:</p>
        <pre>val input = &quot;some *text* example&quot;    
val document = Parse as Markdown fromString input
</pre>
        <p>The <code>document</code> instance gives you the full document model. See
        the <a href="../api/laika/ast/">AST Scaladoc</a> for details.</p>
        <p>The <code>content</code> property of the <code>document</code> instance holds
        the parsed content of the document in the form a tree 
        of case classes.</p>
        <p>You can then specify rewrite
        rules to transform some nodes of the model (see <a href="tree-rewriting.html#document-tree-rewriting">Document Tree Rewriting</a> for 
        details) and use the Render API (explained below) to render
        it to various output formats.</p>
        
        <h3 id="parsing-an-entire-directory" class="section">Parsing an Entire Directory</h3>
        <pre>val tree = Parse as Markdown fromDirectory &quot;source&quot;
</pre>
        <p>The tree instance is of type <code>DocumentTree</code> which gives you access
        to all documents, templates and subdirectories contained in the
        parsed directory.</p>
        
        <h3 id="parallel-execution" class="section">Parallel Execution</h3>
        <p>Like with a full transformation, parsing can be performed in parallel:</p>
        <pre>Parse.as(Markdown).inParallel.fromDirectory(&quot;source&quot;)</pre>
        <p>When specifying options like parallel execution, you cannot use
        the <code>fromDirectory</code> shortcut like in the previous example, but
        instead use the <code>Directory</code> entry point to the full configuration
        API. Apart from parallel execution, it allows to specify a custom
        template engine, a custom document type matcher, and more.</p>
        
        <h3 id="reusing-parsers" class="section">Reusing Parsers</h3>
        <p>Like with the Transform API, all objects are reusable and immutable:</p>
        <pre>val parse = Parse as ReStructuredText

val doc1 = parse fromFile &quot;input1.rst&quot;
val doc2 = parse fromFile &quot;input2.rst&quot;</pre>
        
        <h3 id="character-encoding" class="section">Character Encoding</h3>
        <p>Laika uses the same platform-dependent defaults for file encodings as the
        IO classes in the Scala SDK. The most convenient way to specify an encoding
        is via an implicit:</p>
        <pre>implicit val codec:Codec = Codec.UTF8</pre>
        <p>This codec will then be used by <code>fromDirectory</code> and other methods 
        shown in the examples above.</p>
        
        <h2 id="the-render-api" class="section">The Render API</h2>
        <p>The Render API is similar to the Transform API, but expects
        that you already have a document tree model, either obtained
        by a previous parsing step or built programmatically, and now
        want to render it to a specific output format.</p>
        
        <h3 id="reusing-the-parser-configuration" class="section">Reusing the parser configuration</h3>
        <p>In contrast to the Transform API, the Parse and Render APIs keep these
        two operations completely separate. However, this also means that the
        renderer does not know about any custom renderers the parser might 
        provide as extensions for rendering custom AST nodes the default renderer
        does not know about.</p>
        <p>For this reason it is always best to copy the parser configuration over
        to the Render API:</p>
        <pre>val parser = Parse.as(Markdown).strict

val doc = parse.fromFile(&quot;foo.md&quot;)

Render.as(HTML).withConfig(parser.config).toFile(&quot;hello.html&quot;)</pre>
        <p>For the sake of brevity we omit this detail from the following examples.</p>
        
        <h3 id="rendering-a-single-document" class="section">Rendering a Single Document</h3>
        <p>Rendering to a file:</p>
        <pre>// obtained from a parse step or created programmatically
val doc: Document = ... 

Render as HTML from doc toFile &quot;hello.html&quot;
</pre>
        <p>Or to obtain the HTML as a string:</p>
        <pre>val html = Render as HTML from doc toString
</pre>
        
        <h3 id="rendering-an-entire-directory-as-html" class="section">Rendering an Entire Directory as HTML</h3>
        <pre>// obtained from a parse step or created programmatically
val tree: DocumentTree = ...

Render as HTML from tree toDirectory &quot;path/to/target&quot;</pre>
        <p>The <code>target</code> directory is expected to exist, while any required
        subdirectories will be automatically created during rendering. There
        will be one HTML file for each input file in the same directory layout.</p>
        
        <h3 id="rendering-an-entire-directory-as-pdf" class="section">Rendering an Entire Directory as PDF</h3>
        <pre>// obtained from a parse step or created programmatically
val tree: DocumentTree = ...

Render as PDF from tree toFile &quot;out.pdf&quot;
</pre>
        <p>Here the input files get rendered into a single PDF document, with
        the directory structure getting translated into the document structure
        (optionally including bookmarks and table of contents).</p>
        
        <h3 id="parallel-execution-1" class="section">Parallel Execution</h3>
        <p>Like with a full transformation, rendering can be performed in parallel:</p>
        <pre>val tree: DocumentTree = ...

Render.as(HTML).inParallel.from(tree).toDirectory(&quot;source&quot;)</pre>
        
        <h3 id="reusing-renderers" class="section">Reusing Renderers</h3>
        <p>Like with the Transform API, all objects are reusable and immutable:</p>
        <pre>val document = ...

val render = Render as HTML from document

render toFile &quot;output1.html&quot;
render toFile &quot;output2.html&quot;
</pre>
        
        <h3 id="character-encoding-1" class="section">Character Encoding</h3>
        <p>Laika uses the same platform-dependent defaults for file encodings as the
        IO classes in the Scala SDK. The most convenient way to specify an encoding
        is via an implicit:</p>
        <pre>implicit val codec:Codec = Codec.UTF8</pre>
        <p>This codec will then be used by <code>toDirectory</code> and other methods 
        shown in the examples above.</p>      

      </div>
    </div>

  </div>

</body></html>
