<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using Laika Embedded</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="customize-rendering.html">Customizing Renderers</a></li>
          <li class="active"><a href="#">Document Tree Rewriting</a></li>
          <li><a href="parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://www.planet42.org/laika/webtool">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
          <h1>Document Tree Rewriting</h1>
        </div>
        <p>The document tree in a Laika transformation is a generic representation
        of the document that does not contain any specific semantic or technical coupling to a concrete
        input or output format. This allows to add custom processing logic only
        operating on the tree itself, so it can be used with all supported input and output
        formats unchanged.</p>
        <p>Rewriting a tree means traversing it and replacing or removing some of its nodes.
        A tree model is immutable, so rewriting always creates a new tree, while
        reusing unmodified branches for efficiency.</p>
        <p>The purpose of this facility is to provide a way to support basic tree rewriting
        needs without introducing additional dependencies. If you have more sophisticated
        requirements, you can alternatively use <a href="http://code.google.com/p/kiama/wiki/UserManual">Kiama</a>, a language processing library that
        also supports rewriting. According to their documentation Kiama should be compatible
        with Laika as they support tree models consisting of <code>Product</code> instances
        (which all case classes are). </p>
        
        <h2 id="how-rewrite-rules-work" class="section">How Rewrite Rules Work</h2>
        <p>A rewrite rule has the type <code>PartialFunction[Element,Option[Element]]</code>. Laika offers
        a type alias <code>RewriteRule</code> for convenience.</p>
        <p>The partial function expects an <code>Element</code> and returns an <code>Option[Element]</code>.
        The rules are as follows:</p>
        <ul>
          <li>
            <p>If the function is not defined for a particular element the old element is kept in the tree.</p>
          </li>
          <li>
            <p>If the function returns <code>Some(Element)</code> this element is used in place of the old one.</p>
          </li>
          <li>
            <p>If the function returns <code>None</code> the old element is removed from the tree.</p>
          </li>
          <li>
            <p>Processing happens depth-first (bottom-up), so all nodes getting passed to this function
            already had their children getting processed.</p>
          </li>
          <li>
            <p>The tree is immutable, so new instances are returned when rewriting, but unmodified
            branches are reused.</p>
          </li>
          <li>
            <p>Therefore, if the rule does not affect any child node, the rule will simply return
            the old root node. </p>
          </li>
        </ul>
        <p>The following sections show the three ways to apply such a rule.</p>
        
        <h2 id="applying-a-rewrite-rule" class="section">Applying a Rewrite Rule</h2>
        <p>The mechanism is slightly different, depending on whether you are using the sbt
        plugin or Laika embedded in an application. In the latter case you have two
        choices, one for hooking into a full transformation, the other for operating
        on nodes obtained by a separate parse operation. All three options are described below.</p>
        
        <h3 id="using-the-sbt-plugin" class="section">Using the sbt Plugin</h3>
        <p>The following example of an sbt build file shows how to turn each <code>Emphasized</code> node
        into a <code>Strong</code> node while processing everything else with default rules:</p>
        <pre>import LaikaKeys._
import laika.tree.Elements._

// ... your standard build stuff

LaikaPlugin.defaults

rewriteRules in Laika += rewriteRule { 
  case Emphasized(content, opts) =&gt; Some(Strong(content, opts))
}</pre>
        
        <h3 id="using-the-transform-api" class="section">Using the Transform API</h3>
        <p>When using Laika embedded and all you want to do is to perform a full transformation 
        from some input text to some output format, the Transform API offers a hook to do this 
        in one go, as a step in the transformation process.</p>
        <p>Again we replace all <code>Emphasized</code> nodes with <code>Strong</code> nodes:</p>
        <pre>Transform from ReStructuredText to HTML usingRule {
  case Emphasized(content, opts) =&gt; Some(Strong(content, opts))
} fromFile &quot;hello.rst&quot; toFile &quot;hello.html&quot;</pre>
        
        <h3 id="working-with-the-tree-model" class="section">Working with the Tree Model</h3>
        <p>The final option is for splitting the parse and render operations
        and working with the tree model directly between these operations.
        For obtaining a document tree see <a href="parsing-rendering.html#separate-parsing-and-rendering">Separate Parsing and Rendering</a>.</p>
        <p>Often a rule gets applied to the whole <code>Document</code> instance, but other container
        types support rewriting, too, so you can also apply it to elements like <code>Paragraph</code> or <code>ListItem</code>.</p>
        <p>Once again we are turning all <code>Emphasized</code> nodes in the text to <code>Strong</code> nodes:</p>
        <pre>val doc: Document = ... // obtained through the Parse API

val newDoc = doc rewrite {
  case Emphasized(content, opts) =&gt; Some(Strong(content, opts))
}</pre>
        <p>For a slightly more advanced example, let&#39;s assume you only want to replace <code>Emphasized</code>
        nodes inside headers. To accomplish this you need to nest a rewrite operation
        inside another one:</p>
        <pre>val newDoc = doc rewrite {
  case h: Header =&gt; Some(h rewrite {
    case Emphasized(content, opts) =&gt; Some(Strong(content, opts))
  })
}</pre>      

      </div>
    </div>

  </div>

</body></html>
